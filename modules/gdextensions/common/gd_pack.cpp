/**************************************************************************/
/*  gd_pack.cpp                                                           */
/**************************************************************************/
/*                         This file is part of:                          */
/*                             GODOT ENGINE                               */
/*                        https://godotengine.org                         */
/**************************************************************************/
/* Copyright (c) 2014-present Godot Engine contributors (see AUTHORS.md). */
/* Copyright (c) 2007-2014 Juan Linietsky, Ariel Manzur.                  */
/*                                                                        */
/* Permission is hereby granted, free of charge, to any person obtaining  */
/* a copy of this software and associated documentation files (the        */
/* "Software"), to deal in the Software without restriction, including    */
/* without limitation the rights to use, copy, modify, merge, publish,    */
/* distribute, sublicense, and/or sell copies of the Software, and to     */
/* permit persons to whom the Software is furnished to do so, subject to  */
/* the following conditions:                                              */
/*                                                                        */
/* The above copyright notice and this permission notice shall be         */
/* included in all copies or substantial portions of the Software.        */
/*                                                                        */
/* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,        */
/* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF     */
/* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. */
/* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY   */
/* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,   */
/* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE      */
/* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                 */
/**************************************************************************/

#include "gd_pack.h"

#ifdef DOCTEST
#include "doctest/doctest.h"
#else
#define DOCTEST_CONFIG_DISABLE
#endif

// just add another comparing function name to cmpf to perform another packing attempt
// more functions == slower but probably more efficient cases covered and hence less area wasted

static bool (*cmpf[])(rect_xywhf *, rect_xywhf *) = {
	area,
	perimeter,
	max_side,
	max_width,
	max_height
};

// if you find the algorithm running too slow you may double this factor to increase speed but also decrease efficiency
// 1 == most efficient, slowest
// efficiency may be still satisfying at 64 or even 256 with nice speedup

static const int discard_step = 128;

// For every sorting function, algorithm will perform packing attempts beginning with a bin with width and height equal to max_side,
// and decreasing its dimensions if it finds out that rectangles did actually fit, increasing otherwise.
// Although, it's doing that in sort of binary search manner, so for every comparing function it will perform at most log2(max_side) packing attempts looking for the smallest possible bin size.
// discard_step = 128 means that the algorithm will break of the searching loop if the rectangles fit but "it may be possible to fit them in a bin smaller by 128"
// the bigger the value, the sooner the algorithm will finish but the rectangles will be packed less tightly.
// use discard_step = 1 for maximum tightness.
//
// the algorithm was based on http://www.blackpawn.com/texts/lightmaps/default.html
// the algorithm reuses the node tree so it doesn't reallocate them between searching attempts

struct node {
	struct pnode {
		node *pn = nullptr;
		bool fill = false;

		void set(int l, int t, int r, int b) {
			if (!pn)
				pn = new node(rect_ltrb(l, t, r, b));
			else {
				(*pn).rc = rect_ltrb(l, t, r, b);
				(*pn).id = false;
			}
			fill = true;
		}
	};

	pnode c[2];
	rect_ltrb rc;
	bool id = false;
	node(rect_ltrb rc = rect_ltrb()) :
			rc(rc) {}

	void reset(const rect_wh &r) {
		id = false;
		rc = rect_ltrb(0, 0, r.w(), r.h());
		delcheck();
	}

	node *insert(rect_xywhf &img, bool allow_flip) {
		if (c[0].pn && c[0].fill) {
			if (auto newn = c[0].pn->insert(img, allow_flip)) {
				return newn;
			}
			return c[1].pn->insert(img, allow_flip);
		}

		if (id) {
			return 0;
		}
		const int f = img.fits(rect_xywh(rc), allow_flip);

		switch (f) {
			case 0:
				return 0;
			case 1: {
				img.flipped = false;
			} break;
			case 2: {
				img.flipped = true;
			} break;
			case 3:
				id = true;
				img.flipped = false;
				return this;
			case 4:
				id = true;
				img.flipped = true;
				return this;
		}

		int iw = (img.flipped ? img.h() : img.w()), ih = (img.flipped ? img.w() : img.h());

		if (rc.w() - iw > rc.h() - ih) {
			c[0].set(rc.l, rc.t, rc.l + iw, rc.b);
			c[1].set(rc.l + iw, rc.t, rc.r, rc.b);
		} else {
			c[0].set(rc.l, rc.t, rc.r, rc.t + ih);
			c[1].set(rc.l, rc.t + ih, rc.r, rc.b);
		}

		return c[0].pn->insert(img, allow_flip);
	}

	void delcheck() {
		if (c[0].pn) {
			c[0].fill = false;
			c[0].pn->delcheck();
		}
		if (c[1].pn) {
			c[1].fill = false;
			c[1].pn->delcheck();
		}
	}

	~node() {
		if (c[0].pn) {
			delete c[0].pn;
		}
		if (c[1].pn) {
			delete c[1].pn;
		}
	}
};

static rect_wh _rect_2d(rect_xywhf *const *v, int n, int max_s, bool allow_flip, std::vector<rect_xywhf *> &succ, std::vector<rect_xywhf *> &unsucc) {
	node root;

	const int funcs = (sizeof(cmpf) / sizeof(bool (*)(rect_xywhf *, rect_xywhf *)));

	rect_xywhf **order[funcs];

	for (int f = 0; f < funcs; f++) {
		order[f] = new rect_xywhf *[n];
		std::memcpy(order[f], v, sizeof(rect_xywhf *) * n);
		std::sort(order[f], order[f] + n, cmpf[f]);
	}

	rect_wh min_bin = rect_wh(max_s, max_s);
	int min_func = -1, best_func = 0, best_area = 0, _area = 0, step, fit;

	bool fail = false;

	for (int f = 0; f < funcs; ++f) {
		v = order[f];
		step = min_bin.w() / 2;
		root.reset(min_bin);

		while (true) {
			if (root.rc.w() > min_bin.w()) {
				if (min_func > -1) {
					break;
				}
				_area = 0;

				root.reset(min_bin);
				for (int i = 0; i < n; ++i) {
					if (root.insert(*v[i], allow_flip)) {
						_area += v[i]->area();
					}
				}
				fail = true;
				break;
			}

			fit = -1;

			for (int i = 0; i < n; ++i) {
				if (!root.insert(*v[i], allow_flip)) {
					fit = 1;
					break;
				}
			}

			if (fit == -1 && step <= discard_step) {
				break;
			}

			root.reset(rect_wh(root.rc.w() + fit * step, root.rc.h() + fit * step));

			step /= 2;
			if (!step) {
				step = 1;
			}
		}

		if (!fail && (min_bin.area() >= root.rc.area())) {
			min_bin = rect_wh(root.rc);
			min_func = f;
		} else if (fail && (_area > best_area)) {
			best_area = _area;
			best_func = f;
		}
		fail = false;
	}

	v = order[min_func == -1 ? best_func : min_func];

	int clip_x = 0, clip_y = 0;

	root.reset(min_bin);

	for (int i = 0; i < n; ++i) {
		if (auto ret = root.insert(*v[i], allow_flip)) {
			v[i]->x = ret->rc.l;
			v[i]->y = ret->rc.t;

			if (v[i]->flipped) {
				v[i]->flipped = false;
				v[i]->flip();
			}

			clip_x = std::max(clip_x, ret->rc.r);
			clip_y = std::max(clip_y, ret->rc.b);

			succ.push_back(v[i]);
		} else {
			unsucc.push_back(v[i]);

			v[i]->flipped = false;
		}
	}

	for (int f = 0; f < funcs; ++f) {
		delete[] order[f];
	}

	return rect_wh(clip_x, clip_y);
}

static rect_wh _try_rects_2d(rect_xywhf *const *v, int n, bool allow_flip) {
	int max_side = 0, min_side = 32;

	// start from biggest side
	for (int i = 0; i < n; i++) {
		if (v[i]->w() > max_side) {
			max_side = v[i]->w();
		}
		if (v[i]->h() > max_side) {
			max_side = v[i]->h();
		}
		if (v[i]->w() > 0 && v[i]->w() < min_side) {
			min_side = v[i]->w();
		}
		if (v[i]->h() > 0 && v[i]->h() < min_side) {
			min_side = v[i]->h();
		}
	}

	while (true) {
		rect_wh _rect(max_side, max_side);

		std::vector<rect_xywhf *> vec[2], *p[2] = { vec, vec + 1 }, rects;
		vec[0].resize(n);
		vec[1].clear();
		std::memcpy(&vec[0][0], v, sizeof(rect_xywhf *) * n);

		rect_wh size = _rect_2d(&((*p[0])[0]), static_cast<int>(p[0]->size()), max_side, allow_flip, rects, *p[1]);
		if (!p[1]->size()) { // no unfitted items - finish
			return size; // pack size
		}

		max_side += min_side;
	}

	return { 0, 0 };
}

static bool _pack_rects(rect_xywhf *const *v, int n, int max_side, bool single_page, bool allow_flip, std::vector<bin> &bins) {
	real_t req_max_side = max_side;
	if (max_side <= 0 || single_page) {
		const rect_wh rc = _try_rects_2d(v, n, allow_flip);
		max_side = rc.w();
		if (max_side <= 0) {
			return false;
		}
		print_verbose(vformat("Autofit packing success: %dx%d", rc.w(), rc.h()));
	}

	if (req_max_side <= 0) {
		req_max_side = max_side;
	}

	if (single_page && req_max_side > 0 && max_side > req_max_side) {
		// find scale to fit in max_side
		int max_area = 0;
		for (int i = 0; i < n; i++) {
			const int area = v[i]->area();
			if (area > max_area) {
				max_area = area;
			}
		}
		const real_t step = 0.01;
		real_t base_scale = 1.5;
		int last_max_side = 0;
		do {
			for (int i = 0; i < n; i++) {
				const real_t area = v[i]->_w * v[i]->_h;
				v[i]->scale = 1.0 - base_scale * (area / max_area);
				v[i]->scale = base_scale - (area / max_area);
				ERR_FAIL_COND_V(v[i]->scale <= 0, false);
			}
			max_side = _try_rects_2d(v, n, allow_flip).w();
			print_verbose(vformat("Autoscaling iteration: scale %0.2f -> side %d", base_scale, max_side));
			if (last_max_side && last_max_side - max_side != 0) {
				const real_t diff = (last_max_side - max_side) / real_t(req_max_side); // % difference between iterations
				const real_t need = (req_max_side - max_side) / real_t(req_max_side);
				const int iters = Math::ceil(need / diff);
				if (Math::abs(iters) > 2) { // if estimation shows more iterations are needed increase step one-time
					base_scale += step * iters;
				} else {
					base_scale += step * SIGN2(iters);
				}
			} else {
				base_scale -= step;
			}
			last_max_side = max_side;
		} while (max_side > req_max_side);
	}

	rect_wh _rect(max_side, max_side);
	for (int i = 0; i < n; i++) {
		if (!v[i]->fits(_rect, allow_flip)) {
			return false;
		}
	}

	std::vector<rect_xywhf *> vec[2], *p[2] = { vec, vec + 1 };
	vec[0].resize(n);
	vec[1].clear();
	std::memcpy(&vec[0][0], v, sizeof(rect_xywhf *) * n);

	while (true) {
		bins.push_back(bin());
		bin *b = &bins[bins.size() - 1];

		b->size = _rect_2d(&((*p[0])[0]), static_cast<int>(p[0]->size()), max_side, allow_flip, b->rects, *p[1]);
		p[0]->clear();

		if (!p[1]->size()) { // no unfitted items - finish
			break;
		}

		std::swap(p[0], p[1]); // continue with new bin
	}

	return true;
}

static int _get_offset_for_format(Image::Format format) {
	switch (format) {
		case Image::FORMAT_RGB8:
			return 3;
		case Image::FORMAT_RGBA8:
			return 4;
		case Image::FORMAT_LA8:
			return 2;
		case Image::FORMAT_A8:
			return 1;
		case Image::FORMAT_L8:
			return 1;
		case Image::FORMAT_R8:
		case Image::FORMAT_RG8:
		case Image::FORMAT_RGBA4444:
		case Image::FORMAT_RF:
		case Image::FORMAT_RGF:
		case Image::FORMAT_RGBF:
		case Image::FORMAT_RGBAF:
		case Image::FORMAT_RH:
		case Image::FORMAT_RGH:
		case Image::FORMAT_RGBH:
		case Image::FORMAT_RGBAH:
		case Image::FORMAT_RGBE9995:
		case Image::FORMAT_DXT1:
		case Image::FORMAT_DXT3:
		case Image::FORMAT_DXT5:
		case Image::FORMAT_RGTC_R:
		case Image::FORMAT_RGTC_RG:
		case Image::FORMAT_BPTC_RGBA:
		case Image::FORMAT_BPTC_RGBF:
		case Image::FORMAT_BPTC_RGBFU:
		case Image::FORMAT_PVRTC2:
		case Image::FORMAT_PVRTC2A:
		case Image::FORMAT_PVRTC4:
		case Image::FORMAT_PVRTC4A:
		case Image::FORMAT_ETC:
		case Image::FORMAT_ETC2_R11:
		case Image::FORMAT_ETC2_R11S:
		case Image::FORMAT_ETC2_RG11:
		case Image::FORMAT_ETC2_RG11S:
		case Image::FORMAT_ETC2_RGB8:
		case Image::FORMAT_ETC2_RGBA8:
		case Image::FORMAT_ETC2_RGB8A1:
#if VERSION_MAJOR >= 4
		case Image::FORMAT_RGB565:
		case Image::FORMAT_ETC2_RA_AS_RG:
		case Image::FORMAT_DXT5_RA_AS_RG:
#else
		case Image::FORMAT_RGBA5551:
#endif
		case Image::FORMAT_MAX:
			return 0;
	}

	return 0;
}

// mirror borders to avoid leaking outside pixels when filtering
static Ref<Image> _mirror_borders(Ref<Image> image, int x_border, int y_border) {
	ERR_FAIL_COND_V(image.is_null(), Ref<Image>());

	int bx = MAX(0, x_border - 1);
	int by = MAX(0, y_border - 1);
	Size2 rc = image->get_size();

	Ref<Image> form = memnew(Image);
	form->create(image->get_size().width + 2 * x_border, image->get_size().height + 2 * y_border, false, image->get_format());

	auto get_rect = [](Ref<Image> img) {
		return Rect2(Point2(0, 0), img->get_size());
	};

	// copy borders:
	const auto topb = image->get_rect(Rect2(0, 0, rc.width, 1));
	const auto botb = image->get_rect(Rect2(0, rc.height - 1, rc.width, 1));
	const auto leftb = image->get_rect(Rect2(0, 0, 1, rc.height));
	const auto rightb = image->get_rect(Rect2(rc.width - 1, 0, 1, rc.height));

	// copy corner pixels:
	image->lock();
	const auto topp = image->get_pixel(0, 0);
	const auto botp = image->get_pixel(0, rc.height - 1);
	const auto leftp = image->get_pixel(rc.width - 1, rc.height - 1);
	const auto rightp = image->get_pixel(rc.width - 1, 0);
	image->unlock();

	// place image:
	form->blit_rect(image, get_rect(image), Point2(x_border, y_border));

	// duplicate borders around the image:
	for (int k = 0; k < by; k++) {
		form->blit_rect(topb, get_rect(topb), Point2(x_border, y_border - k - 1)); // top
	}
	for (int k = 0; k < by; k++) {
		form->blit_rect(botb, get_rect(botb), Point2(x_border, rc.height - y_border + k)); // bottom
	}
	for (int k = 0; k < bx; k++) {
		form->blit_rect(leftb, get_rect(leftb), Point2(x_border - k - 1, y_border)); // left
	}
	for (int k = 0; k < bx; k++) {
		form->blit_rect(rightb, get_rect(rightb), Point2(rc.width - x_border + k, y_border)); // right
	}

	form->lock();
	// fill up corners:
	for (int k = 0; k < by; k++) {
		for (int m = 0; m < bx; m++) {
			form->set_pixel(x_border - m - 1, y_border - k - 1, topp);
			form->set_pixel(x_border - m - 1, rc.height - y_border + k, botp);
			form->set_pixel(rc.width - x_border + m, rc.height - y_border + k, leftp);
			form->set_pixel(rc.width - x_border + m, y_border - k - 1, rightp);
		}
	}
	form->unlock();

	return form;
}

Dictionary merge_images(const Vector<Ref<Image>> &images, const ImageMergeOptions &options) {
	if (images.empty()) {
		return Dictionary(); // exit early
	}

	const int margin = options.margin;
	const Color background_color = options.background_color;

	// NOTICE: atlas texture can be 1, 3 or 4 channels only
	int atlas_channels = 1;

	const int n = images.size();

	Vector<rect_xywhf> data;
	data.resize(n);
	Vector<rect_xywhf *> rects;
	rects.resize(n);

	for (int i = 0; i < images.size(); ++i) {
		Ref<Image> image = images[i];
		if (image->get_size().width == 0 || image->get_size().height == 0) {
			WARN_PRINT("Image " + itos(i) + " is empty");
		}
		if (margin > 0) {
			image = _mirror_borders(image, margin, margin);
		}
		data.write[i].original_image = image;
		data.write[i].x = 0;
		data.write[i].y = 0;
		data.write[i]._w = image->get_size().width;
		data.write[i]._h = image->get_size().height;
		data.write[i].scale = 1;
		rects.write[i] = &data.write[i];
		if (image->get_format() == Image::FORMAT_L8) {
			atlas_channels = MAX(1, atlas_channels);
		} else if (image->get_format() == Image::FORMAT_RGBA8 || image->get_format() == Image::FORMAT_LA8) {
			// only if we have a real alpha values in the channel
			if (image->detect_alpha() == Image::ALPHA_BLEND) {
				atlas_channels = 4;
			}
		}
	}

	if (options.force_atlas_channels > 0) {
		atlas_channels = options.force_atlas_channels;
	}

	ERR_FAIL_COND_V(atlas_channels < 1 || atlas_channels > 4, Dictionary());

	Image::Format atlas_format = atlas_channels == 1 ? Image::FORMAT_L8 : atlas_channels == 3 ? Image::FORMAT_RGB8
																							  : Image::FORMAT_RGBA8;

	Array generated_images;
	std::vector<bin> bins;
	Dictionary ret;

	if (_pack_rects(rects.ptr(), rects.size(), options.max_atlas_size, options.force_single_page_atlas, false, bins)) {
		generated_images.clear();
		generated_images.resize(bins.size());

		for (int i = 0; i < bins.size(); ++i) {
			const bin b = bins[i];

			const Size2 atlas_size = b.size.size();
			PoolByteArray atlas_data;
			atlas_data.resize(atlas_size.width * atlas_size.height * atlas_channels);

			// Setup background color
			const uint8_t cr = background_color.r * 255.0;
			const uint8_t cg = background_color.g * 255.0;
			const uint8_t cb = background_color.b * 255.0;
			const uint8_t ca = background_color.a * 255.0;

			for (int j = 0; j < atlas_data.size(); j += atlas_channels) {
				if (atlas_channels == 1) {
					static uint8_t c = (cr + cg + cb) / 3;
					atlas_data.set(j, c);
				} else {
					atlas_data.set(j, cr);
					atlas_data.set(j + 1, cg);
					atlas_data.set(j + 2, cb);
					if (atlas_channels == 4) {
						atlas_data.set(j + 3, ca);
					}
				}
			}

			Ref<Image> atlas;
			atlas.instance();

			// Process rects
			for (int j = 0; j < b.rects.size(); ++j) {
				rect_xywhf *r = b.rects[j];

				r->bin = i;
				r->atlas_image = atlas;

				int rect_pos_x = 0;
				int rect_pos_y = 0;

				Ref<Image> img = r->original_image;
				if (r->scale != 1) {
					img = img->resized(r->w(), r->h());
				}

				ERR_CONTINUE(!img.is_valid());

				const Size2 image_size = img->get_size();
				PoolByteArray image_data = img->get_data();

				int input_format_offset = _get_offset_for_format(img->get_format());

				ERR_CONTINUE_MSG(input_format_offset == 0, "Image format is not supported, skipping.");

				for (int y = 0; y < r->h(); ++y) {
					const int orig_img_indx = (rect_pos_y + y) * image_size.width * input_format_offset + rect_pos_x * input_format_offset;
					const int start_indx = (r->y + y) * atlas_size.width * atlas_channels + r->x * atlas_channels;

					for (int x = 0; x < r->w(); ++x) {
						switch (input_format_offset) {
							case 4:
							case 3: {
								for (int sx = 0; sx < input_format_offset; ++sx) {
									atlas_data.set(start_indx + (x * atlas_channels) + sx, image_data[orig_img_indx + sx + (x * input_format_offset)]);
								}
							} break;
							case 2: {
								// grey + alpha
								for (int sx = 0; sx < 4; ++sx) {
									if (sx == 3 && atlas_channels == 4) {
										atlas_data.set(start_indx + (x * atlas_channels) + sx, image_data[orig_img_indx + 1 + (x * input_format_offset)]);
									} else {
										atlas_data.set(start_indx + (x * atlas_channels) + sx, image_data[orig_img_indx + 0 + (x * input_format_offset)]);
									}
								}
							} break;
							case 1: {
								// alpha
								const uint8_t a = image_data[orig_img_indx + (x * input_format_offset)];
								if (atlas_channels == 1) {
									atlas_data.set(start_indx + x, a);
								} else {
									for (int sx = 0; sx < 4; ++sx) {
										if (sx == 3 && atlas_channels == 4) {
											atlas_data.set(start_indx + (x * atlas_channels) + sx, a);
										} else {
											if (atlas_channels == 4) {
												atlas_data.set(start_indx + (x * atlas_channels) + sx, 255);
											} else if (atlas_channels == 3) {
												atlas_data.set(start_indx + (x * atlas_channels) + sx, a);
											}
										}
									}
								}
							}
						}
					}
				}
			}

			atlas->create(atlas_size.width, atlas_size.height, false, atlas_format, atlas_data);
			generated_images.set(i, atlas);
		}

		Array atlas_rects;
		ERR_FAIL_COND_V(atlas_rects.resize(data.size()) != OK, Dictionary());
		for (int r = 0; r < data.size(); ++r) {
			const rect_xywhf &rc = data[r];
			Dictionary entry;
			entry["rect"] = Rect2(rc.x + margin, rc.y + margin, rc.w() - 2 * margin, rc.h() - 2 * margin);
			entry["rrect"] = Rect2(Point2(rc.x + margin, rc.y + margin) / rc.atlas_image->get_size(), Size2(rc.w() - 2 * margin, rc.h() - 2 * margin) / rc.atlas_image->get_size());
			entry["atlas_page"] = rc.bin;
			entry["atlas"] = rc.atlas_image;
			atlas_rects[r] = entry;
		}

		ret["_rects"] = atlas_rects;
		ret["_generated_images"] = generated_images;
		Array bins_size;
		ERR_FAIL_COND_V(bins_size.resize(bins.size()) != OK, Dictionary());
		for (int i = 0; i < bins.size(); ++i) {
			bins_size[i] = Size2(bins[i].size.w(), bins[i].size.h());
		}
		ret["_bins_size"] = bins_size;
	} else {
		WARN_PRINT("Packing of " + String::num(images.size()) + " images failed.");
	}

	return ret;
}

#ifdef DOCTEST

#include "doctest/doctest_godot.h"

#include <vector>

TEST_CASE("Packing functions") {
	_doctest_prepare_folder();

	// for s in 32 128 256 512 1024; do
	//   convert -size ${s}x$s xc:white test$s.png24
	//   pngcrush  -rem alla test$s.png24 test$s.png
	//   ls -l test$s* && ~/Private/Projekty/0.shared/common-dev-tools/res_tools/bin2c/bin2c -o /dev/stdin test$s.png
	//   rm test$s.*
	// done;
	static const struct {
		int image_size;
		int data_len;
		std::vector<uint8_t> png_data;
	} test_data[5] = {
		{ 32, 80,
				{ 0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52,
						0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x20, 0x08, 0x00, 0x00, 0x00, 0x00, 0x56, 0x11, 0x25,
						0x28, 0x00, 0x00, 0x00, 0x17, 0x49, 0x44, 0x41, 0x54, 0x38, 0xCB, 0x63, 0xFC, 0xCF, 0x80, 0x1F,
						0x30, 0x8E, 0x2A, 0x18, 0x55, 0x30, 0xAA, 0x60, 0xA4, 0x2A, 0x00, 0x00, 0xF8, 0x2D, 0x20, 0x01,
						0x4F, 0x2A, 0xA0, 0xAE, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82 } },
		{ 128, 148,
				{ 0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52,
						0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x08, 0x00, 0x00, 0x00, 0x00, 0xE6, 0x55, 0x3E,
						0x17, 0x00, 0x00, 0x00, 0x5B, 0x49, 0x44, 0x41, 0x54, 0x78, 0x5E, 0xED, 0xCE, 0x31, 0x01, 0x00,
						0x00, 0x0C, 0x02, 0xA0, 0xD9, 0x3F, 0xF4, 0x8C, 0xE1, 0x03, 0x09, 0xC8, 0xDF, 0x56, 0x04, 0x04,
						0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
						0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
						0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
						0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0xD6, 0x81, 0x02,
						0xF4, 0xC0, 0x80, 0x01, 0xE0, 0x6A, 0x61, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44,
						0xAE, 0x42, 0x60, 0x82 } },
		{ 256, 369,
				{ 0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52,
						0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x79, 0x19, 0xF7,
						0xBA, 0x00, 0x00, 0x01, 0x38, 0x49, 0x44, 0x41, 0x54, 0x78, 0xDA, 0xED, 0xD0, 0x01, 0x01, 0x00,
						0x00, 0x08, 0x02, 0x20, 0xFD, 0x3F, 0x3A, 0x87, 0x04, 0x13, 0xE8, 0xE5, 0xB7, 0x0A, 0x10, 0x20,
						0x40, 0x80, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x01, 0x02, 0x04, 0x08,
						0x10, 0x20, 0x40, 0x80, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x01, 0x02,
						0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00,
						0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40,
						0x80, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10,
						0x20, 0x40, 0x80, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x01, 0x02, 0x04,
						0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x01,
						0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
						0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,
						0x40, 0x80, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x01, 0x02, 0x04, 0x08,
						0x10, 0x20, 0x40, 0x80, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x01, 0x02,
						0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00,
						0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40,
						0x80, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10,
						0x20, 0x40, 0x80, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x01, 0x02, 0x04,
						0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x01,
						0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
						0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x01, 0xC9, 0x00, 0x11, 0x78, 0x00,
						0x10, 0x9C, 0xDD, 0xB8, 0x38, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60,
						0x82 } },
		{ 512, 854,
				{ 0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52,
						0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0xD1, 0x13, 0x8B,
						0x26, 0x00, 0x00, 0x03, 0x1D, 0x49, 0x44, 0x41, 0x54, 0x78, 0xDA, 0xED, 0xD2, 0x31, 0x01, 0x00,
						0x00, 0x08, 0x03, 0x20, 0xD7, 0x3F, 0xB4, 0xBB, 0xCD, 0x20, 0x64, 0x20, 0x3B, 0x7C, 0x16, 0x01,
						0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04,
						0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40,
						0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00,
						0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04,
						0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40,
						0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00,
						0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04,
						0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x10,
						0x40, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10,
						0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00,
						0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01,
						0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10,
						0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00,
						0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01,
						0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10,
						0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00,
						0x01, 0x04, 0x10, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40,
						0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00,
						0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04,
						0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40,
						0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00,
						0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04,
						0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40,
						0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00,
						0x04, 0x40, 0x00, 0x01, 0x04, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00,
						0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01,
						0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10,
						0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00,
						0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01,
						0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10,
						0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00,
						0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01,
						0x10, 0x00, 0x01, 0x10, 0x40, 0x00, 0x01, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00,
						0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04,
						0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40,
						0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00,
						0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04,
						0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40,
						0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00,
						0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x40, 0x00, 0x04,
						0x40, 0x00, 0x04, 0x40, 0x00, 0x04, 0x10, 0x40, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01,
						0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10,
						0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00,
						0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01,
						0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10,
						0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00,
						0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01,
						0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10, 0x00, 0x01, 0x10,
						0x80, 0xAB, 0x43, 0xB1, 0x00, 0x1F, 0xDE, 0xFC, 0x68, 0xA2, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45,
						0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82 } },
		{ 1024, 2389,
				{ 0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52,
						0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x5A, 0x76, 0x74,
						0x5F, 0x00, 0x00, 0x09, 0x1C, 0x49, 0x44, 0x41, 0x54, 0x78, 0xDA, 0xED, 0xD4, 0x31, 0x01, 0x00,
						0x00, 0x08, 0xC3, 0x30, 0xE6, 0x5F, 0x34, 0x13, 0xC1, 0x49, 0x22, 0xA1, 0x47, 0xB3, 0x03, 0x7C,
						0x15, 0x03, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00,
						0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00,
						0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00,
						0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0,
						0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30,
						0x00, 0xC0, 0x00, 0xC0, 0x00, 0x34, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00,
						0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0,
						0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30,
						0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C,
						0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03,
						0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00,
						0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00,
						0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00,
						0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00,
						0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0,
						0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C,
						0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03,
						0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00,
						0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00,
						0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00,
						0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0x00,
						0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0,
						0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30,
						0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C,
						0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03,
						0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00,
						0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00,
						0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00,
						0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00,
						0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0,
						0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30,
						0x00, 0xC0, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03,
						0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00,
						0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00,
						0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00,
						0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00,
						0x0C, 0x00, 0x30, 0x00, 0x30, 0x00, 0x03, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00,
						0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00,
						0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00,
						0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00,
						0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00,
						0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0x34, 0x00, 0x03, 0x00, 0x0C, 0x00,
						0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00,
						0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00,
						0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0,
						0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30,
						0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0x00, 0x03,
						0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00,
						0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00,
						0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00,
						0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00,
						0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0xC0,
						0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30,
						0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C,
						0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03,
						0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00,
						0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00,
						0xC0, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00,
						0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00,
						0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0,
						0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30,
						0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C,
						0x00, 0x30, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00,
						0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00,
						0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00,
						0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00,
						0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00,
						0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30,
						0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C,
						0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03,
						0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00,
						0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00,
						0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0x30, 0x00, 0x03, 0x00, 0x03, 0x00, 0x0C,
						0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03,
						0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00,
						0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00,
						0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00,
						0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0x34,
						0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00,
						0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00,
						0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00,
						0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00,
						0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0,
						0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C,
						0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03,
						0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00,
						0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00,
						0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00,
						0x30, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00,
						0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0,
						0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30,
						0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C,
						0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03,
						0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00,
						0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00,
						0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00,
						0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00,
						0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0,
						0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C,
						0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03,
						0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00,
						0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00,
						0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00,
						0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0x00,
						0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0,
						0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30,
						0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C,
						0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03,
						0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0x30, 0x00,
						0x03, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30,
						0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C,
						0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03,
						0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00,
						0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00,
						0xC0, 0x00, 0xC0, 0x00, 0x34, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03,
						0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00,
						0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00,
						0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00,
						0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00,
						0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0,
						0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30,
						0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C,
						0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03,
						0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00,
						0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00,
						0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00,
						0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00,
						0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0,
						0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30,
						0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0x00, 0x03,
						0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00,
						0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00,
						0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00,
						0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00,
						0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0xC0,
						0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30,
						0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C,
						0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03,
						0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00,
						0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00,
						0xC0, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00,
						0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00,
						0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0,
						0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0xB8,
						0x29, 0x15, 0x01, 0x00, 0x3D, 0x65, 0x1B, 0x47, 0xA5, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E,
						0x44, 0xAE, 0x42, 0x60, 0x82 } }
	};
	Vector<Ref<Image>> empty_set;
	Vector<Ref<Image>> test_set;
	for (int i = 0; i < 5; i++) {
		test_set.push_back(memnew(Image(test_data[i].png_data.data(), test_data[i].data_len)));
	}
	SUBCASE("empty set") {
		REQUIRE(merge_images(empty_set).empty());
	}
	SUBCASE("default packing") {
		const ImageMergeOptions options = ImageMergeOptions();
		Dictionary res = merge_images(test_set, options);
		REQUIRE(!res.empty());
		REQUIRE(Array(res["_generated_images"]).size() == 1);
		Ref<Image> atlas = Array(res["_generated_images"])[0];
		Size2 area = Array(res["_bins_size"])[0];
		REQUIRE(atlas->get_size() == area);
		atlas->save_png(_doctest_get_folder() + "atlas_default_packing.png");
	}
	SUBCASE("packing to max. size 1000 with single page") {
		const ImageMergeOptions options = ImageMergeOptions().set_max_size(1000).set_single_page(true);
		Dictionary res = merge_images(test_set, options);
		REQUIRE(!res.empty());
		REQUIRE(Array(res["_generated_images"]).size() == 1);
		Ref<Image> atlas = Array(res["_generated_images"])[0];
		atlas->save_png(_doctest_get_folder() + "atlas_max1000_with_single_page.png");
	}
	SUBCASE("packing big images to max. size 1000 with single page") {
		const ImageMergeOptions options = ImageMergeOptions().set_max_size(1000).set_single_page(true);
		Vector<Ref<Image>> test_set_1;
		test_set_1.push_back(test_set[3], test_set[4], test_set[4]);
		Dictionary res = merge_images(test_set_1, options);
		REQUIRE(!res.empty());
		REQUIRE(Array(res["_generated_images"]).size() == 1);
		Ref<Image> atlas = Array(res["_generated_images"])[0];
		atlas->save_png(_doctest_get_folder() + "atlas_big_images_max1000_with_single_page.png");
	}
	SUBCASE("packing small images to max. size 1000 with single page") {
		const ImageMergeOptions options = ImageMergeOptions().set_max_size(1000).set_single_page(true);
		Vector<Ref<Image>> test_set_1;
		test_set_1.push_back(test_set[0], test_set[0], test_set[1]);
		Dictionary res = merge_images(test_set_1, options);
		REQUIRE(!res.empty());
		REQUIRE(Array(res["_generated_images"]).size() == 1);
		Ref<Image> atlas = Array(res["_generated_images"])[0];
		atlas->save_png(_doctest_get_folder() + "atlas_small_images_max1000_with_single_page.png");
	}
}
#endif
