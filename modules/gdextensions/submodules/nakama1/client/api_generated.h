/**************************************************************************/
/*  api_generated.h                                                       */
/**************************************************************************/
/*                         This file is part of:                          */
/*                             GODOT ENGINE                               */
/*                        https://godotengine.org                         */
/**************************************************************************/
/* Copyright (c) 2014-present Godot Engine contributors (see AUTHORS.md). */
/* Copyright (c) 2007-2014 Juan Linietsky, Ariel Manzur.                  */
/*                                                                        */
/* Permission is hereby granted, free of charge, to any person obtaining  */
/* a copy of this software and associated documentation files (the        */
/* "Software"), to deal in the Software without restriction, including    */
/* without limitation the rights to use, copy, modify, merge, publish,    */
/* distribute, sublicense, and/or sell copies of the Software, and to     */
/* permit persons to whom the Software is furnished to do so, subject to  */
/* the following conditions:                                              */
/*                                                                        */
/* The above copyright notice and this permission notice shall be         */
/* included in all copies or substantial portions of the Software.        */
/*                                                                        */
/* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,        */
/* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF     */
/* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. */
/* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY   */
/* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,   */
/* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE      */
/* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                 */
/**************************************************************************/

// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_API_SERVER_H_
#define FLATBUFFERS_GENERATED_API_SERVER_H_

#include "flatbuffers/flatbuffers.h"

#undef _timezone

namespace server {

struct Heartbeat;
struct HeartbeatBuilder;
struct HeartbeatT;

struct Error;
struct ErrorBuilder;
struct ErrorT;

struct AuthenticateRequest;
struct AuthenticateRequestBuilder;
struct AuthenticateRequestT;

namespace AuthenticateRequest_ {

struct Email;
struct EmailBuilder;
struct EmailT;

struct GameCenter;
struct GameCenterBuilder;
struct GameCenterT;

struct AuthenticateMethod;
struct AuthenticateMethodBuilder;
struct AuthenticateMethodT;

} // namespace AuthenticateRequest_

struct AuthenticateResponse;
struct AuthenticateResponseBuilder;
struct AuthenticateResponseT;

namespace AuthenticateResponse_ {

struct Session;
struct SessionBuilder;
struct SessionT;

struct Error;
struct ErrorBuilder;
struct ErrorT;

struct AuthenticateResult;
struct AuthenticateResultBuilder;
struct AuthenticateResultT;

} // namespace AuthenticateResponse_

struct Envelope;
struct EnvelopeBuilder;
struct EnvelopeT;

namespace Envelope_ {

struct EnvelopeContent;
struct EnvelopeContentBuilder;
struct EnvelopeContentT;

} // namespace Envelope_

struct Logout;
struct LogoutBuilder;
struct LogoutT;

struct TLink;
struct TLinkBuilder;
struct TLinkT;

namespace TLink_ {

struct Anonymous3;
struct Anonymous3Builder;
struct Anonymous3T;

} // namespace TLink_

struct TUnlink;
struct TUnlinkBuilder;
struct TUnlinkT;

namespace TUnlink_ {

struct Anonymous4;
struct Anonymous4Builder;
struct Anonymous4T;

} // namespace TUnlink_

struct User;
struct UserBuilder;
struct UserT;

struct Self;
struct SelfBuilder;
struct SelfT;

struct TSelfFetch;
struct TSelfFetchBuilder;
struct TSelfFetchT;

struct TSelf;
struct TSelfBuilder;
struct TSelfT;

struct TSelfUpdate;
struct TSelfUpdateBuilder;
struct TSelfUpdateT;

struct TUsersFetch;
struct TUsersFetchBuilder;
struct TUsersFetchT;

namespace TUsersFetch_ {

struct UsersFetch;
struct UsersFetchBuilder;
struct UsersFetchT;

namespace UsersFetch_ {

struct Anonymous5;
struct Anonymous5Builder;
struct Anonymous5T;

} // namespace UsersFetch_
} // namespace TUsersFetch_

struct TUsers;
struct TUsersBuilder;
struct TUsersT;

struct Friend;
struct FriendBuilder;
struct FriendT;

struct TFriendsAdd;
struct TFriendsAddBuilder;
struct TFriendsAddT;

namespace TFriendsAdd_ {

struct FriendsAdd;
struct FriendsAddBuilder;
struct FriendsAddT;

namespace FriendsAdd_ {

struct Anonymous6;
struct Anonymous6Builder;
struct Anonymous6T;

} // namespace FriendsAdd_
} // namespace TFriendsAdd_

struct TFriendsRemove;
struct TFriendsRemoveBuilder;
struct TFriendsRemoveT;

struct TFriendsBlock;
struct TFriendsBlockBuilder;
struct TFriendsBlockT;

struct TFriendsList;
struct TFriendsListBuilder;
struct TFriendsListT;

struct TFriends;
struct TFriendsBuilder;
struct TFriendsT;

struct Group;
struct GroupBuilder;
struct GroupT;

struct TGroupsCreate;
struct TGroupsCreateBuilder;
struct TGroupsCreateT;

namespace TGroupsCreate_ {

struct GroupCreate;
struct GroupCreateBuilder;
struct GroupCreateT;

} // namespace TGroupsCreate_

struct TGroupsUpdate;
struct TGroupsUpdateBuilder;
struct TGroupsUpdateT;

namespace TGroupsUpdate_ {

struct GroupUpdate;
struct GroupUpdateBuilder;
struct GroupUpdateT;

} // namespace TGroupsUpdate_

struct TGroupsRemove;
struct TGroupsRemoveBuilder;
struct TGroupsRemoveT;

struct TGroupsSelfList;
struct TGroupsSelfListBuilder;
struct TGroupsSelfListT;

struct TGroupsFetch;
struct TGroupsFetchBuilder;
struct TGroupsFetchT;

namespace TGroupsFetch_ {

struct GroupFetch;
struct GroupFetchBuilder;
struct GroupFetchT;

namespace GroupFetch_ {

struct Anonymous7;
struct Anonymous7Builder;
struct Anonymous7T;

} // namespace GroupFetch_
} // namespace TGroupsFetch_

struct TGroupsList;
struct TGroupsListBuilder;
struct TGroupsListT;

namespace TGroupsList_ {

struct Anonymous8;
struct Anonymous8Builder;
struct Anonymous8T;

} // namespace TGroupsList_

struct TGroups;
struct TGroupsBuilder;
struct TGroupsT;

struct TGroupsSelf;
struct TGroupsSelfBuilder;
struct TGroupsSelfT;

namespace TGroupsSelf_ {

struct GroupSelf;
struct GroupSelfBuilder;
struct GroupSelfT;

} // namespace TGroupsSelf_

struct GroupUser;
struct GroupUserBuilder;
struct GroupUserT;

struct TGroupUsersList;
struct TGroupUsersListBuilder;
struct TGroupUsersListT;

struct TGroupUsers;
struct TGroupUsersBuilder;
struct TGroupUsersT;

struct TGroupsJoin;
struct TGroupsJoinBuilder;
struct TGroupsJoinT;

struct TGroupsLeave;
struct TGroupsLeaveBuilder;
struct TGroupsLeaveT;

struct TGroupUsersAdd;
struct TGroupUsersAddBuilder;
struct TGroupUsersAddT;

namespace TGroupUsersAdd_ {

struct GroupUserAdd;
struct GroupUserAddBuilder;
struct GroupUserAddT;

} // namespace TGroupUsersAdd_

struct TGroupUsersKick;
struct TGroupUsersKickBuilder;
struct TGroupUsersKickT;

namespace TGroupUsersKick_ {

struct GroupUserKick;
struct GroupUserKickBuilder;
struct GroupUserKickT;

} // namespace TGroupUsersKick_

struct TGroupUsersPromote;
struct TGroupUsersPromoteBuilder;
struct TGroupUsersPromoteT;

namespace TGroupUsersPromote_ {

struct GroupUserPromote;
struct GroupUserPromoteBuilder;
struct GroupUserPromoteT;

} // namespace TGroupUsersPromote_

struct TopicId;
struct TopicIdBuilder;
struct TopicIdT;

namespace TopicId_ {

struct TopicType;
struct TopicTypeBuilder;
struct TopicTypeT;

} // namespace TopicId_

struct UserPresence;
struct UserPresenceBuilder;
struct UserPresenceT;

struct TTopicsJoin;
struct TTopicsJoinBuilder;
struct TTopicsJoinT;

namespace TTopicsJoin_ {

struct TopicJoin;
struct TopicJoinBuilder;
struct TopicJoinT;

namespace TopicJoin_ {

struct AuthenticateResult0;
struct AuthenticateResult0Builder;
struct AuthenticateResult0T;

} // namespace TopicJoin_
} // namespace TTopicsJoin_

struct TTopics;
struct TTopicsBuilder;
struct TTopicsT;

namespace TTopics_ {

struct Topic;
struct TopicBuilder;
struct TopicT;

} // namespace TTopics_

struct TTopicsLeave;
struct TTopicsLeaveBuilder;
struct TTopicsLeaveT;

struct TTopicMessageSend;
struct TTopicMessageSendBuilder;
struct TTopicMessageSendT;

struct TTopicMessageAck;
struct TTopicMessageAckBuilder;
struct TTopicMessageAckT;

struct TopicMessage;
struct TopicMessageBuilder;
struct TopicMessageT;

struct TTopicMessagesList;
struct TTopicMessagesListBuilder;
struct TTopicMessagesListT;

namespace TTopicMessagesList_ {

struct AuthenticateResult1;
struct AuthenticateResult1Builder;
struct AuthenticateResult1T;

} // namespace TTopicMessagesList_

struct TTopicMessages;
struct TTopicMessagesBuilder;
struct TTopicMessagesT;

struct TopicPresence;
struct TopicPresenceBuilder;
struct TopicPresenceT;

struct PropertyPair;
struct PropertyPairBuilder;
struct PropertyPairT;

namespace PropertyPair_ {

struct StringSet;
struct StringSetBuilder;
struct StringSetT;

struct AuthenticateResult2;
struct AuthenticateResult2Builder;
struct AuthenticateResult2T;

} // namespace PropertyPair_

struct MatchmakeFilter;
struct MatchmakeFilterBuilder;
struct MatchmakeFilterT;

namespace MatchmakeFilter_ {

struct TermFilter;
struct TermFilterBuilder;
struct TermFilterT;

struct RangeFilter;
struct RangeFilterBuilder;
struct RangeFilterT;

struct AuthenticateResult3;
struct AuthenticateResult3Builder;
struct AuthenticateResult3T;

} // namespace MatchmakeFilter_

struct TMatchmakeAdd;
struct TMatchmakeAddBuilder;
struct TMatchmakeAddT;

struct TMatchmakeTicket;
struct TMatchmakeTicketBuilder;
struct TMatchmakeTicketT;

struct TMatchmakeRemove;
struct TMatchmakeRemoveBuilder;
struct TMatchmakeRemoveT;

struct MatchmakeMatched;
struct MatchmakeMatchedBuilder;
struct MatchmakeMatchedT;

namespace MatchmakeMatched_ {

struct UserProperty;
struct UserPropertyBuilder;
struct UserPropertyT;

} // namespace MatchmakeMatched_

struct Match;
struct MatchBuilder;
struct MatchT;

struct MatchPresence;
struct MatchPresenceBuilder;
struct MatchPresenceT;

struct TMatchCreate;
struct TMatchCreateBuilder;
struct TMatchCreateT;

struct TMatch;
struct TMatchBuilder;
struct TMatchT;

struct TMatchesJoin;
struct TMatchesJoinBuilder;
struct TMatchesJoinT;

namespace TMatchesJoin_ {

struct MatchJoin;
struct MatchJoinBuilder;
struct MatchJoinT;

namespace MatchJoin_ {

struct AuthenticateResult4;
struct AuthenticateResult4Builder;
struct AuthenticateResult4T;

} // namespace MatchJoin_
} // namespace TMatchesJoin_

struct TMatches;
struct TMatchesBuilder;
struct TMatchesT;

struct MatchDataSend;
struct MatchDataSendBuilder;
struct MatchDataSendT;

struct MatchData;
struct MatchDataBuilder;
struct MatchDataT;

struct TMatchesLeave;
struct TMatchesLeaveBuilder;
struct TMatchesLeaveT;

struct TStorageList;
struct TStorageListBuilder;
struct TStorageListT;

struct TStorageFetch;
struct TStorageFetchBuilder;
struct TStorageFetchT;

namespace TStorageFetch_ {

struct StorageKey;
struct StorageKeyBuilder;
struct StorageKeyT;

} // namespace TStorageFetch_

struct TStorageData;
struct TStorageDataBuilder;
struct TStorageDataT;

namespace TStorageData_ {

struct StorageData;
struct StorageDataBuilder;
struct StorageDataT;

} // namespace TStorageData_

struct TStorageWrite;
struct TStorageWriteBuilder;
struct TStorageWriteT;

namespace TStorageWrite_ {

struct StorageData;
struct StorageDataBuilder;
struct StorageDataT;

} // namespace TStorageWrite_

struct TStorageUpdate;
struct TStorageUpdateBuilder;
struct TStorageUpdateT;

namespace TStorageUpdate_ {

struct StorageUpdate;
struct StorageUpdateBuilder;
struct StorageUpdateT;

namespace StorageUpdate_ {

struct UpdateOp;
struct UpdateOpBuilder;
struct UpdateOpT;

struct StorageKey;
struct StorageKeyBuilder;
struct StorageKeyT;

} // namespace StorageUpdate_
} // namespace TStorageUpdate_

struct TStorageKeys;
struct TStorageKeysBuilder;
struct TStorageKeysT;

namespace TStorageKeys_ {

struct StorageKey;
struct StorageKeyBuilder;
struct StorageKeyT;

} // namespace TStorageKeys_

struct TStorageRemove;
struct TStorageRemoveBuilder;
struct TStorageRemoveT;

namespace TStorageRemove_ {

struct StorageKey;
struct StorageKeyBuilder;
struct StorageKeyT;

} // namespace TStorageRemove_

struct Leaderboard;
struct LeaderboardBuilder;
struct LeaderboardT;

struct LeaderboardRecord;
struct LeaderboardRecordBuilder;
struct LeaderboardRecordT;

struct TLeaderboardsList;
struct TLeaderboardsListBuilder;
struct TLeaderboardsListT;

struct TLeaderboards;
struct TLeaderboardsBuilder;
struct TLeaderboardsT;

struct TLeaderboardRecordsWrite;
struct TLeaderboardRecordsWriteBuilder;
struct TLeaderboardRecordsWriteT;

namespace TLeaderboardRecordsWrite_ {

struct LeaderboardRecordWrite;
struct LeaderboardRecordWriteBuilder;
struct LeaderboardRecordWriteT;

namespace LeaderboardRecordWrite_ {

struct ScoreOperator;
struct ScoreOperatorBuilder;
struct ScoreOperatorT;

} // namespace LeaderboardRecordWrite_
} // namespace TLeaderboardRecordsWrite_

struct TLeaderboardRecordsFetch;
struct TLeaderboardRecordsFetchBuilder;
struct TLeaderboardRecordsFetchT;

struct TLeaderboardRecordsList;
struct TLeaderboardRecordsListBuilder;
struct TLeaderboardRecordsListT;

namespace TLeaderboardRecordsList_ {

struct Owners;
struct OwnersBuilder;
struct OwnersT;

struct AuthenticateResult6;
struct AuthenticateResult6Builder;
struct AuthenticateResult6T;

} // namespace TLeaderboardRecordsList_

struct TLeaderboardRecords;
struct TLeaderboardRecordsBuilder;
struct TLeaderboardRecordsT;

struct TRpc;
struct TRpcBuilder;
struct TRpcT;

struct TPurchaseValidation;
struct TPurchaseValidationBuilder;
struct TPurchaseValidationT;

namespace TPurchaseValidation_ {

struct ApplePurchase;
struct ApplePurchaseBuilder;
struct ApplePurchaseT;

struct GooglePurchase;
struct GooglePurchaseBuilder;
struct GooglePurchaseT;

struct AuthenticateResult7;
struct AuthenticateResult7Builder;
struct AuthenticateResult7T;

} // namespace TPurchaseValidation_

struct TPurchaseRecord;
struct TPurchaseRecordBuilder;
struct TPurchaseRecordT;

struct Notification;
struct NotificationBuilder;
struct NotificationT;

struct Notifications;
struct NotificationsBuilder;
struct NotificationsT;

struct TNotificationsList;
struct TNotificationsListBuilder;
struct TNotificationsListT;

struct TNotifications;
struct TNotificationsBuilder;
struct TNotificationsT;

struct TNotificationsRemove;
struct TNotificationsRemoveBuilder;
struct TNotificationsRemoveT;

namespace Error_ {

/// Predefined errors that are produced by the server.
enum class Code : int32_t {
	/// An unexpected error that is unrecoverable.
	RUNTIME_EXCEPTION = 0,
	/// Server received a message that is not recognized.
	UNRECOGNIZED_PAYLOAD = 1,
	/// Server received an Envelop message but the internal message is unrecognised. Most likely a protocol mismatch.
	MISSING_PAYLOAD = 2,
	/// The message did not include the required data in the correct format.
	BAD_INPUT = 3,
	/// Authentication failure.
	AUTH_ERROR = 4,
	/// Login failed because ID/device/email did not exist.
	USER_NOT_FOUND = 5,
	/// Registration failed because ID/device/email exists.
	USER_REGISTER_INUSE = 6,
	/// Linking operation failed because link exists.
	USER_LINK_INUSE = 7,
	/// Linking operation failed because third-party service was unreachable.
	USER_LINK_PROVIDER_UNAVAILABLE = 8,
	/// Unlinking operation failed because you cannot unlink last ID.
	USER_UNLINK_DISALLOWED = 9,
	/// Handle is in-use by another user.
	USER_HANDLE_INUSE = 10,
	/// Group names must be unique and it's already in use.
	GROUP_NAME_INUSE = 11,
	/// Group leave operation not allowed because the user is the last admin.
	GROUP_LAST_ADMIN = 12,
	/// Storage write operation failed.
	STORAGE_REJECTED = 13,
	/// Match with given ID was not found in the system.
	MATCH_NOT_FOUND = 14,
	/// Runtime function name was not found in system registry.
	RUNTIME_FUNCTION_NOT_FOUND = 15,
	/// Runtime function caused an internal server error and did not complete.
	RUNTIME_FUNCTION_EXCEPTION = 16,
	MIN = RUNTIME_EXCEPTION,
	MAX = RUNTIME_FUNCTION_EXCEPTION
};

inline const Code (&EnumValuesCode())[17] {
	static const Code values[] = {
		Code::RUNTIME_EXCEPTION,
		Code::UNRECOGNIZED_PAYLOAD,
		Code::MISSING_PAYLOAD,
		Code::BAD_INPUT,
		Code::AUTH_ERROR,
		Code::USER_NOT_FOUND,
		Code::USER_REGISTER_INUSE,
		Code::USER_LINK_INUSE,
		Code::USER_LINK_PROVIDER_UNAVAILABLE,
		Code::USER_UNLINK_DISALLOWED,
		Code::USER_HANDLE_INUSE,
		Code::GROUP_NAME_INUSE,
		Code::GROUP_LAST_ADMIN,
		Code::STORAGE_REJECTED,
		Code::MATCH_NOT_FOUND,
		Code::RUNTIME_FUNCTION_NOT_FOUND,
		Code::RUNTIME_FUNCTION_EXCEPTION
	};
	return values;
}

inline const char *const *EnumNamesCode() {
	static const char *const names[18] = {
		"RUNTIME_EXCEPTION",
		"UNRECOGNIZED_PAYLOAD",
		"MISSING_PAYLOAD",
		"BAD_INPUT",
		"AUTH_ERROR",
		"USER_NOT_FOUND",
		"USER_REGISTER_INUSE",
		"USER_LINK_INUSE",
		"USER_LINK_PROVIDER_UNAVAILABLE",
		"USER_UNLINK_DISALLOWED",
		"USER_HANDLE_INUSE",
		"GROUP_NAME_INUSE",
		"GROUP_LAST_ADMIN",
		"STORAGE_REJECTED",
		"MATCH_NOT_FOUND",
		"RUNTIME_FUNCTION_NOT_FOUND",
		"RUNTIME_FUNCTION_EXCEPTION",
		nullptr
	};
	return names;
}

inline const char *EnumNameCode(Code e) {
	if (flatbuffers::IsOutRange(e, Code::RUNTIME_EXCEPTION, Code::RUNTIME_FUNCTION_EXCEPTION))
		return "";
	const size_t index = static_cast<size_t>(e);
	return EnumNamesCode()[index];
}

} // namespace Error_

enum class StoragePermissionRead : int32_t {
	/// Storage owner does not have read access.
	NO_READ = 0,
	/// Only storage owner has read access.
	OWNER_READ = 1,
	/// Storage owner and every other user has read access.
	PUBLIC_READ = 2,
	MIN = NO_READ,
	MAX = PUBLIC_READ
};

inline const StoragePermissionRead (&EnumValuesStoragePermissionRead())[3] {
	static const StoragePermissionRead values[] = {
		StoragePermissionRead::NO_READ,
		StoragePermissionRead::OWNER_READ,
		StoragePermissionRead::PUBLIC_READ
	};
	return values;
}

inline const char *const *EnumNamesStoragePermissionRead() {
	static const char *const names[4] = {
		"NO_READ",
		"OWNER_READ",
		"PUBLIC_READ",
		nullptr
	};
	return names;
}

inline const char *EnumNameStoragePermissionRead(StoragePermissionRead e) {
	if (flatbuffers::IsOutRange(e, StoragePermissionRead::NO_READ, StoragePermissionRead::PUBLIC_READ))
		return "";
	const size_t index = static_cast<size_t>(e);
	return EnumNamesStoragePermissionRead()[index];
}

enum class StoragePermissionWrite : int32_t {
	/// Storage owner does not have write access.
	NO_WRITE = 0,
	/// Storage owner has write access.
	OWNER_WRITE = 1,
	MIN = NO_WRITE,
	MAX = OWNER_WRITE
};

inline const StoragePermissionWrite (&EnumValuesStoragePermissionWrite())[2] {
	static const StoragePermissionWrite values[] = {
		StoragePermissionWrite::NO_WRITE,
		StoragePermissionWrite::OWNER_WRITE
	};
	return values;
}

inline const char *const *EnumNamesStoragePermissionWrite() {
	static const char *const names[3] = {
		"NO_WRITE",
		"OWNER_WRITE",
		nullptr
	};
	return names;
}

inline const char *EnumNameStoragePermissionWrite(StoragePermissionWrite e) {
	if (flatbuffers::IsOutRange(e, StoragePermissionWrite::NO_WRITE, StoragePermissionWrite::OWNER_WRITE))
		return "";
	const size_t index = static_cast<size_t>(e);
	return EnumNamesStoragePermissionWrite()[index];
}

namespace TStorageUpdate_ {
namespace StorageUpdate_ {
namespace UpdateOp_ {

enum class UpdateOpCode : int32_t {
	/// Add field or value to array at the path.
	ADD = 0,
	/// Append a value or array of values at the path.
	APPEND = 1,
	/// Copy value at the path to another path.
	COPY = 2,
	/// Add a positive/negative value to the value at the path.
	INCR = 3,
	/// Initialize the value at the path ONLY if itâ€™s not already present.
	INIT = 4,
	/// Perform a merge of the object at the path.
	MERGE = 5,
	/// Move a value from one path to another and remove from the original path.
	MOVE = 6,
	/// Perform a JSON patch with the sequence of operations on the subpath specified
	PATCH = 7,
	/// Remove the value or array at the path.
	REMOVE = 8,
	/// Replaces an existing value at the specified path.
	REPLACE = 9,
	/// Tests equality of the value at the path. The entire patch set fails if the test fails.
	TEST = 10,
	/// Performs a comparator which returns -1, 0, or 1 depending on whether the value is less than, the same, or greater than the value in the path.
	COMPARE = 11,
	MIN = ADD,
	MAX = COMPARE
};

inline const UpdateOpCode (&EnumValuesUpdateOpCode())[12] {
	static const UpdateOpCode values[] = {
		UpdateOpCode::ADD,
		UpdateOpCode::APPEND,
		UpdateOpCode::COPY,
		UpdateOpCode::INCR,
		UpdateOpCode::INIT,
		UpdateOpCode::MERGE,
		UpdateOpCode::MOVE,
		UpdateOpCode::PATCH,
		UpdateOpCode::REMOVE,
		UpdateOpCode::REPLACE,
		UpdateOpCode::TEST,
		UpdateOpCode::COMPARE
	};
	return values;
}

inline const char *const *EnumNamesUpdateOpCode() {
	static const char *const names[13] = {
		"ADD",
		"APPEND",
		"COPY",
		"INCR",
		"INIT",
		"MERGE",
		"MOVE",
		"PATCH",
		"REMOVE",
		"REPLACE",
		"TEST",
		"COMPARE",
		nullptr
	};
	return names;
}

inline const char *EnumNameUpdateOpCode(UpdateOpCode e) {
	if (flatbuffers::IsOutRange(e, UpdateOpCode::ADD, UpdateOpCode::COMPARE))
		return "";
	const size_t index = static_cast<size_t>(e);
	return EnumNamesUpdateOpCode()[index];
}

} // namespace UpdateOp_
} // namespace StorageUpdate_
} // namespace TStorageUpdate_

struct HeartbeatT : public flatbuffers::NativeTable {
	typedef Heartbeat TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.HeartbeatT";
	}
	int64_t timestamp;
	HeartbeatT() :
			timestamp(0) {
	}
};

struct Heartbeat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef HeartbeatT NativeTableType;
	typedef HeartbeatBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.Heartbeat";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_TIMESTAMP = 4
	};
	/// Server UTC timestamp in milliseconds.
	int64_t timestamp() const {
		return GetField<int64_t>(VT_TIMESTAMP, 0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyField<int64_t>(verifier, VT_TIMESTAMP) &&
				verifier.EndTable();
	}
	HeartbeatT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(HeartbeatT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<Heartbeat> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HeartbeatT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct HeartbeatBuilder {
	typedef Heartbeat Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_timestamp(int64_t timestamp) {
		fbb_.AddElement<int64_t>(Heartbeat::VT_TIMESTAMP, timestamp, 0);
	}
	explicit HeartbeatBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<Heartbeat> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Heartbeat>(end);
		return o;
	}
};

inline flatbuffers::Offset<Heartbeat> CreateHeartbeat(
		flatbuffers::FlatBufferBuilder &_fbb,
		int64_t timestamp = 0) {
	HeartbeatBuilder builder_(_fbb);
	builder_.add_timestamp(timestamp);
	return builder_.Finish();
}

flatbuffers::Offset<Heartbeat> CreateHeartbeat(flatbuffers::FlatBufferBuilder &_fbb, const HeartbeatT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ErrorT : public flatbuffers::NativeTable {
	typedef Error TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.ErrorT";
	}
	int32_t code;
	CharString message;
	ErrorT() :
			code(0) {
	}
};

struct Error FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef ErrorT NativeTableType;
	typedef ErrorBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.Error";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_CODE = 4,
		VT_MESSAGE = 6
	};
	/// Error code - must be one of the Error.Code enums above.
	int32_t code() const {
		return GetField<int32_t>(VT_CODE, 0);
	}
	/// Specific error message.
	const flatbuffers::String *message() const {
		return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyField<int32_t>(verifier, VT_CODE) &&
				VerifyOffset(verifier, VT_MESSAGE) &&
				verifier.VerifyString(message()) &&
				verifier.EndTable();
	}
	ErrorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(ErrorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<Error> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ErrorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct ErrorBuilder {
	typedef Error Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_code(int32_t code) {
		fbb_.AddElement<int32_t>(Error::VT_CODE, code, 0);
	}
	void add_message(flatbuffers::Offset<flatbuffers::String> message) {
		fbb_.AddOffset(Error::VT_MESSAGE, message);
	}
	explicit ErrorBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<Error> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Error>(end);
		return o;
	}
};

inline flatbuffers::Offset<Error> CreateError(
		flatbuffers::FlatBufferBuilder &_fbb,
		int32_t code = 0,
		flatbuffers::Offset<flatbuffers::String> message = 0) {
	ErrorBuilder builder_(_fbb);
	builder_.add_message(message);
	builder_.add_code(code);
	return builder_.Finish();
}

inline flatbuffers::Offset<Error> CreateErrorDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		int32_t code = 0,
		const char *message = nullptr) {
	auto message__ = message ? _fbb.CreateString(message) : 0;
	return server::CreateError(
			_fbb,
			code,
			message__);
}

flatbuffers::Offset<Error> CreateError(flatbuffers::FlatBufferBuilder &_fbb, const ErrorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AuthenticateRequestT : public flatbuffers::NativeTable {
	typedef AuthenticateRequest TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.AuthenticateRequestT";
	}
	CharString collation_id;
	std::unique_ptr<server::AuthenticateRequest_::AuthenticateMethodT> id;
	AuthenticateRequestT() {
	}
};

struct AuthenticateRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef AuthenticateRequestT NativeTableType;
	typedef AuthenticateRequestBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.AuthenticateRequest";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_COLLATION_ID = 4,
		VT_ID = 6
	};
	/// Optional collationID to track server response.
	const flatbuffers::String *collation_id() const {
		return GetPointer<const flatbuffers::String *>(VT_COLLATION_ID);
	}
	/// OneOf authentication methods.
	const server::AuthenticateRequest_::AuthenticateMethod *id() const {
		return GetPointer<const server::AuthenticateRequest_::AuthenticateMethod *>(VT_ID);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_COLLATION_ID) &&
				verifier.VerifyString(collation_id()) &&
				VerifyOffset(verifier, VT_ID) &&
				verifier.VerifyTable(id()) &&
				verifier.EndTable();
	}
	AuthenticateRequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(AuthenticateRequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<AuthenticateRequest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct AuthenticateRequestBuilder {
	typedef AuthenticateRequest Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_collation_id(flatbuffers::Offset<flatbuffers::String> collation_id) {
		fbb_.AddOffset(AuthenticateRequest::VT_COLLATION_ID, collation_id);
	}
	void add_id(flatbuffers::Offset<server::AuthenticateRequest_::AuthenticateMethod> id) {
		fbb_.AddOffset(AuthenticateRequest::VT_ID, id);
	}
	explicit AuthenticateRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<AuthenticateRequest> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<AuthenticateRequest>(end);
		return o;
	}
};

inline flatbuffers::Offset<AuthenticateRequest> CreateAuthenticateRequest(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> collation_id = 0,
		flatbuffers::Offset<server::AuthenticateRequest_::AuthenticateMethod> id = 0) {
	AuthenticateRequestBuilder builder_(_fbb);
	builder_.add_id(id);
	builder_.add_collation_id(collation_id);
	return builder_.Finish();
}

inline flatbuffers::Offset<AuthenticateRequest> CreateAuthenticateRequestDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *collation_id = nullptr,
		flatbuffers::Offset<server::AuthenticateRequest_::AuthenticateMethod> id = 0) {
	auto collation_id__ = collation_id ? _fbb.CreateString(collation_id) : 0;
	return server::CreateAuthenticateRequest(
			_fbb,
			collation_id__,
			id);
}

flatbuffers::Offset<AuthenticateRequest> CreateAuthenticateRequest(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace AuthenticateRequest_ {

struct EmailT : public flatbuffers::NativeTable {
	typedef Email TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.AuthenticateRequest_.EmailT";
	}
	CharString email;
	CharString password;
	EmailT() {
	}
};

struct Email FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef EmailT NativeTableType;
	typedef EmailBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.AuthenticateRequest_.Email";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_EMAIL = 4,
		VT_PASSWORD = 6
	};
	/// Email address.
	const flatbuffers::String *email() const {
		return GetPointer<const flatbuffers::String *>(VT_EMAIL);
	}
	/// Password.
	const flatbuffers::String *password() const {
		return GetPointer<const flatbuffers::String *>(VT_PASSWORD);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_EMAIL) &&
				verifier.VerifyString(email()) &&
				VerifyOffset(verifier, VT_PASSWORD) &&
				verifier.VerifyString(password()) &&
				verifier.EndTable();
	}
	EmailT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(EmailT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<Email> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EmailT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct EmailBuilder {
	typedef Email Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_email(flatbuffers::Offset<flatbuffers::String> email) {
		fbb_.AddOffset(Email::VT_EMAIL, email);
	}
	void add_password(flatbuffers::Offset<flatbuffers::String> password) {
		fbb_.AddOffset(Email::VT_PASSWORD, password);
	}
	explicit EmailBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<Email> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Email>(end);
		return o;
	}
};

inline flatbuffers::Offset<Email> CreateEmail(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> email = 0,
		flatbuffers::Offset<flatbuffers::String> password = 0) {
	EmailBuilder builder_(_fbb);
	builder_.add_password(password);
	builder_.add_email(email);
	return builder_.Finish();
}

inline flatbuffers::Offset<Email> CreateEmailDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *email = nullptr,
		const char *password = nullptr) {
	auto email__ = email ? _fbb.CreateString(email) : 0;
	auto password__ = password ? _fbb.CreateString(password) : 0;
	return server::AuthenticateRequest_::CreateEmail(
			_fbb,
			email__,
			password__);
}

flatbuffers::Offset<Email> CreateEmail(flatbuffers::FlatBufferBuilder &_fbb, const EmailT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GameCenterT : public flatbuffers::NativeTable {
	typedef GameCenter TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.AuthenticateRequest_.GameCenterT";
	}
	CharString player_id;
	CharString bundle_id;
	int64_t timestamp;
	CharString salt;
	CharString signature;
	CharString public_key_url;
	GameCenterT() :
			timestamp(0) {
	}
};

struct GameCenter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef GameCenterT NativeTableType;
	typedef GameCenterBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.AuthenticateRequest_.GameCenter";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_PLAYER_ID = 4,
		VT_BUNDLE_ID = 6,
		VT_TIMESTAMP = 8,
		VT_SALT = 10,
		VT_SIGNATURE = 12,
		VT_PUBLIC_KEY_URL = 14
	};
	/// PlayerID generated by GameCenter.
	const flatbuffers::String *player_id() const {
		return GetPointer<const flatbuffers::String *>(VT_PLAYER_ID);
	}
	/// BundleID generated by GameCenter.
	const flatbuffers::String *bundle_id() const {
		return GetPointer<const flatbuffers::String *>(VT_BUNDLE_ID);
	}
	/// The date and time that the signature was created.
	int64_t timestamp() const {
		return GetField<int64_t>(VT_TIMESTAMP, 0);
	}
	/// A random NSString used to compute the hash and keep it randomized.
	const flatbuffers::String *salt() const {
		return GetPointer<const flatbuffers::String *>(VT_SALT);
	}
	/// The verification signature data generated.
	const flatbuffers::String *signature() const {
		return GetPointer<const flatbuffers::String *>(VT_SIGNATURE);
	}
	/// The URL for the public encryption key.
	const flatbuffers::String *public_key_url() const {
		return GetPointer<const flatbuffers::String *>(VT_PUBLIC_KEY_URL);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_PLAYER_ID) &&
				verifier.VerifyString(player_id()) &&
				VerifyOffset(verifier, VT_BUNDLE_ID) &&
				verifier.VerifyString(bundle_id()) &&
				VerifyField<int64_t>(verifier, VT_TIMESTAMP) &&
				VerifyOffset(verifier, VT_SALT) &&
				verifier.VerifyString(salt()) &&
				VerifyOffset(verifier, VT_SIGNATURE) &&
				verifier.VerifyString(signature()) &&
				VerifyOffset(verifier, VT_PUBLIC_KEY_URL) &&
				verifier.VerifyString(public_key_url()) &&
				verifier.EndTable();
	}
	GameCenterT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(GameCenterT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<GameCenter> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GameCenterT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct GameCenterBuilder {
	typedef GameCenter Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_player_id(flatbuffers::Offset<flatbuffers::String> player_id) {
		fbb_.AddOffset(GameCenter::VT_PLAYER_ID, player_id);
	}
	void add_bundle_id(flatbuffers::Offset<flatbuffers::String> bundle_id) {
		fbb_.AddOffset(GameCenter::VT_BUNDLE_ID, bundle_id);
	}
	void add_timestamp(int64_t timestamp) {
		fbb_.AddElement<int64_t>(GameCenter::VT_TIMESTAMP, timestamp, 0);
	}
	void add_salt(flatbuffers::Offset<flatbuffers::String> salt) {
		fbb_.AddOffset(GameCenter::VT_SALT, salt);
	}
	void add_signature(flatbuffers::Offset<flatbuffers::String> signature) {
		fbb_.AddOffset(GameCenter::VT_SIGNATURE, signature);
	}
	void add_public_key_url(flatbuffers::Offset<flatbuffers::String> public_key_url) {
		fbb_.AddOffset(GameCenter::VT_PUBLIC_KEY_URL, public_key_url);
	}
	explicit GameCenterBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<GameCenter> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<GameCenter>(end);
		return o;
	}
};

inline flatbuffers::Offset<GameCenter> CreateGameCenter(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> player_id = 0,
		flatbuffers::Offset<flatbuffers::String> bundle_id = 0,
		int64_t timestamp = 0,
		flatbuffers::Offset<flatbuffers::String> salt = 0,
		flatbuffers::Offset<flatbuffers::String> signature = 0,
		flatbuffers::Offset<flatbuffers::String> public_key_url = 0) {
	GameCenterBuilder builder_(_fbb);
	builder_.add_timestamp(timestamp);
	builder_.add_public_key_url(public_key_url);
	builder_.add_signature(signature);
	builder_.add_salt(salt);
	builder_.add_bundle_id(bundle_id);
	builder_.add_player_id(player_id);
	return builder_.Finish();
}

inline flatbuffers::Offset<GameCenter> CreateGameCenterDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *player_id = nullptr,
		const char *bundle_id = nullptr,
		int64_t timestamp = 0,
		const char *salt = nullptr,
		const char *signature = nullptr,
		const char *public_key_url = nullptr) {
	auto player_id__ = player_id ? _fbb.CreateString(player_id) : 0;
	auto bundle_id__ = bundle_id ? _fbb.CreateString(bundle_id) : 0;
	auto salt__ = salt ? _fbb.CreateString(salt) : 0;
	auto signature__ = signature ? _fbb.CreateString(signature) : 0;
	auto public_key_url__ = public_key_url ? _fbb.CreateString(public_key_url) : 0;
	return server::AuthenticateRequest_::CreateGameCenter(
			_fbb,
			player_id__,
			bundle_id__,
			timestamp,
			salt__,
			signature__,
			public_key_url__);
}

flatbuffers::Offset<GameCenter> CreateGameCenter(flatbuffers::FlatBufferBuilder &_fbb, const GameCenterT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AuthenticateMethodT : public flatbuffers::NativeTable {
	typedef AuthenticateMethod TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.AuthenticateRequest_.AuthenticateMethodT";
	}
	std::unique_ptr<server::AuthenticateRequest_::EmailT> email;
	CharString facebook;
	CharString google;
	std::unique_ptr<server::AuthenticateRequest_::GameCenterT> game_center;
	CharString steam;
	CharString device;
	CharString custom;
	AuthenticateMethodT() {
	}
};

struct AuthenticateMethod FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef AuthenticateMethodT NativeTableType;
	typedef AuthenticateMethodBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.AuthenticateRequest_.AuthenticateMethod";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_EMAIL = 4,
		VT_FACEBOOK = 6,
		VT_GOOGLE = 8,
		VT_GAME_CENTER = 10,
		VT_STEAM = 12,
		VT_DEVICE = 14,
		VT_CUSTOM = 16
	};
	/// Email address and password.
	const server::AuthenticateRequest_::Email *email() const {
		return GetPointer<const server::AuthenticateRequest_::Email *>(VT_EMAIL);
	}
	/// Facebook OAuth Access Token.
	const flatbuffers::String *facebook() const {
		return GetPointer<const flatbuffers::String *>(VT_FACEBOOK);
	}
	/// Google OAuth Access Token.
	const flatbuffers::String *google() const {
		return GetPointer<const flatbuffers::String *>(VT_GOOGLE);
	}
	/// GameCenter Authentication.
	const server::AuthenticateRequest_::GameCenter *game_center() const {
		return GetPointer<const server::AuthenticateRequest_::GameCenter *>(VT_GAME_CENTER);
	}
	/// Steam Token.
	const flatbuffers::String *steam() const {
		return GetPointer<const flatbuffers::String *>(VT_STEAM);
	}
	/// Device ID authentication.
	const flatbuffers::String *device() const {
		return GetPointer<const flatbuffers::String *>(VT_DEVICE);
	}
	/// Custom ID authentication.
	const flatbuffers::String *custom() const {
		return GetPointer<const flatbuffers::String *>(VT_CUSTOM);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_EMAIL) &&
				verifier.VerifyTable(email()) &&
				VerifyOffset(verifier, VT_FACEBOOK) &&
				verifier.VerifyString(facebook()) &&
				VerifyOffset(verifier, VT_GOOGLE) &&
				verifier.VerifyString(google()) &&
				VerifyOffset(verifier, VT_GAME_CENTER) &&
				verifier.VerifyTable(game_center()) &&
				VerifyOffset(verifier, VT_STEAM) &&
				verifier.VerifyString(steam()) &&
				VerifyOffset(verifier, VT_DEVICE) &&
				verifier.VerifyString(device()) &&
				VerifyOffset(verifier, VT_CUSTOM) &&
				verifier.VerifyString(custom()) &&
				verifier.EndTable();
	}
	AuthenticateMethodT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(AuthenticateMethodT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<AuthenticateMethod> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateMethodT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct AuthenticateMethodBuilder {
	typedef AuthenticateMethod Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_email(flatbuffers::Offset<server::AuthenticateRequest_::Email> email) {
		fbb_.AddOffset(AuthenticateMethod::VT_EMAIL, email);
	}
	void add_facebook(flatbuffers::Offset<flatbuffers::String> facebook) {
		fbb_.AddOffset(AuthenticateMethod::VT_FACEBOOK, facebook);
	}
	void add_google(flatbuffers::Offset<flatbuffers::String> google) {
		fbb_.AddOffset(AuthenticateMethod::VT_GOOGLE, google);
	}
	void add_game_center(flatbuffers::Offset<server::AuthenticateRequest_::GameCenter> game_center) {
		fbb_.AddOffset(AuthenticateMethod::VT_GAME_CENTER, game_center);
	}
	void add_steam(flatbuffers::Offset<flatbuffers::String> steam) {
		fbb_.AddOffset(AuthenticateMethod::VT_STEAM, steam);
	}
	void add_device(flatbuffers::Offset<flatbuffers::String> device) {
		fbb_.AddOffset(AuthenticateMethod::VT_DEVICE, device);
	}
	void add_custom(flatbuffers::Offset<flatbuffers::String> custom) {
		fbb_.AddOffset(AuthenticateMethod::VT_CUSTOM, custom);
	}
	explicit AuthenticateMethodBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<AuthenticateMethod> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<AuthenticateMethod>(end);
		return o;
	}
};

inline flatbuffers::Offset<AuthenticateMethod> CreateAuthenticateMethod(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<server::AuthenticateRequest_::Email> email = 0,
		flatbuffers::Offset<flatbuffers::String> facebook = 0,
		flatbuffers::Offset<flatbuffers::String> google = 0,
		flatbuffers::Offset<server::AuthenticateRequest_::GameCenter> game_center = 0,
		flatbuffers::Offset<flatbuffers::String> steam = 0,
		flatbuffers::Offset<flatbuffers::String> device = 0,
		flatbuffers::Offset<flatbuffers::String> custom = 0) {
	AuthenticateMethodBuilder builder_(_fbb);
	builder_.add_custom(custom);
	builder_.add_device(device);
	builder_.add_steam(steam);
	builder_.add_game_center(game_center);
	builder_.add_google(google);
	builder_.add_facebook(facebook);
	builder_.add_email(email);
	return builder_.Finish();
}

inline flatbuffers::Offset<AuthenticateMethod> CreateAuthenticateMethodDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<server::AuthenticateRequest_::Email> email = 0,
		const char *facebook = nullptr,
		const char *google = nullptr,
		flatbuffers::Offset<server::AuthenticateRequest_::GameCenter> game_center = 0,
		const char *steam = nullptr,
		const char *device = nullptr,
		const char *custom = nullptr) {
	auto facebook__ = facebook ? _fbb.CreateString(facebook) : 0;
	auto google__ = google ? _fbb.CreateString(google) : 0;
	auto steam__ = steam ? _fbb.CreateString(steam) : 0;
	auto device__ = device ? _fbb.CreateString(device) : 0;
	auto custom__ = custom ? _fbb.CreateString(custom) : 0;
	return server::AuthenticateRequest_::CreateAuthenticateMethod(
			_fbb,
			email,
			facebook__,
			google__,
			game_center,
			steam__,
			device__,
			custom__);
}

flatbuffers::Offset<AuthenticateMethod> CreateAuthenticateMethod(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateMethodT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

} // namespace AuthenticateRequest_

struct AuthenticateResponseT : public flatbuffers::NativeTable {
	typedef AuthenticateResponse TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.AuthenticateResponseT";
	}
	CharString collation_id;
	std::unique_ptr<server::AuthenticateResponse_::AuthenticateResultT> id;
	AuthenticateResponseT() {
	}
};

struct AuthenticateResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef AuthenticateResponseT NativeTableType;
	typedef AuthenticateResponseBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.AuthenticateResponse";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_COLLATION_ID = 4,
		VT_ID = 6
	};
	/// Optional collationID to track server response.
	const flatbuffers::String *collation_id() const {
		return GetPointer<const flatbuffers::String *>(VT_COLLATION_ID);
	}
	/// OneOf authentication response.
	const server::AuthenticateResponse_::AuthenticateResult *id() const {
		return GetPointer<const server::AuthenticateResponse_::AuthenticateResult *>(VT_ID);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_COLLATION_ID) &&
				verifier.VerifyString(collation_id()) &&
				VerifyOffset(verifier, VT_ID) &&
				verifier.VerifyTable(id()) &&
				verifier.EndTable();
	}
	AuthenticateResponseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(AuthenticateResponseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<AuthenticateResponse> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct AuthenticateResponseBuilder {
	typedef AuthenticateResponse Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_collation_id(flatbuffers::Offset<flatbuffers::String> collation_id) {
		fbb_.AddOffset(AuthenticateResponse::VT_COLLATION_ID, collation_id);
	}
	void add_id(flatbuffers::Offset<server::AuthenticateResponse_::AuthenticateResult> id) {
		fbb_.AddOffset(AuthenticateResponse::VT_ID, id);
	}
	explicit AuthenticateResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<AuthenticateResponse> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<AuthenticateResponse>(end);
		return o;
	}
};

inline flatbuffers::Offset<AuthenticateResponse> CreateAuthenticateResponse(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> collation_id = 0,
		flatbuffers::Offset<server::AuthenticateResponse_::AuthenticateResult> id = 0) {
	AuthenticateResponseBuilder builder_(_fbb);
	builder_.add_id(id);
	builder_.add_collation_id(collation_id);
	return builder_.Finish();
}

inline flatbuffers::Offset<AuthenticateResponse> CreateAuthenticateResponseDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *collation_id = nullptr,
		flatbuffers::Offset<server::AuthenticateResponse_::AuthenticateResult> id = 0) {
	auto collation_id__ = collation_id ? _fbb.CreateString(collation_id) : 0;
	return server::CreateAuthenticateResponse(
			_fbb,
			collation_id__,
			id);
}

flatbuffers::Offset<AuthenticateResponse> CreateAuthenticateResponse(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace AuthenticateResponse_ {

struct SessionT : public flatbuffers::NativeTable {
	typedef Session TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.AuthenticateResponse_.SessionT";
	}
	CharString token;
	CharString udp_token;
	SessionT() {
	}
};

struct Session FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef SessionT NativeTableType;
	typedef SessionBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.AuthenticateResponse_.Session";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_TOKEN = 4,
		VT_UDP_TOKEN = 6
	};
	/// Authentication Token.
	const flatbuffers::String *token() const {
		return GetPointer<const flatbuffers::String *>(VT_TOKEN);
	}
	/// UDP token.
	const flatbuffers::String *udp_token() const {
		return GetPointer<const flatbuffers::String *>(VT_UDP_TOKEN);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_TOKEN) &&
				verifier.VerifyString(token()) &&
				VerifyOffset(verifier, VT_UDP_TOKEN) &&
				verifier.VerifyString(udp_token()) &&
				verifier.EndTable();
	}
	SessionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(SessionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<Session> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SessionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct SessionBuilder {
	typedef Session Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_token(flatbuffers::Offset<flatbuffers::String> token) {
		fbb_.AddOffset(Session::VT_TOKEN, token);
	}
	void add_udp_token(flatbuffers::Offset<flatbuffers::String> udp_token) {
		fbb_.AddOffset(Session::VT_UDP_TOKEN, udp_token);
	}
	explicit SessionBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<Session> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Session>(end);
		return o;
	}
};

inline flatbuffers::Offset<Session> CreateSession(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> token = 0,
		flatbuffers::Offset<flatbuffers::String> udp_token = 0) {
	SessionBuilder builder_(_fbb);
	builder_.add_udp_token(udp_token);
	builder_.add_token(token);
	return builder_.Finish();
}

inline flatbuffers::Offset<Session> CreateSessionDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *token = nullptr,
		const char *udp_token = nullptr) {
	auto token__ = token ? _fbb.CreateString(token) : 0;
	auto udp_token__ = udp_token ? _fbb.CreateString(udp_token) : 0;
	return server::AuthenticateResponse_::CreateSession(
			_fbb,
			token__,
			udp_token__);
}

flatbuffers::Offset<Session> CreateSession(flatbuffers::FlatBufferBuilder &_fbb, const SessionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ErrorT : public flatbuffers::NativeTable {
	typedef Error TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.AuthenticateResponse_.ErrorT";
	}
	int32_t code;
	CharString message;
	std::unique_ptr<server::AuthenticateRequestT> request;
	ErrorT() :
			code(0) {
	}
};

struct Error FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef ErrorT NativeTableType;
	typedef ErrorBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.AuthenticateResponse_.Error";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_CODE = 4,
		VT_MESSAGE = 6,
		VT_REQUEST = 8
	};
	/// Error code - this will be the same as the global error codes.
	int32_t code() const {
		return GetField<int32_t>(VT_CODE, 0);
	}
	/// Specific error message.
	const flatbuffers::String *message() const {
		return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
	}
	/// Original request that caused this error.
	const server::AuthenticateRequest *request() const {
		return GetPointer<const server::AuthenticateRequest *>(VT_REQUEST);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyField<int32_t>(verifier, VT_CODE) &&
				VerifyOffset(verifier, VT_MESSAGE) &&
				verifier.VerifyString(message()) &&
				VerifyOffset(verifier, VT_REQUEST) &&
				verifier.VerifyTable(request()) &&
				verifier.EndTable();
	}
	ErrorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(ErrorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<Error> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ErrorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct ErrorBuilder {
	typedef Error Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_code(int32_t code) {
		fbb_.AddElement<int32_t>(Error::VT_CODE, code, 0);
	}
	void add_message(flatbuffers::Offset<flatbuffers::String> message) {
		fbb_.AddOffset(Error::VT_MESSAGE, message);
	}
	void add_request(flatbuffers::Offset<server::AuthenticateRequest> request) {
		fbb_.AddOffset(Error::VT_REQUEST, request);
	}
	explicit ErrorBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<Error> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Error>(end);
		return o;
	}
};

inline flatbuffers::Offset<Error> CreateError(
		flatbuffers::FlatBufferBuilder &_fbb,
		int32_t code = 0,
		flatbuffers::Offset<flatbuffers::String> message = 0,
		flatbuffers::Offset<server::AuthenticateRequest> request = 0) {
	ErrorBuilder builder_(_fbb);
	builder_.add_request(request);
	builder_.add_message(message);
	builder_.add_code(code);
	return builder_.Finish();
}

inline flatbuffers::Offset<Error> CreateErrorDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		int32_t code = 0,
		const char *message = nullptr,
		flatbuffers::Offset<server::AuthenticateRequest> request = 0) {
	auto message__ = message ? _fbb.CreateString(message) : 0;
	return server::AuthenticateResponse_::CreateError(
			_fbb,
			code,
			message__,
			request);
}

flatbuffers::Offset<Error> CreateError(flatbuffers::FlatBufferBuilder &_fbb, const ErrorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AuthenticateResultT : public flatbuffers::NativeTable {
	typedef AuthenticateResult TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.AuthenticateResponse_.AuthenticateResultT";
	}
	std::unique_ptr<server::AuthenticateResponse_::SessionT> session;
	std::unique_ptr<server::AuthenticateResponse_::ErrorT> error;
	AuthenticateResultT() {
	}
};

struct AuthenticateResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef AuthenticateResultT NativeTableType;
	typedef AuthenticateResultBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.AuthenticateResponse_.AuthenticateResult";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_SESSION = 4,
		VT_ERROR = 6
	};
	/// Authentication session.
	const server::AuthenticateResponse_::Session *session() const {
		return GetPointer<const server::AuthenticateResponse_::Session *>(VT_SESSION);
	}
	/// Authentication error.
	const server::AuthenticateResponse_::Error *error() const {
		return GetPointer<const server::AuthenticateResponse_::Error *>(VT_ERROR);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_SESSION) &&
				verifier.VerifyTable(session()) &&
				VerifyOffset(verifier, VT_ERROR) &&
				verifier.VerifyTable(error()) &&
				verifier.EndTable();
	}
	AuthenticateResultT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(AuthenticateResultT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<AuthenticateResult> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateResultT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct AuthenticateResultBuilder {
	typedef AuthenticateResult Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_session(flatbuffers::Offset<server::AuthenticateResponse_::Session> session) {
		fbb_.AddOffset(AuthenticateResult::VT_SESSION, session);
	}
	void add_error(flatbuffers::Offset<server::AuthenticateResponse_::Error> error) {
		fbb_.AddOffset(AuthenticateResult::VT_ERROR, error);
	}
	explicit AuthenticateResultBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<AuthenticateResult> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<AuthenticateResult>(end);
		return o;
	}
};

inline flatbuffers::Offset<AuthenticateResult> CreateAuthenticateResult(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<server::AuthenticateResponse_::Session> session = 0,
		flatbuffers::Offset<server::AuthenticateResponse_::Error> error = 0) {
	AuthenticateResultBuilder builder_(_fbb);
	builder_.add_error(error);
	builder_.add_session(session);
	return builder_.Finish();
}

flatbuffers::Offset<AuthenticateResult> CreateAuthenticateResult(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateResultT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

} // namespace AuthenticateResponse_

struct EnvelopeT : public flatbuffers::NativeTable {
	typedef Envelope TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.EnvelopeT";
	}
	CharString collation_id;
	std::unique_ptr<server::Envelope_::EnvelopeContentT> payload;
	EnvelopeT() {
	}
};

struct Envelope FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef EnvelopeT NativeTableType;
	typedef EnvelopeBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.Envelope";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_COLLATION_ID = 4,
		VT_PAYLOAD = 6
	};
	/// Optional collationID to track server response.
	const flatbuffers::String *collation_id() const {
		return GetPointer<const flatbuffers::String *>(VT_COLLATION_ID);
	}
	/// OneOf envelope payload. This can be both for request and response purposes.
	const server::Envelope_::EnvelopeContent *payload() const {
		return GetPointer<const server::Envelope_::EnvelopeContent *>(VT_PAYLOAD);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_COLLATION_ID) &&
				verifier.VerifyString(collation_id()) &&
				VerifyOffset(verifier, VT_PAYLOAD) &&
				verifier.VerifyTable(payload()) &&
				verifier.EndTable();
	}
	EnvelopeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(EnvelopeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<Envelope> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EnvelopeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct EnvelopeBuilder {
	typedef Envelope Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_collation_id(flatbuffers::Offset<flatbuffers::String> collation_id) {
		fbb_.AddOffset(Envelope::VT_COLLATION_ID, collation_id);
	}
	void add_payload(flatbuffers::Offset<server::Envelope_::EnvelopeContent> payload) {
		fbb_.AddOffset(Envelope::VT_PAYLOAD, payload);
	}
	explicit EnvelopeBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<Envelope> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Envelope>(end);
		return o;
	}
};

inline flatbuffers::Offset<Envelope> CreateEnvelope(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> collation_id = 0,
		flatbuffers::Offset<server::Envelope_::EnvelopeContent> payload = 0) {
	EnvelopeBuilder builder_(_fbb);
	builder_.add_payload(payload);
	builder_.add_collation_id(collation_id);
	return builder_.Finish();
}

inline flatbuffers::Offset<Envelope> CreateEnvelopeDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *collation_id = nullptr,
		flatbuffers::Offset<server::Envelope_::EnvelopeContent> payload = 0) {
	auto collation_id__ = collation_id ? _fbb.CreateString(collation_id) : 0;
	return server::CreateEnvelope(
			_fbb,
			collation_id__,
			payload);
}

flatbuffers::Offset<Envelope> CreateEnvelope(flatbuffers::FlatBufferBuilder &_fbb, const EnvelopeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace Envelope_ {

struct EnvelopeContentT : public flatbuffers::NativeTable {
	typedef EnvelopeContent TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.Envelope_.EnvelopeContentT";
	}
	std::unique_ptr<server::ErrorT> error;
	std::unique_ptr<server::HeartbeatT> heartbeat;
	std::unique_ptr<server::LogoutT> logout;
	std::unique_ptr<server::TLinkT> link;
	std::unique_ptr<server::TUnlinkT> unlink;
	std::unique_ptr<server::TSelfFetchT> self_fetch;
	std::unique_ptr<server::TSelfUpdateT> self_update;
	std::unique_ptr<server::TUsersFetchT> users_fetch;
	std::unique_ptr<server::TSelfT> self;
	std::unique_ptr<server::TUsersT> users;
	std::unique_ptr<server::TFriendsAddT> friends_add;
	std::unique_ptr<server::TFriendsRemoveT> friends_remove;
	std::unique_ptr<server::TFriendsBlockT> friends_block;
	std::unique_ptr<server::TFriendsListT> friends_list;
	std::unique_ptr<server::TFriendsT> friends;
	std::unique_ptr<server::TGroupsCreateT> groups_create;
	std::unique_ptr<server::TGroupsUpdateT> groups_update;
	std::unique_ptr<server::TGroupsRemoveT> groups_remove;
	std::unique_ptr<server::TGroupsFetchT> groups_fetch;
	std::unique_ptr<server::TGroupsListT> groups_list;
	std::unique_ptr<server::TGroupsSelfListT> groups_self_list;
	std::unique_ptr<server::TGroupUsersListT> group_users_list;
	std::unique_ptr<server::TGroupsJoinT> groups_join;
	std::unique_ptr<server::TGroupsLeaveT> groups_leave;
	std::unique_ptr<server::TGroupUsersAddT> group_users_add;
	std::unique_ptr<server::TGroupUsersKickT> group_users_kick;
	std::unique_ptr<server::TGroupUsersPromoteT> group_users_promote;
	std::unique_ptr<server::TGroupsT> groups;
	std::unique_ptr<server::TGroupsSelfT> groups_self;
	std::unique_ptr<server::TGroupUsersT> group_users;
	std::unique_ptr<server::TTopicsJoinT> topics_join;
	std::unique_ptr<server::TTopicsLeaveT> topics_leave;
	std::unique_ptr<server::TTopicMessageSendT> topic_message_send;
	std::unique_ptr<server::TTopicMessagesListT> topic_messages_list;
	std::unique_ptr<server::TTopicsT> topics;
	std::unique_ptr<server::TTopicMessageAckT> topic_message_ack;
	std::unique_ptr<server::TopicMessageT> topic_message;
	std::unique_ptr<server::TTopicMessagesT> topic_messages;
	std::unique_ptr<server::TopicPresenceT> topic_presence;
	std::unique_ptr<server::TMatchCreateT> match_create;
	std::unique_ptr<server::TMatchesJoinT> matches_join;
	std::unique_ptr<server::TMatchesLeaveT> matches_leave;
	std::unique_ptr<server::MatchDataSendT> match_data_send;
	std::unique_ptr<server::TMatchT> match;
	std::unique_ptr<server::TMatchesT> matches;
	std::unique_ptr<server::MatchDataT> match_data;
	std::unique_ptr<server::MatchPresenceT> match_presence;
	std::unique_ptr<server::TStorageListT> storage_list;
	std::unique_ptr<server::TStorageFetchT> storage_fetch;
	std::unique_ptr<server::TStorageWriteT> storage_write;
	std::unique_ptr<server::TStorageUpdateT> storage_update;
	std::unique_ptr<server::TStorageRemoveT> storage_remove;
	std::unique_ptr<server::TStorageDataT> storage_data;
	std::unique_ptr<server::TStorageKeysT> storage_keys;
	std::unique_ptr<server::TLeaderboardsListT> leaderboards_list;
	std::unique_ptr<server::TLeaderboardRecordsWriteT> leaderboard_records_write;
	std::unique_ptr<server::TLeaderboardRecordsFetchT> leaderboard_records_fetch;
	std::unique_ptr<server::TLeaderboardRecordsListT> leaderboard_records_list;
	std::unique_ptr<server::TLeaderboardsT> leaderboards;
	std::unique_ptr<server::TLeaderboardRecordsT> leaderboard_records;
	std::unique_ptr<server::TMatchmakeAddT> matchmake_add;
	std::unique_ptr<server::TMatchmakeRemoveT> matchmake_remove;
	std::unique_ptr<server::TMatchmakeTicketT> matchmake_ticket;
	std::unique_ptr<server::MatchmakeMatchedT> matchmake_matched;
	std::unique_ptr<server::TRpcT> rpc;
	std::unique_ptr<server::TPurchaseValidationT> purchase;
	std::unique_ptr<server::TPurchaseRecordT> purchase_record;
	std::unique_ptr<server::TNotificationsListT> notifications_list;
	std::unique_ptr<server::TNotificationsRemoveT> notifications_remove;
	std::unique_ptr<server::TNotificationsT> notifications;
	std::unique_ptr<server::NotificationsT> live_notifications;
	EnvelopeContentT() {
	}
};

struct EnvelopeContent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef EnvelopeContentT NativeTableType;
	typedef EnvelopeContentBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.Envelope_.EnvelopeContent";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_ERROR = 4,
		VT_HEARTBEAT = 6,
		VT_LOGOUT = 8,
		VT_LINK = 10,
		VT_UNLINK = 12,
		VT_SELF_FETCH = 14,
		VT_SELF_UPDATE = 16,
		VT_USERS_FETCH = 18,
		VT_SELF = 20,
		VT_USERS = 22,
		VT_FRIENDS_ADD = 24,
		VT_FRIENDS_REMOVE = 26,
		VT_FRIENDS_BLOCK = 28,
		VT_FRIENDS_LIST = 30,
		VT_FRIENDS = 32,
		VT_GROUPS_CREATE = 34,
		VT_GROUPS_UPDATE = 36,
		VT_GROUPS_REMOVE = 38,
		VT_GROUPS_FETCH = 40,
		VT_GROUPS_LIST = 42,
		VT_GROUPS_SELF_LIST = 44,
		VT_GROUP_USERS_LIST = 46,
		VT_GROUPS_JOIN = 48,
		VT_GROUPS_LEAVE = 50,
		VT_GROUP_USERS_ADD = 52,
		VT_GROUP_USERS_KICK = 54,
		VT_GROUP_USERS_PROMOTE = 56,
		VT_GROUPS = 58,
		VT_GROUPS_SELF = 60,
		VT_GROUP_USERS = 62,
		VT_TOPICS_JOIN = 64,
		VT_TOPICS_LEAVE = 66,
		VT_TOPIC_MESSAGE_SEND = 68,
		VT_TOPIC_MESSAGES_LIST = 70,
		VT_TOPICS = 72,
		VT_TOPIC_MESSAGE_ACK = 74,
		VT_TOPIC_MESSAGE = 76,
		VT_TOPIC_MESSAGES = 78,
		VT_TOPIC_PRESENCE = 80,
		VT_MATCH_CREATE = 82,
		VT_MATCHES_JOIN = 84,
		VT_MATCHES_LEAVE = 86,
		VT_MATCH_DATA_SEND = 88,
		VT_MATCH = 90,
		VT_MATCHES = 92,
		VT_MATCH_DATA = 94,
		VT_MATCH_PRESENCE = 96,
		VT_STORAGE_LIST = 98,
		VT_STORAGE_FETCH = 100,
		VT_STORAGE_WRITE = 102,
		VT_STORAGE_UPDATE = 104,
		VT_STORAGE_REMOVE = 106,
		VT_STORAGE_DATA = 108,
		VT_STORAGE_KEYS = 110,
		VT_LEADERBOARDS_LIST = 112,
		VT_LEADERBOARD_RECORDS_WRITE = 114,
		VT_LEADERBOARD_RECORDS_FETCH = 116,
		VT_LEADERBOARD_RECORDS_LIST = 118,
		VT_LEADERBOARDS = 120,
		VT_LEADERBOARD_RECORDS = 122,
		VT_MATCHMAKE_ADD = 124,
		VT_MATCHMAKE_REMOVE = 126,
		VT_MATCHMAKE_TICKET = 128,
		VT_MATCHMAKE_MATCHED = 130,
		VT_RPC = 132,
		VT_PURCHASE = 134,
		VT_PURCHASE_RECORD = 136,
		VT_NOTIFICATIONS_LIST = 138,
		VT_NOTIFICATIONS_REMOVE = 140,
		VT_NOTIFICATIONS = 142,
		VT_LIVE_NOTIFICATIONS = 144
	};
	const server::Error *error() const {
		return GetPointer<const server::Error *>(VT_ERROR);
	}
	const server::Heartbeat *heartbeat() const {
		return GetPointer<const server::Heartbeat *>(VT_HEARTBEAT);
	}
	const server::Logout *logout() const {
		return GetPointer<const server::Logout *>(VT_LOGOUT);
	}
	const server::TLink *link() const {
		return GetPointer<const server::TLink *>(VT_LINK);
	}
	const server::TUnlink *unlink() const {
		return GetPointer<const server::TUnlink *>(VT_UNLINK);
	}
	const server::TSelfFetch *self_fetch() const {
		return GetPointer<const server::TSelfFetch *>(VT_SELF_FETCH);
	}
	const server::TSelfUpdate *self_update() const {
		return GetPointer<const server::TSelfUpdate *>(VT_SELF_UPDATE);
	}
	const server::TUsersFetch *users_fetch() const {
		return GetPointer<const server::TUsersFetch *>(VT_USERS_FETCH);
	}
	const server::TSelf *self() const {
		return GetPointer<const server::TSelf *>(VT_SELF);
	}
	const server::TUsers *users() const {
		return GetPointer<const server::TUsers *>(VT_USERS);
	}
	const server::TFriendsAdd *friends_add() const {
		return GetPointer<const server::TFriendsAdd *>(VT_FRIENDS_ADD);
	}
	const server::TFriendsRemove *friends_remove() const {
		return GetPointer<const server::TFriendsRemove *>(VT_FRIENDS_REMOVE);
	}
	const server::TFriendsBlock *friends_block() const {
		return GetPointer<const server::TFriendsBlock *>(VT_FRIENDS_BLOCK);
	}
	const server::TFriendsList *friends_list() const {
		return GetPointer<const server::TFriendsList *>(VT_FRIENDS_LIST);
	}
	const server::TFriends *friends() const {
		return GetPointer<const server::TFriends *>(VT_FRIENDS);
	}
	const server::TGroupsCreate *groups_create() const {
		return GetPointer<const server::TGroupsCreate *>(VT_GROUPS_CREATE);
	}
	const server::TGroupsUpdate *groups_update() const {
		return GetPointer<const server::TGroupsUpdate *>(VT_GROUPS_UPDATE);
	}
	const server::TGroupsRemove *groups_remove() const {
		return GetPointer<const server::TGroupsRemove *>(VT_GROUPS_REMOVE);
	}
	const server::TGroupsFetch *groups_fetch() const {
		return GetPointer<const server::TGroupsFetch *>(VT_GROUPS_FETCH);
	}
	const server::TGroupsList *groups_list() const {
		return GetPointer<const server::TGroupsList *>(VT_GROUPS_LIST);
	}
	const server::TGroupsSelfList *groups_self_list() const {
		return GetPointer<const server::TGroupsSelfList *>(VT_GROUPS_SELF_LIST);
	}
	const server::TGroupUsersList *group_users_list() const {
		return GetPointer<const server::TGroupUsersList *>(VT_GROUP_USERS_LIST);
	}
	const server::TGroupsJoin *groups_join() const {
		return GetPointer<const server::TGroupsJoin *>(VT_GROUPS_JOIN);
	}
	const server::TGroupsLeave *groups_leave() const {
		return GetPointer<const server::TGroupsLeave *>(VT_GROUPS_LEAVE);
	}
	const server::TGroupUsersAdd *group_users_add() const {
		return GetPointer<const server::TGroupUsersAdd *>(VT_GROUP_USERS_ADD);
	}
	const server::TGroupUsersKick *group_users_kick() const {
		return GetPointer<const server::TGroupUsersKick *>(VT_GROUP_USERS_KICK);
	}
	const server::TGroupUsersPromote *group_users_promote() const {
		return GetPointer<const server::TGroupUsersPromote *>(VT_GROUP_USERS_PROMOTE);
	}
	const server::TGroups *groups() const {
		return GetPointer<const server::TGroups *>(VT_GROUPS);
	}
	const server::TGroupsSelf *groups_self() const {
		return GetPointer<const server::TGroupsSelf *>(VT_GROUPS_SELF);
	}
	const server::TGroupUsers *group_users() const {
		return GetPointer<const server::TGroupUsers *>(VT_GROUP_USERS);
	}
	const server::TTopicsJoin *topics_join() const {
		return GetPointer<const server::TTopicsJoin *>(VT_TOPICS_JOIN);
	}
	const server::TTopicsLeave *topics_leave() const {
		return GetPointer<const server::TTopicsLeave *>(VT_TOPICS_LEAVE);
	}
	const server::TTopicMessageSend *topic_message_send() const {
		return GetPointer<const server::TTopicMessageSend *>(VT_TOPIC_MESSAGE_SEND);
	}
	const server::TTopicMessagesList *topic_messages_list() const {
		return GetPointer<const server::TTopicMessagesList *>(VT_TOPIC_MESSAGES_LIST);
	}
	const server::TTopics *topics() const {
		return GetPointer<const server::TTopics *>(VT_TOPICS);
	}
	const server::TTopicMessageAck *topic_message_ack() const {
		return GetPointer<const server::TTopicMessageAck *>(VT_TOPIC_MESSAGE_ACK);
	}
	const server::TopicMessage *topic_message() const {
		return GetPointer<const server::TopicMessage *>(VT_TOPIC_MESSAGE);
	}
	const server::TTopicMessages *topic_messages() const {
		return GetPointer<const server::TTopicMessages *>(VT_TOPIC_MESSAGES);
	}
	const server::TopicPresence *topic_presence() const {
		return GetPointer<const server::TopicPresence *>(VT_TOPIC_PRESENCE);
	}
	const server::TMatchCreate *match_create() const {
		return GetPointer<const server::TMatchCreate *>(VT_MATCH_CREATE);
	}
	const server::TMatchesJoin *matches_join() const {
		return GetPointer<const server::TMatchesJoin *>(VT_MATCHES_JOIN);
	}
	const server::TMatchesLeave *matches_leave() const {
		return GetPointer<const server::TMatchesLeave *>(VT_MATCHES_LEAVE);
	}
	const server::MatchDataSend *match_data_send() const {
		return GetPointer<const server::MatchDataSend *>(VT_MATCH_DATA_SEND);
	}
	const server::TMatch *match() const {
		return GetPointer<const server::TMatch *>(VT_MATCH);
	}
	const server::TMatches *matches() const {
		return GetPointer<const server::TMatches *>(VT_MATCHES);
	}
	const server::MatchData *match_data() const {
		return GetPointer<const server::MatchData *>(VT_MATCH_DATA);
	}
	const server::MatchPresence *match_presence() const {
		return GetPointer<const server::MatchPresence *>(VT_MATCH_PRESENCE);
	}
	const server::TStorageList *storage_list() const {
		return GetPointer<const server::TStorageList *>(VT_STORAGE_LIST);
	}
	const server::TStorageFetch *storage_fetch() const {
		return GetPointer<const server::TStorageFetch *>(VT_STORAGE_FETCH);
	}
	const server::TStorageWrite *storage_write() const {
		return GetPointer<const server::TStorageWrite *>(VT_STORAGE_WRITE);
	}
	const server::TStorageUpdate *storage_update() const {
		return GetPointer<const server::TStorageUpdate *>(VT_STORAGE_UPDATE);
	}
	const server::TStorageRemove *storage_remove() const {
		return GetPointer<const server::TStorageRemove *>(VT_STORAGE_REMOVE);
	}
	const server::TStorageData *storage_data() const {
		return GetPointer<const server::TStorageData *>(VT_STORAGE_DATA);
	}
	const server::TStorageKeys *storage_keys() const {
		return GetPointer<const server::TStorageKeys *>(VT_STORAGE_KEYS);
	}
	const server::TLeaderboardsList *leaderboards_list() const {
		return GetPointer<const server::TLeaderboardsList *>(VT_LEADERBOARDS_LIST);
	}
	const server::TLeaderboardRecordsWrite *leaderboard_records_write() const {
		return GetPointer<const server::TLeaderboardRecordsWrite *>(VT_LEADERBOARD_RECORDS_WRITE);
	}
	const server::TLeaderboardRecordsFetch *leaderboard_records_fetch() const {
		return GetPointer<const server::TLeaderboardRecordsFetch *>(VT_LEADERBOARD_RECORDS_FETCH);
	}
	const server::TLeaderboardRecordsList *leaderboard_records_list() const {
		return GetPointer<const server::TLeaderboardRecordsList *>(VT_LEADERBOARD_RECORDS_LIST);
	}
	const server::TLeaderboards *leaderboards() const {
		return GetPointer<const server::TLeaderboards *>(VT_LEADERBOARDS);
	}
	const server::TLeaderboardRecords *leaderboard_records() const {
		return GetPointer<const server::TLeaderboardRecords *>(VT_LEADERBOARD_RECORDS);
	}
	const server::TMatchmakeAdd *matchmake_add() const {
		return GetPointer<const server::TMatchmakeAdd *>(VT_MATCHMAKE_ADD);
	}
	const server::TMatchmakeRemove *matchmake_remove() const {
		return GetPointer<const server::TMatchmakeRemove *>(VT_MATCHMAKE_REMOVE);
	}
	const server::TMatchmakeTicket *matchmake_ticket() const {
		return GetPointer<const server::TMatchmakeTicket *>(VT_MATCHMAKE_TICKET);
	}
	const server::MatchmakeMatched *matchmake_matched() const {
		return GetPointer<const server::MatchmakeMatched *>(VT_MATCHMAKE_MATCHED);
	}
	const server::TRpc *rpc() const {
		return GetPointer<const server::TRpc *>(VT_RPC);
	}
	const server::TPurchaseValidation *purchase() const {
		return GetPointer<const server::TPurchaseValidation *>(VT_PURCHASE);
	}
	const server::TPurchaseRecord *purchase_record() const {
		return GetPointer<const server::TPurchaseRecord *>(VT_PURCHASE_RECORD);
	}
	const server::TNotificationsList *notifications_list() const {
		return GetPointer<const server::TNotificationsList *>(VT_NOTIFICATIONS_LIST);
	}
	const server::TNotificationsRemove *notifications_remove() const {
		return GetPointer<const server::TNotificationsRemove *>(VT_NOTIFICATIONS_REMOVE);
	}
	const server::TNotifications *notifications() const {
		return GetPointer<const server::TNotifications *>(VT_NOTIFICATIONS);
	}
	const server::Notifications *live_notifications() const {
		return GetPointer<const server::Notifications *>(VT_LIVE_NOTIFICATIONS);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_ERROR) &&
				verifier.VerifyTable(error()) &&
				VerifyOffset(verifier, VT_HEARTBEAT) &&
				verifier.VerifyTable(heartbeat()) &&
				VerifyOffset(verifier, VT_LOGOUT) &&
				verifier.VerifyTable(logout()) &&
				VerifyOffset(verifier, VT_LINK) &&
				verifier.VerifyTable(link()) &&
				VerifyOffset(verifier, VT_UNLINK) &&
				verifier.VerifyTable(unlink()) &&
				VerifyOffset(verifier, VT_SELF_FETCH) &&
				verifier.VerifyTable(self_fetch()) &&
				VerifyOffset(verifier, VT_SELF_UPDATE) &&
				verifier.VerifyTable(self_update()) &&
				VerifyOffset(verifier, VT_USERS_FETCH) &&
				verifier.VerifyTable(users_fetch()) &&
				VerifyOffset(verifier, VT_SELF) &&
				verifier.VerifyTable(self()) &&
				VerifyOffset(verifier, VT_USERS) &&
				verifier.VerifyTable(users()) &&
				VerifyOffset(verifier, VT_FRIENDS_ADD) &&
				verifier.VerifyTable(friends_add()) &&
				VerifyOffset(verifier, VT_FRIENDS_REMOVE) &&
				verifier.VerifyTable(friends_remove()) &&
				VerifyOffset(verifier, VT_FRIENDS_BLOCK) &&
				verifier.VerifyTable(friends_block()) &&
				VerifyOffset(verifier, VT_FRIENDS_LIST) &&
				verifier.VerifyTable(friends_list()) &&
				VerifyOffset(verifier, VT_FRIENDS) &&
				verifier.VerifyTable(friends()) &&
				VerifyOffset(verifier, VT_GROUPS_CREATE) &&
				verifier.VerifyTable(groups_create()) &&
				VerifyOffset(verifier, VT_GROUPS_UPDATE) &&
				verifier.VerifyTable(groups_update()) &&
				VerifyOffset(verifier, VT_GROUPS_REMOVE) &&
				verifier.VerifyTable(groups_remove()) &&
				VerifyOffset(verifier, VT_GROUPS_FETCH) &&
				verifier.VerifyTable(groups_fetch()) &&
				VerifyOffset(verifier, VT_GROUPS_LIST) &&
				verifier.VerifyTable(groups_list()) &&
				VerifyOffset(verifier, VT_GROUPS_SELF_LIST) &&
				verifier.VerifyTable(groups_self_list()) &&
				VerifyOffset(verifier, VT_GROUP_USERS_LIST) &&
				verifier.VerifyTable(group_users_list()) &&
				VerifyOffset(verifier, VT_GROUPS_JOIN) &&
				verifier.VerifyTable(groups_join()) &&
				VerifyOffset(verifier, VT_GROUPS_LEAVE) &&
				verifier.VerifyTable(groups_leave()) &&
				VerifyOffset(verifier, VT_GROUP_USERS_ADD) &&
				verifier.VerifyTable(group_users_add()) &&
				VerifyOffset(verifier, VT_GROUP_USERS_KICK) &&
				verifier.VerifyTable(group_users_kick()) &&
				VerifyOffset(verifier, VT_GROUP_USERS_PROMOTE) &&
				verifier.VerifyTable(group_users_promote()) &&
				VerifyOffset(verifier, VT_GROUPS) &&
				verifier.VerifyTable(groups()) &&
				VerifyOffset(verifier, VT_GROUPS_SELF) &&
				verifier.VerifyTable(groups_self()) &&
				VerifyOffset(verifier, VT_GROUP_USERS) &&
				verifier.VerifyTable(group_users()) &&
				VerifyOffset(verifier, VT_TOPICS_JOIN) &&
				verifier.VerifyTable(topics_join()) &&
				VerifyOffset(verifier, VT_TOPICS_LEAVE) &&
				verifier.VerifyTable(topics_leave()) &&
				VerifyOffset(verifier, VT_TOPIC_MESSAGE_SEND) &&
				verifier.VerifyTable(topic_message_send()) &&
				VerifyOffset(verifier, VT_TOPIC_MESSAGES_LIST) &&
				verifier.VerifyTable(topic_messages_list()) &&
				VerifyOffset(verifier, VT_TOPICS) &&
				verifier.VerifyTable(topics()) &&
				VerifyOffset(verifier, VT_TOPIC_MESSAGE_ACK) &&
				verifier.VerifyTable(topic_message_ack()) &&
				VerifyOffset(verifier, VT_TOPIC_MESSAGE) &&
				verifier.VerifyTable(topic_message()) &&
				VerifyOffset(verifier, VT_TOPIC_MESSAGES) &&
				verifier.VerifyTable(topic_messages()) &&
				VerifyOffset(verifier, VT_TOPIC_PRESENCE) &&
				verifier.VerifyTable(topic_presence()) &&
				VerifyOffset(verifier, VT_MATCH_CREATE) &&
				verifier.VerifyTable(match_create()) &&
				VerifyOffset(verifier, VT_MATCHES_JOIN) &&
				verifier.VerifyTable(matches_join()) &&
				VerifyOffset(verifier, VT_MATCHES_LEAVE) &&
				verifier.VerifyTable(matches_leave()) &&
				VerifyOffset(verifier, VT_MATCH_DATA_SEND) &&
				verifier.VerifyTable(match_data_send()) &&
				VerifyOffset(verifier, VT_MATCH) &&
				verifier.VerifyTable(match()) &&
				VerifyOffset(verifier, VT_MATCHES) &&
				verifier.VerifyTable(matches()) &&
				VerifyOffset(verifier, VT_MATCH_DATA) &&
				verifier.VerifyTable(match_data()) &&
				VerifyOffset(verifier, VT_MATCH_PRESENCE) &&
				verifier.VerifyTable(match_presence()) &&
				VerifyOffset(verifier, VT_STORAGE_LIST) &&
				verifier.VerifyTable(storage_list()) &&
				VerifyOffset(verifier, VT_STORAGE_FETCH) &&
				verifier.VerifyTable(storage_fetch()) &&
				VerifyOffset(verifier, VT_STORAGE_WRITE) &&
				verifier.VerifyTable(storage_write()) &&
				VerifyOffset(verifier, VT_STORAGE_UPDATE) &&
				verifier.VerifyTable(storage_update()) &&
				VerifyOffset(verifier, VT_STORAGE_REMOVE) &&
				verifier.VerifyTable(storage_remove()) &&
				VerifyOffset(verifier, VT_STORAGE_DATA) &&
				verifier.VerifyTable(storage_data()) &&
				VerifyOffset(verifier, VT_STORAGE_KEYS) &&
				verifier.VerifyTable(storage_keys()) &&
				VerifyOffset(verifier, VT_LEADERBOARDS_LIST) &&
				verifier.VerifyTable(leaderboards_list()) &&
				VerifyOffset(verifier, VT_LEADERBOARD_RECORDS_WRITE) &&
				verifier.VerifyTable(leaderboard_records_write()) &&
				VerifyOffset(verifier, VT_LEADERBOARD_RECORDS_FETCH) &&
				verifier.VerifyTable(leaderboard_records_fetch()) &&
				VerifyOffset(verifier, VT_LEADERBOARD_RECORDS_LIST) &&
				verifier.VerifyTable(leaderboard_records_list()) &&
				VerifyOffset(verifier, VT_LEADERBOARDS) &&
				verifier.VerifyTable(leaderboards()) &&
				VerifyOffset(verifier, VT_LEADERBOARD_RECORDS) &&
				verifier.VerifyTable(leaderboard_records()) &&
				VerifyOffset(verifier, VT_MATCHMAKE_ADD) &&
				verifier.VerifyTable(matchmake_add()) &&
				VerifyOffset(verifier, VT_MATCHMAKE_REMOVE) &&
				verifier.VerifyTable(matchmake_remove()) &&
				VerifyOffset(verifier, VT_MATCHMAKE_TICKET) &&
				verifier.VerifyTable(matchmake_ticket()) &&
				VerifyOffset(verifier, VT_MATCHMAKE_MATCHED) &&
				verifier.VerifyTable(matchmake_matched()) &&
				VerifyOffset(verifier, VT_RPC) &&
				verifier.VerifyTable(rpc()) &&
				VerifyOffset(verifier, VT_PURCHASE) &&
				verifier.VerifyTable(purchase()) &&
				VerifyOffset(verifier, VT_PURCHASE_RECORD) &&
				verifier.VerifyTable(purchase_record()) &&
				VerifyOffset(verifier, VT_NOTIFICATIONS_LIST) &&
				verifier.VerifyTable(notifications_list()) &&
				VerifyOffset(verifier, VT_NOTIFICATIONS_REMOVE) &&
				verifier.VerifyTable(notifications_remove()) &&
				VerifyOffset(verifier, VT_NOTIFICATIONS) &&
				verifier.VerifyTable(notifications()) &&
				VerifyOffset(verifier, VT_LIVE_NOTIFICATIONS) &&
				verifier.VerifyTable(live_notifications()) &&
				verifier.EndTable();
	}
	EnvelopeContentT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(EnvelopeContentT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<EnvelopeContent> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EnvelopeContentT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct EnvelopeContentBuilder {
	typedef EnvelopeContent Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_error(flatbuffers::Offset<server::Error> error) {
		fbb_.AddOffset(EnvelopeContent::VT_ERROR, error);
	}
	void add_heartbeat(flatbuffers::Offset<server::Heartbeat> heartbeat) {
		fbb_.AddOffset(EnvelopeContent::VT_HEARTBEAT, heartbeat);
	}
	void add_logout(flatbuffers::Offset<server::Logout> logout) {
		fbb_.AddOffset(EnvelopeContent::VT_LOGOUT, logout);
	}
	void add_link(flatbuffers::Offset<server::TLink> link) {
		fbb_.AddOffset(EnvelopeContent::VT_LINK, link);
	}
	void add_unlink(flatbuffers::Offset<server::TUnlink> unlink) {
		fbb_.AddOffset(EnvelopeContent::VT_UNLINK, unlink);
	}
	void add_self_fetch(flatbuffers::Offset<server::TSelfFetch> self_fetch) {
		fbb_.AddOffset(EnvelopeContent::VT_SELF_FETCH, self_fetch);
	}
	void add_self_update(flatbuffers::Offset<server::TSelfUpdate> self_update) {
		fbb_.AddOffset(EnvelopeContent::VT_SELF_UPDATE, self_update);
	}
	void add_users_fetch(flatbuffers::Offset<server::TUsersFetch> users_fetch) {
		fbb_.AddOffset(EnvelopeContent::VT_USERS_FETCH, users_fetch);
	}
	void add_self(flatbuffers::Offset<server::TSelf> self) {
		fbb_.AddOffset(EnvelopeContent::VT_SELF, self);
	}
	void add_users(flatbuffers::Offset<server::TUsers> users) {
		fbb_.AddOffset(EnvelopeContent::VT_USERS, users);
	}
	void add_friends_add(flatbuffers::Offset<server::TFriendsAdd> friends_add) {
		fbb_.AddOffset(EnvelopeContent::VT_FRIENDS_ADD, friends_add);
	}
	void add_friends_remove(flatbuffers::Offset<server::TFriendsRemove> friends_remove) {
		fbb_.AddOffset(EnvelopeContent::VT_FRIENDS_REMOVE, friends_remove);
	}
	void add_friends_block(flatbuffers::Offset<server::TFriendsBlock> friends_block) {
		fbb_.AddOffset(EnvelopeContent::VT_FRIENDS_BLOCK, friends_block);
	}
	void add_friends_list(flatbuffers::Offset<server::TFriendsList> friends_list) {
		fbb_.AddOffset(EnvelopeContent::VT_FRIENDS_LIST, friends_list);
	}
	void add_friends(flatbuffers::Offset<server::TFriends> friends) {
		fbb_.AddOffset(EnvelopeContent::VT_FRIENDS, friends);
	}
	void add_groups_create(flatbuffers::Offset<server::TGroupsCreate> groups_create) {
		fbb_.AddOffset(EnvelopeContent::VT_GROUPS_CREATE, groups_create);
	}
	void add_groups_update(flatbuffers::Offset<server::TGroupsUpdate> groups_update) {
		fbb_.AddOffset(EnvelopeContent::VT_GROUPS_UPDATE, groups_update);
	}
	void add_groups_remove(flatbuffers::Offset<server::TGroupsRemove> groups_remove) {
		fbb_.AddOffset(EnvelopeContent::VT_GROUPS_REMOVE, groups_remove);
	}
	void add_groups_fetch(flatbuffers::Offset<server::TGroupsFetch> groups_fetch) {
		fbb_.AddOffset(EnvelopeContent::VT_GROUPS_FETCH, groups_fetch);
	}
	void add_groups_list(flatbuffers::Offset<server::TGroupsList> groups_list) {
		fbb_.AddOffset(EnvelopeContent::VT_GROUPS_LIST, groups_list);
	}
	void add_groups_self_list(flatbuffers::Offset<server::TGroupsSelfList> groups_self_list) {
		fbb_.AddOffset(EnvelopeContent::VT_GROUPS_SELF_LIST, groups_self_list);
	}
	void add_group_users_list(flatbuffers::Offset<server::TGroupUsersList> group_users_list) {
		fbb_.AddOffset(EnvelopeContent::VT_GROUP_USERS_LIST, group_users_list);
	}
	void add_groups_join(flatbuffers::Offset<server::TGroupsJoin> groups_join) {
		fbb_.AddOffset(EnvelopeContent::VT_GROUPS_JOIN, groups_join);
	}
	void add_groups_leave(flatbuffers::Offset<server::TGroupsLeave> groups_leave) {
		fbb_.AddOffset(EnvelopeContent::VT_GROUPS_LEAVE, groups_leave);
	}
	void add_group_users_add(flatbuffers::Offset<server::TGroupUsersAdd> group_users_add) {
		fbb_.AddOffset(EnvelopeContent::VT_GROUP_USERS_ADD, group_users_add);
	}
	void add_group_users_kick(flatbuffers::Offset<server::TGroupUsersKick> group_users_kick) {
		fbb_.AddOffset(EnvelopeContent::VT_GROUP_USERS_KICK, group_users_kick);
	}
	void add_group_users_promote(flatbuffers::Offset<server::TGroupUsersPromote> group_users_promote) {
		fbb_.AddOffset(EnvelopeContent::VT_GROUP_USERS_PROMOTE, group_users_promote);
	}
	void add_groups(flatbuffers::Offset<server::TGroups> groups) {
		fbb_.AddOffset(EnvelopeContent::VT_GROUPS, groups);
	}
	void add_groups_self(flatbuffers::Offset<server::TGroupsSelf> groups_self) {
		fbb_.AddOffset(EnvelopeContent::VT_GROUPS_SELF, groups_self);
	}
	void add_group_users(flatbuffers::Offset<server::TGroupUsers> group_users) {
		fbb_.AddOffset(EnvelopeContent::VT_GROUP_USERS, group_users);
	}
	void add_topics_join(flatbuffers::Offset<server::TTopicsJoin> topics_join) {
		fbb_.AddOffset(EnvelopeContent::VT_TOPICS_JOIN, topics_join);
	}
	void add_topics_leave(flatbuffers::Offset<server::TTopicsLeave> topics_leave) {
		fbb_.AddOffset(EnvelopeContent::VT_TOPICS_LEAVE, topics_leave);
	}
	void add_topic_message_send(flatbuffers::Offset<server::TTopicMessageSend> topic_message_send) {
		fbb_.AddOffset(EnvelopeContent::VT_TOPIC_MESSAGE_SEND, topic_message_send);
	}
	void add_topic_messages_list(flatbuffers::Offset<server::TTopicMessagesList> topic_messages_list) {
		fbb_.AddOffset(EnvelopeContent::VT_TOPIC_MESSAGES_LIST, topic_messages_list);
	}
	void add_topics(flatbuffers::Offset<server::TTopics> topics) {
		fbb_.AddOffset(EnvelopeContent::VT_TOPICS, topics);
	}
	void add_topic_message_ack(flatbuffers::Offset<server::TTopicMessageAck> topic_message_ack) {
		fbb_.AddOffset(EnvelopeContent::VT_TOPIC_MESSAGE_ACK, topic_message_ack);
	}
	void add_topic_message(flatbuffers::Offset<server::TopicMessage> topic_message) {
		fbb_.AddOffset(EnvelopeContent::VT_TOPIC_MESSAGE, topic_message);
	}
	void add_topic_messages(flatbuffers::Offset<server::TTopicMessages> topic_messages) {
		fbb_.AddOffset(EnvelopeContent::VT_TOPIC_MESSAGES, topic_messages);
	}
	void add_topic_presence(flatbuffers::Offset<server::TopicPresence> topic_presence) {
		fbb_.AddOffset(EnvelopeContent::VT_TOPIC_PRESENCE, topic_presence);
	}
	void add_match_create(flatbuffers::Offset<server::TMatchCreate> match_create) {
		fbb_.AddOffset(EnvelopeContent::VT_MATCH_CREATE, match_create);
	}
	void add_matches_join(flatbuffers::Offset<server::TMatchesJoin> matches_join) {
		fbb_.AddOffset(EnvelopeContent::VT_MATCHES_JOIN, matches_join);
	}
	void add_matches_leave(flatbuffers::Offset<server::TMatchesLeave> matches_leave) {
		fbb_.AddOffset(EnvelopeContent::VT_MATCHES_LEAVE, matches_leave);
	}
	void add_match_data_send(flatbuffers::Offset<server::MatchDataSend> match_data_send) {
		fbb_.AddOffset(EnvelopeContent::VT_MATCH_DATA_SEND, match_data_send);
	}
	void add_match(flatbuffers::Offset<server::TMatch> match) {
		fbb_.AddOffset(EnvelopeContent::VT_MATCH, match);
	}
	void add_matches(flatbuffers::Offset<server::TMatches> matches) {
		fbb_.AddOffset(EnvelopeContent::VT_MATCHES, matches);
	}
	void add_match_data(flatbuffers::Offset<server::MatchData> match_data) {
		fbb_.AddOffset(EnvelopeContent::VT_MATCH_DATA, match_data);
	}
	void add_match_presence(flatbuffers::Offset<server::MatchPresence> match_presence) {
		fbb_.AddOffset(EnvelopeContent::VT_MATCH_PRESENCE, match_presence);
	}
	void add_storage_list(flatbuffers::Offset<server::TStorageList> storage_list) {
		fbb_.AddOffset(EnvelopeContent::VT_STORAGE_LIST, storage_list);
	}
	void add_storage_fetch(flatbuffers::Offset<server::TStorageFetch> storage_fetch) {
		fbb_.AddOffset(EnvelopeContent::VT_STORAGE_FETCH, storage_fetch);
	}
	void add_storage_write(flatbuffers::Offset<server::TStorageWrite> storage_write) {
		fbb_.AddOffset(EnvelopeContent::VT_STORAGE_WRITE, storage_write);
	}
	void add_storage_update(flatbuffers::Offset<server::TStorageUpdate> storage_update) {
		fbb_.AddOffset(EnvelopeContent::VT_STORAGE_UPDATE, storage_update);
	}
	void add_storage_remove(flatbuffers::Offset<server::TStorageRemove> storage_remove) {
		fbb_.AddOffset(EnvelopeContent::VT_STORAGE_REMOVE, storage_remove);
	}
	void add_storage_data(flatbuffers::Offset<server::TStorageData> storage_data) {
		fbb_.AddOffset(EnvelopeContent::VT_STORAGE_DATA, storage_data);
	}
	void add_storage_keys(flatbuffers::Offset<server::TStorageKeys> storage_keys) {
		fbb_.AddOffset(EnvelopeContent::VT_STORAGE_KEYS, storage_keys);
	}
	void add_leaderboards_list(flatbuffers::Offset<server::TLeaderboardsList> leaderboards_list) {
		fbb_.AddOffset(EnvelopeContent::VT_LEADERBOARDS_LIST, leaderboards_list);
	}
	void add_leaderboard_records_write(flatbuffers::Offset<server::TLeaderboardRecordsWrite> leaderboard_records_write) {
		fbb_.AddOffset(EnvelopeContent::VT_LEADERBOARD_RECORDS_WRITE, leaderboard_records_write);
	}
	void add_leaderboard_records_fetch(flatbuffers::Offset<server::TLeaderboardRecordsFetch> leaderboard_records_fetch) {
		fbb_.AddOffset(EnvelopeContent::VT_LEADERBOARD_RECORDS_FETCH, leaderboard_records_fetch);
	}
	void add_leaderboard_records_list(flatbuffers::Offset<server::TLeaderboardRecordsList> leaderboard_records_list) {
		fbb_.AddOffset(EnvelopeContent::VT_LEADERBOARD_RECORDS_LIST, leaderboard_records_list);
	}
	void add_leaderboards(flatbuffers::Offset<server::TLeaderboards> leaderboards) {
		fbb_.AddOffset(EnvelopeContent::VT_LEADERBOARDS, leaderboards);
	}
	void add_leaderboard_records(flatbuffers::Offset<server::TLeaderboardRecords> leaderboard_records) {
		fbb_.AddOffset(EnvelopeContent::VT_LEADERBOARD_RECORDS, leaderboard_records);
	}
	void add_matchmake_add(flatbuffers::Offset<server::TMatchmakeAdd> matchmake_add) {
		fbb_.AddOffset(EnvelopeContent::VT_MATCHMAKE_ADD, matchmake_add);
	}
	void add_matchmake_remove(flatbuffers::Offset<server::TMatchmakeRemove> matchmake_remove) {
		fbb_.AddOffset(EnvelopeContent::VT_MATCHMAKE_REMOVE, matchmake_remove);
	}
	void add_matchmake_ticket(flatbuffers::Offset<server::TMatchmakeTicket> matchmake_ticket) {
		fbb_.AddOffset(EnvelopeContent::VT_MATCHMAKE_TICKET, matchmake_ticket);
	}
	void add_matchmake_matched(flatbuffers::Offset<server::MatchmakeMatched> matchmake_matched) {
		fbb_.AddOffset(EnvelopeContent::VT_MATCHMAKE_MATCHED, matchmake_matched);
	}
	void add_rpc(flatbuffers::Offset<server::TRpc> rpc) {
		fbb_.AddOffset(EnvelopeContent::VT_RPC, rpc);
	}
	void add_purchase(flatbuffers::Offset<server::TPurchaseValidation> purchase) {
		fbb_.AddOffset(EnvelopeContent::VT_PURCHASE, purchase);
	}
	void add_purchase_record(flatbuffers::Offset<server::TPurchaseRecord> purchase_record) {
		fbb_.AddOffset(EnvelopeContent::VT_PURCHASE_RECORD, purchase_record);
	}
	void add_notifications_list(flatbuffers::Offset<server::TNotificationsList> notifications_list) {
		fbb_.AddOffset(EnvelopeContent::VT_NOTIFICATIONS_LIST, notifications_list);
	}
	void add_notifications_remove(flatbuffers::Offset<server::TNotificationsRemove> notifications_remove) {
		fbb_.AddOffset(EnvelopeContent::VT_NOTIFICATIONS_REMOVE, notifications_remove);
	}
	void add_notifications(flatbuffers::Offset<server::TNotifications> notifications) {
		fbb_.AddOffset(EnvelopeContent::VT_NOTIFICATIONS, notifications);
	}
	void add_live_notifications(flatbuffers::Offset<server::Notifications> live_notifications) {
		fbb_.AddOffset(EnvelopeContent::VT_LIVE_NOTIFICATIONS, live_notifications);
	}
	explicit EnvelopeContentBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<EnvelopeContent> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<EnvelopeContent>(end);
		return o;
	}
};

inline flatbuffers::Offset<EnvelopeContent> CreateEnvelopeContent(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<server::Error> error = 0,
		flatbuffers::Offset<server::Heartbeat> heartbeat = 0,
		flatbuffers::Offset<server::Logout> logout = 0,
		flatbuffers::Offset<server::TLink> link = 0,
		flatbuffers::Offset<server::TUnlink> unlink = 0,
		flatbuffers::Offset<server::TSelfFetch> self_fetch = 0,
		flatbuffers::Offset<server::TSelfUpdate> self_update = 0,
		flatbuffers::Offset<server::TUsersFetch> users_fetch = 0,
		flatbuffers::Offset<server::TSelf> self = 0,
		flatbuffers::Offset<server::TUsers> users = 0,
		flatbuffers::Offset<server::TFriendsAdd> friends_add = 0,
		flatbuffers::Offset<server::TFriendsRemove> friends_remove = 0,
		flatbuffers::Offset<server::TFriendsBlock> friends_block = 0,
		flatbuffers::Offset<server::TFriendsList> friends_list = 0,
		flatbuffers::Offset<server::TFriends> friends = 0,
		flatbuffers::Offset<server::TGroupsCreate> groups_create = 0,
		flatbuffers::Offset<server::TGroupsUpdate> groups_update = 0,
		flatbuffers::Offset<server::TGroupsRemove> groups_remove = 0,
		flatbuffers::Offset<server::TGroupsFetch> groups_fetch = 0,
		flatbuffers::Offset<server::TGroupsList> groups_list = 0,
		flatbuffers::Offset<server::TGroupsSelfList> groups_self_list = 0,
		flatbuffers::Offset<server::TGroupUsersList> group_users_list = 0,
		flatbuffers::Offset<server::TGroupsJoin> groups_join = 0,
		flatbuffers::Offset<server::TGroupsLeave> groups_leave = 0,
		flatbuffers::Offset<server::TGroupUsersAdd> group_users_add = 0,
		flatbuffers::Offset<server::TGroupUsersKick> group_users_kick = 0,
		flatbuffers::Offset<server::TGroupUsersPromote> group_users_promote = 0,
		flatbuffers::Offset<server::TGroups> groups = 0,
		flatbuffers::Offset<server::TGroupsSelf> groups_self = 0,
		flatbuffers::Offset<server::TGroupUsers> group_users = 0,
		flatbuffers::Offset<server::TTopicsJoin> topics_join = 0,
		flatbuffers::Offset<server::TTopicsLeave> topics_leave = 0,
		flatbuffers::Offset<server::TTopicMessageSend> topic_message_send = 0,
		flatbuffers::Offset<server::TTopicMessagesList> topic_messages_list = 0,
		flatbuffers::Offset<server::TTopics> topics = 0,
		flatbuffers::Offset<server::TTopicMessageAck> topic_message_ack = 0,
		flatbuffers::Offset<server::TopicMessage> topic_message = 0,
		flatbuffers::Offset<server::TTopicMessages> topic_messages = 0,
		flatbuffers::Offset<server::TopicPresence> topic_presence = 0,
		flatbuffers::Offset<server::TMatchCreate> match_create = 0,
		flatbuffers::Offset<server::TMatchesJoin> matches_join = 0,
		flatbuffers::Offset<server::TMatchesLeave> matches_leave = 0,
		flatbuffers::Offset<server::MatchDataSend> match_data_send = 0,
		flatbuffers::Offset<server::TMatch> match = 0,
		flatbuffers::Offset<server::TMatches> matches = 0,
		flatbuffers::Offset<server::MatchData> match_data = 0,
		flatbuffers::Offset<server::MatchPresence> match_presence = 0,
		flatbuffers::Offset<server::TStorageList> storage_list = 0,
		flatbuffers::Offset<server::TStorageFetch> storage_fetch = 0,
		flatbuffers::Offset<server::TStorageWrite> storage_write = 0,
		flatbuffers::Offset<server::TStorageUpdate> storage_update = 0,
		flatbuffers::Offset<server::TStorageRemove> storage_remove = 0,
		flatbuffers::Offset<server::TStorageData> storage_data = 0,
		flatbuffers::Offset<server::TStorageKeys> storage_keys = 0,
		flatbuffers::Offset<server::TLeaderboardsList> leaderboards_list = 0,
		flatbuffers::Offset<server::TLeaderboardRecordsWrite> leaderboard_records_write = 0,
		flatbuffers::Offset<server::TLeaderboardRecordsFetch> leaderboard_records_fetch = 0,
		flatbuffers::Offset<server::TLeaderboardRecordsList> leaderboard_records_list = 0,
		flatbuffers::Offset<server::TLeaderboards> leaderboards = 0,
		flatbuffers::Offset<server::TLeaderboardRecords> leaderboard_records = 0,
		flatbuffers::Offset<server::TMatchmakeAdd> matchmake_add = 0,
		flatbuffers::Offset<server::TMatchmakeRemove> matchmake_remove = 0,
		flatbuffers::Offset<server::TMatchmakeTicket> matchmake_ticket = 0,
		flatbuffers::Offset<server::MatchmakeMatched> matchmake_matched = 0,
		flatbuffers::Offset<server::TRpc> rpc = 0,
		flatbuffers::Offset<server::TPurchaseValidation> purchase = 0,
		flatbuffers::Offset<server::TPurchaseRecord> purchase_record = 0,
		flatbuffers::Offset<server::TNotificationsList> notifications_list = 0,
		flatbuffers::Offset<server::TNotificationsRemove> notifications_remove = 0,
		flatbuffers::Offset<server::TNotifications> notifications = 0,
		flatbuffers::Offset<server::Notifications> live_notifications = 0) {
	EnvelopeContentBuilder builder_(_fbb);
	builder_.add_live_notifications(live_notifications);
	builder_.add_notifications(notifications);
	builder_.add_notifications_remove(notifications_remove);
	builder_.add_notifications_list(notifications_list);
	builder_.add_purchase_record(purchase_record);
	builder_.add_purchase(purchase);
	builder_.add_rpc(rpc);
	builder_.add_matchmake_matched(matchmake_matched);
	builder_.add_matchmake_ticket(matchmake_ticket);
	builder_.add_matchmake_remove(matchmake_remove);
	builder_.add_matchmake_add(matchmake_add);
	builder_.add_leaderboard_records(leaderboard_records);
	builder_.add_leaderboards(leaderboards);
	builder_.add_leaderboard_records_list(leaderboard_records_list);
	builder_.add_leaderboard_records_fetch(leaderboard_records_fetch);
	builder_.add_leaderboard_records_write(leaderboard_records_write);
	builder_.add_leaderboards_list(leaderboards_list);
	builder_.add_storage_keys(storage_keys);
	builder_.add_storage_data(storage_data);
	builder_.add_storage_remove(storage_remove);
	builder_.add_storage_update(storage_update);
	builder_.add_storage_write(storage_write);
	builder_.add_storage_fetch(storage_fetch);
	builder_.add_storage_list(storage_list);
	builder_.add_match_presence(match_presence);
	builder_.add_match_data(match_data);
	builder_.add_matches(matches);
	builder_.add_match(match);
	builder_.add_match_data_send(match_data_send);
	builder_.add_matches_leave(matches_leave);
	builder_.add_matches_join(matches_join);
	builder_.add_match_create(match_create);
	builder_.add_topic_presence(topic_presence);
	builder_.add_topic_messages(topic_messages);
	builder_.add_topic_message(topic_message);
	builder_.add_topic_message_ack(topic_message_ack);
	builder_.add_topics(topics);
	builder_.add_topic_messages_list(topic_messages_list);
	builder_.add_topic_message_send(topic_message_send);
	builder_.add_topics_leave(topics_leave);
	builder_.add_topics_join(topics_join);
	builder_.add_group_users(group_users);
	builder_.add_groups_self(groups_self);
	builder_.add_groups(groups);
	builder_.add_group_users_promote(group_users_promote);
	builder_.add_group_users_kick(group_users_kick);
	builder_.add_group_users_add(group_users_add);
	builder_.add_groups_leave(groups_leave);
	builder_.add_groups_join(groups_join);
	builder_.add_group_users_list(group_users_list);
	builder_.add_groups_self_list(groups_self_list);
	builder_.add_groups_list(groups_list);
	builder_.add_groups_fetch(groups_fetch);
	builder_.add_groups_remove(groups_remove);
	builder_.add_groups_update(groups_update);
	builder_.add_groups_create(groups_create);
	builder_.add_friends(friends);
	builder_.add_friends_list(friends_list);
	builder_.add_friends_block(friends_block);
	builder_.add_friends_remove(friends_remove);
	builder_.add_friends_add(friends_add);
	builder_.add_users(users);
	builder_.add_self(self);
	builder_.add_users_fetch(users_fetch);
	builder_.add_self_update(self_update);
	builder_.add_self_fetch(self_fetch);
	builder_.add_unlink(unlink);
	builder_.add_link(link);
	builder_.add_logout(logout);
	builder_.add_heartbeat(heartbeat);
	builder_.add_error(error);
	return builder_.Finish();
}

flatbuffers::Offset<EnvelopeContent> CreateEnvelopeContent(flatbuffers::FlatBufferBuilder &_fbb, const EnvelopeContentT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

} // namespace Envelope_

struct LogoutT : public flatbuffers::NativeTable {
	typedef Logout TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.LogoutT";
	}
	LogoutT() {
	}
};

struct Logout FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef LogoutT NativeTableType;
	typedef LogoutBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.Logout";
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				verifier.EndTable();
	}
	LogoutT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(LogoutT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<Logout> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogoutT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct LogoutBuilder {
	typedef Logout Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	explicit LogoutBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<Logout> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Logout>(end);
		return o;
	}
};

inline flatbuffers::Offset<Logout> CreateLogout(
		flatbuffers::FlatBufferBuilder &_fbb) {
	LogoutBuilder builder_(_fbb);
	return builder_.Finish();
}

flatbuffers::Offset<Logout> CreateLogout(flatbuffers::FlatBufferBuilder &_fbb, const LogoutT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TLinkT : public flatbuffers::NativeTable {
	typedef TLink TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TLinkT";
	}
	std::unique_ptr<server::TLink_::Anonymous3T> id;
	TLinkT() {
	}
};

struct TLink FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TLinkT NativeTableType;
	typedef TLinkBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TLink";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_ID = 4
	};
	/// OneOf linking methods.
	const server::TLink_::Anonymous3 *id() const {
		return GetPointer<const server::TLink_::Anonymous3 *>(VT_ID);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_ID) &&
				verifier.VerifyTable(id()) &&
				verifier.EndTable();
	}
	TLinkT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TLinkT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TLink> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TLinkT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TLinkBuilder {
	typedef TLink Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_id(flatbuffers::Offset<server::TLink_::Anonymous3> id) {
		fbb_.AddOffset(TLink::VT_ID, id);
	}
	explicit TLinkBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TLink> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TLink>(end);
		return o;
	}
};

inline flatbuffers::Offset<TLink> CreateTLink(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<server::TLink_::Anonymous3> id = 0) {
	TLinkBuilder builder_(_fbb);
	builder_.add_id(id);
	return builder_.Finish();
}

flatbuffers::Offset<TLink> CreateTLink(flatbuffers::FlatBufferBuilder &_fbb, const TLinkT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace TLink_ {

struct Anonymous3T : public flatbuffers::NativeTable {
	typedef Anonymous3 TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TLink_.Anonymous3T";
	}
	std::unique_ptr<server::AuthenticateRequest_::EmailT> email;
	CharString facebook;
	CharString google;
	std::unique_ptr<server::AuthenticateRequest_::GameCenterT> game_center;
	CharString steam;
	CharString device;
	CharString custom;
	Anonymous3T() {
	}
};

struct Anonymous3 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef Anonymous3T NativeTableType;
	typedef Anonymous3Builder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TLink_.Anonymous3";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_EMAIL = 4,
		VT_FACEBOOK = 6,
		VT_GOOGLE = 8,
		VT_GAME_CENTER = 10,
		VT_STEAM = 12,
		VT_DEVICE = 14,
		VT_CUSTOM = 16
	};
	/// Email address and password.
	const server::AuthenticateRequest_::Email *email() const {
		return GetPointer<const server::AuthenticateRequest_::Email *>(VT_EMAIL);
	}
	/// Facebook OAuth Access Token.
	const flatbuffers::String *facebook() const {
		return GetPointer<const flatbuffers::String *>(VT_FACEBOOK);
	}
	/// Google OAuth Access Token.
	const flatbuffers::String *google() const {
		return GetPointer<const flatbuffers::String *>(VT_GOOGLE);
	}
	/// GameCenter.
	const server::AuthenticateRequest_::GameCenter *game_center() const {
		return GetPointer<const server::AuthenticateRequest_::GameCenter *>(VT_GAME_CENTER);
	}
	/// Steam Token.
	const flatbuffers::String *steam() const {
		return GetPointer<const flatbuffers::String *>(VT_STEAM);
	}
	/// Device ID.
	const flatbuffers::String *device() const {
		return GetPointer<const flatbuffers::String *>(VT_DEVICE);
	}
	/// Custom ID.
	const flatbuffers::String *custom() const {
		return GetPointer<const flatbuffers::String *>(VT_CUSTOM);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_EMAIL) &&
				verifier.VerifyTable(email()) &&
				VerifyOffset(verifier, VT_FACEBOOK) &&
				verifier.VerifyString(facebook()) &&
				VerifyOffset(verifier, VT_GOOGLE) &&
				verifier.VerifyString(google()) &&
				VerifyOffset(verifier, VT_GAME_CENTER) &&
				verifier.VerifyTable(game_center()) &&
				VerifyOffset(verifier, VT_STEAM) &&
				verifier.VerifyString(steam()) &&
				VerifyOffset(verifier, VT_DEVICE) &&
				verifier.VerifyString(device()) &&
				VerifyOffset(verifier, VT_CUSTOM) &&
				verifier.VerifyString(custom()) &&
				verifier.EndTable();
	}
	Anonymous3T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(Anonymous3T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<Anonymous3> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Anonymous3T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct Anonymous3Builder {
	typedef Anonymous3 Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_email(flatbuffers::Offset<server::AuthenticateRequest_::Email> email) {
		fbb_.AddOffset(Anonymous3::VT_EMAIL, email);
	}
	void add_facebook(flatbuffers::Offset<flatbuffers::String> facebook) {
		fbb_.AddOffset(Anonymous3::VT_FACEBOOK, facebook);
	}
	void add_google(flatbuffers::Offset<flatbuffers::String> google) {
		fbb_.AddOffset(Anonymous3::VT_GOOGLE, google);
	}
	void add_game_center(flatbuffers::Offset<server::AuthenticateRequest_::GameCenter> game_center) {
		fbb_.AddOffset(Anonymous3::VT_GAME_CENTER, game_center);
	}
	void add_steam(flatbuffers::Offset<flatbuffers::String> steam) {
		fbb_.AddOffset(Anonymous3::VT_STEAM, steam);
	}
	void add_device(flatbuffers::Offset<flatbuffers::String> device) {
		fbb_.AddOffset(Anonymous3::VT_DEVICE, device);
	}
	void add_custom(flatbuffers::Offset<flatbuffers::String> custom) {
		fbb_.AddOffset(Anonymous3::VT_CUSTOM, custom);
	}
	explicit Anonymous3Builder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<Anonymous3> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Anonymous3>(end);
		return o;
	}
};

inline flatbuffers::Offset<Anonymous3> CreateAnonymous3(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<server::AuthenticateRequest_::Email> email = 0,
		flatbuffers::Offset<flatbuffers::String> facebook = 0,
		flatbuffers::Offset<flatbuffers::String> google = 0,
		flatbuffers::Offset<server::AuthenticateRequest_::GameCenter> game_center = 0,
		flatbuffers::Offset<flatbuffers::String> steam = 0,
		flatbuffers::Offset<flatbuffers::String> device = 0,
		flatbuffers::Offset<flatbuffers::String> custom = 0) {
	Anonymous3Builder builder_(_fbb);
	builder_.add_custom(custom);
	builder_.add_device(device);
	builder_.add_steam(steam);
	builder_.add_game_center(game_center);
	builder_.add_google(google);
	builder_.add_facebook(facebook);
	builder_.add_email(email);
	return builder_.Finish();
}

inline flatbuffers::Offset<Anonymous3> CreateAnonymous3Direct(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<server::AuthenticateRequest_::Email> email = 0,
		const char *facebook = nullptr,
		const char *google = nullptr,
		flatbuffers::Offset<server::AuthenticateRequest_::GameCenter> game_center = 0,
		const char *steam = nullptr,
		const char *device = nullptr,
		const char *custom = nullptr) {
	auto facebook__ = facebook ? _fbb.CreateString(facebook) : 0;
	auto google__ = google ? _fbb.CreateString(google) : 0;
	auto steam__ = steam ? _fbb.CreateString(steam) : 0;
	auto device__ = device ? _fbb.CreateString(device) : 0;
	auto custom__ = custom ? _fbb.CreateString(custom) : 0;
	return server::TLink_::CreateAnonymous3(
			_fbb,
			email,
			facebook__,
			google__,
			game_center,
			steam__,
			device__,
			custom__);
}

flatbuffers::Offset<Anonymous3> CreateAnonymous3(flatbuffers::FlatBufferBuilder &_fbb, const Anonymous3T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

} // namespace TLink_

struct TUnlinkT : public flatbuffers::NativeTable {
	typedef TUnlink TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TUnlinkT";
	}
	std::unique_ptr<server::TUnlink_::Anonymous4T> id;
	TUnlinkT() {
	}
};

struct TUnlink FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TUnlinkT NativeTableType;
	typedef TUnlinkBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TUnlink";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_ID = 4
	};
	/// OneOf unlinking methods.
	const server::TUnlink_::Anonymous4 *id() const {
		return GetPointer<const server::TUnlink_::Anonymous4 *>(VT_ID);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_ID) &&
				verifier.VerifyTable(id()) &&
				verifier.EndTable();
	}
	TUnlinkT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TUnlinkT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TUnlink> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TUnlinkT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TUnlinkBuilder {
	typedef TUnlink Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_id(flatbuffers::Offset<server::TUnlink_::Anonymous4> id) {
		fbb_.AddOffset(TUnlink::VT_ID, id);
	}
	explicit TUnlinkBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TUnlink> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TUnlink>(end);
		return o;
	}
};

inline flatbuffers::Offset<TUnlink> CreateTUnlink(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<server::TUnlink_::Anonymous4> id = 0) {
	TUnlinkBuilder builder_(_fbb);
	builder_.add_id(id);
	return builder_.Finish();
}

flatbuffers::Offset<TUnlink> CreateTUnlink(flatbuffers::FlatBufferBuilder &_fbb, const TUnlinkT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace TUnlink_ {

struct Anonymous4T : public flatbuffers::NativeTable {
	typedef Anonymous4 TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TUnlink_.Anonymous4T";
	}
	CharString email;
	CharString facebook;
	CharString google;
	CharString game_center;
	CharString steam;
	CharString device;
	CharString custom;
	Anonymous4T() {
	}
};

struct Anonymous4 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef Anonymous4T NativeTableType;
	typedef Anonymous4Builder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TUnlink_.Anonymous4";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_EMAIL = 4,
		VT_FACEBOOK = 6,
		VT_GOOGLE = 8,
		VT_GAME_CENTER = 10,
		VT_STEAM = 12,
		VT_DEVICE = 14,
		VT_CUSTOM = 16
	};
	/// Email address.
	const flatbuffers::String *email() const {
		return GetPointer<const flatbuffers::String *>(VT_EMAIL);
	}
	/// Facebook ID.
	const flatbuffers::String *facebook() const {
		return GetPointer<const flatbuffers::String *>(VT_FACEBOOK);
	}
	/// Google ID.
	const flatbuffers::String *google() const {
		return GetPointer<const flatbuffers::String *>(VT_GOOGLE);
	}
	/// GameCenter ID.
	const flatbuffers::String *game_center() const {
		return GetPointer<const flatbuffers::String *>(VT_GAME_CENTER);
	}
	/// Steam ID.
	const flatbuffers::String *steam() const {
		return GetPointer<const flatbuffers::String *>(VT_STEAM);
	}
	/// Device ID.
	const flatbuffers::String *device() const {
		return GetPointer<const flatbuffers::String *>(VT_DEVICE);
	}
	/// Custom ID.
	const flatbuffers::String *custom() const {
		return GetPointer<const flatbuffers::String *>(VT_CUSTOM);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_EMAIL) &&
				verifier.VerifyString(email()) &&
				VerifyOffset(verifier, VT_FACEBOOK) &&
				verifier.VerifyString(facebook()) &&
				VerifyOffset(verifier, VT_GOOGLE) &&
				verifier.VerifyString(google()) &&
				VerifyOffset(verifier, VT_GAME_CENTER) &&
				verifier.VerifyString(game_center()) &&
				VerifyOffset(verifier, VT_STEAM) &&
				verifier.VerifyString(steam()) &&
				VerifyOffset(verifier, VT_DEVICE) &&
				verifier.VerifyString(device()) &&
				VerifyOffset(verifier, VT_CUSTOM) &&
				verifier.VerifyString(custom()) &&
				verifier.EndTable();
	}
	Anonymous4T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(Anonymous4T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<Anonymous4> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Anonymous4T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct Anonymous4Builder {
	typedef Anonymous4 Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_email(flatbuffers::Offset<flatbuffers::String> email) {
		fbb_.AddOffset(Anonymous4::VT_EMAIL, email);
	}
	void add_facebook(flatbuffers::Offset<flatbuffers::String> facebook) {
		fbb_.AddOffset(Anonymous4::VT_FACEBOOK, facebook);
	}
	void add_google(flatbuffers::Offset<flatbuffers::String> google) {
		fbb_.AddOffset(Anonymous4::VT_GOOGLE, google);
	}
	void add_game_center(flatbuffers::Offset<flatbuffers::String> game_center) {
		fbb_.AddOffset(Anonymous4::VT_GAME_CENTER, game_center);
	}
	void add_steam(flatbuffers::Offset<flatbuffers::String> steam) {
		fbb_.AddOffset(Anonymous4::VT_STEAM, steam);
	}
	void add_device(flatbuffers::Offset<flatbuffers::String> device) {
		fbb_.AddOffset(Anonymous4::VT_DEVICE, device);
	}
	void add_custom(flatbuffers::Offset<flatbuffers::String> custom) {
		fbb_.AddOffset(Anonymous4::VT_CUSTOM, custom);
	}
	explicit Anonymous4Builder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<Anonymous4> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Anonymous4>(end);
		return o;
	}
};

inline flatbuffers::Offset<Anonymous4> CreateAnonymous4(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> email = 0,
		flatbuffers::Offset<flatbuffers::String> facebook = 0,
		flatbuffers::Offset<flatbuffers::String> google = 0,
		flatbuffers::Offset<flatbuffers::String> game_center = 0,
		flatbuffers::Offset<flatbuffers::String> steam = 0,
		flatbuffers::Offset<flatbuffers::String> device = 0,
		flatbuffers::Offset<flatbuffers::String> custom = 0) {
	Anonymous4Builder builder_(_fbb);
	builder_.add_custom(custom);
	builder_.add_device(device);
	builder_.add_steam(steam);
	builder_.add_game_center(game_center);
	builder_.add_google(google);
	builder_.add_facebook(facebook);
	builder_.add_email(email);
	return builder_.Finish();
}

inline flatbuffers::Offset<Anonymous4> CreateAnonymous4Direct(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *email = nullptr,
		const char *facebook = nullptr,
		const char *google = nullptr,
		const char *game_center = nullptr,
		const char *steam = nullptr,
		const char *device = nullptr,
		const char *custom = nullptr) {
	auto email__ = email ? _fbb.CreateString(email) : 0;
	auto facebook__ = facebook ? _fbb.CreateString(facebook) : 0;
	auto google__ = google ? _fbb.CreateString(google) : 0;
	auto game_center__ = game_center ? _fbb.CreateString(game_center) : 0;
	auto steam__ = steam ? _fbb.CreateString(steam) : 0;
	auto device__ = device ? _fbb.CreateString(device) : 0;
	auto custom__ = custom ? _fbb.CreateString(custom) : 0;
	return server::TUnlink_::CreateAnonymous4(
			_fbb,
			email__,
			facebook__,
			google__,
			game_center__,
			steam__,
			device__,
			custom__);
}

flatbuffers::Offset<Anonymous4> CreateAnonymous4(flatbuffers::FlatBufferBuilder &_fbb, const Anonymous4T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

} // namespace TUnlink_

struct UserT : public flatbuffers::NativeTable {
	typedef User TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.UserT";
	}
	CharString id;
	CharString handle;
	CharString fullname;
	CharString avatar_url;
	CharString lang;
	CharString location;
	CharString timezone;
	CharString metadata;
	int64_t created_at;
	int64_t updated_at;
	int64_t last_online_at;
	UserT() :
			created_at(0),
			updated_at(0),
			last_online_at(0) {
	}
};

struct User FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef UserT NativeTableType;
	typedef UserBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.User";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_ID = 4,
		VT_HANDLE = 6,
		VT_FULLNAME = 8,
		VT_AVATAR_URL = 10,
		VT_LANG = 12,
		VT_LOCATION = 14,
		VT_TIMEZONE = 16,
		VT_METADATA = 18,
		VT_CREATED_AT = 20,
		VT_UPDATED_AT = 22,
		VT_LAST_ONLINE_AT = 24
	};
	/// User ID.
	const flatbuffers::String *id() const {
		return GetPointer<const flatbuffers::String *>(VT_ID);
	}
	/// User Handle (username).
	const flatbuffers::String *handle() const {
		return GetPointer<const flatbuffers::String *>(VT_HANDLE);
	}
	/// User's fullname.
	const flatbuffers::String *fullname() const {
		return GetPointer<const flatbuffers::String *>(VT_FULLNAME);
	}
	/// Link to avatar.
	const flatbuffers::String *avatar_url() const {
		return GetPointer<const flatbuffers::String *>(VT_AVATAR_URL);
	}
	/// Language tag corresponding to the BCP 47 spec.
	const flatbuffers::String *lang() const {
		return GetPointer<const flatbuffers::String *>(VT_LANG);
	}
	/// User's location.
	const flatbuffers::String *location() const {
		return GetPointer<const flatbuffers::String *>(VT_LOCATION);
	}
	/// User's timezone.
	const flatbuffers::String *timezone() const {
		return GetPointer<const flatbuffers::String *>(VT_TIMEZONE);
	}
	/// Custom user metadata.
	const flatbuffers::String *metadata() const {
		return GetPointer<const flatbuffers::String *>(VT_METADATA);
	}
	/// Unix timestamp when this user registered.
	int64_t created_at() const {
		return GetField<int64_t>(VT_CREATED_AT, 0);
	}
	/// Unix timestamp when user profile was last changed.
	int64_t updated_at() const {
		return GetField<int64_t>(VT_UPDATED_AT, 0);
	}
	/// Unix timestamp when user was last connected.
	int64_t last_online_at() const {
		return GetField<int64_t>(VT_LAST_ONLINE_AT, 0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_ID) &&
				verifier.VerifyString(id()) &&
				VerifyOffset(verifier, VT_HANDLE) &&
				verifier.VerifyString(handle()) &&
				VerifyOffset(verifier, VT_FULLNAME) &&
				verifier.VerifyString(fullname()) &&
				VerifyOffset(verifier, VT_AVATAR_URL) &&
				verifier.VerifyString(avatar_url()) &&
				VerifyOffset(verifier, VT_LANG) &&
				verifier.VerifyString(lang()) &&
				VerifyOffset(verifier, VT_LOCATION) &&
				verifier.VerifyString(location()) &&
				VerifyOffset(verifier, VT_TIMEZONE) &&
				verifier.VerifyString(timezone()) &&
				VerifyOffset(verifier, VT_METADATA) &&
				verifier.VerifyString(metadata()) &&
				VerifyField<int64_t>(verifier, VT_CREATED_AT) &&
				VerifyField<int64_t>(verifier, VT_UPDATED_AT) &&
				VerifyField<int64_t>(verifier, VT_LAST_ONLINE_AT) &&
				verifier.EndTable();
	}
	UserT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(UserT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<User> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UserT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct UserBuilder {
	typedef User Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_id(flatbuffers::Offset<flatbuffers::String> id) {
		fbb_.AddOffset(User::VT_ID, id);
	}
	void add_handle(flatbuffers::Offset<flatbuffers::String> handle) {
		fbb_.AddOffset(User::VT_HANDLE, handle);
	}
	void add_fullname(flatbuffers::Offset<flatbuffers::String> fullname) {
		fbb_.AddOffset(User::VT_FULLNAME, fullname);
	}
	void add_avatar_url(flatbuffers::Offset<flatbuffers::String> avatar_url) {
		fbb_.AddOffset(User::VT_AVATAR_URL, avatar_url);
	}
	void add_lang(flatbuffers::Offset<flatbuffers::String> lang) {
		fbb_.AddOffset(User::VT_LANG, lang);
	}
	void add_location(flatbuffers::Offset<flatbuffers::String> location) {
		fbb_.AddOffset(User::VT_LOCATION, location);
	}
	void add_timezone(flatbuffers::Offset<flatbuffers::String> timezone) {
		fbb_.AddOffset(User::VT_TIMEZONE, timezone);
	}
	void add_metadata(flatbuffers::Offset<flatbuffers::String> metadata) {
		fbb_.AddOffset(User::VT_METADATA, metadata);
	}
	void add_created_at(int64_t created_at) {
		fbb_.AddElement<int64_t>(User::VT_CREATED_AT, created_at, 0);
	}
	void add_updated_at(int64_t updated_at) {
		fbb_.AddElement<int64_t>(User::VT_UPDATED_AT, updated_at, 0);
	}
	void add_last_online_at(int64_t last_online_at) {
		fbb_.AddElement<int64_t>(User::VT_LAST_ONLINE_AT, last_online_at, 0);
	}
	explicit UserBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<User> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<User>(end);
		return o;
	}
};

inline flatbuffers::Offset<User> CreateUser(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> id = 0,
		flatbuffers::Offset<flatbuffers::String> handle = 0,
		flatbuffers::Offset<flatbuffers::String> fullname = 0,
		flatbuffers::Offset<flatbuffers::String> avatar_url = 0,
		flatbuffers::Offset<flatbuffers::String> lang = 0,
		flatbuffers::Offset<flatbuffers::String> location = 0,
		flatbuffers::Offset<flatbuffers::String> timezone = 0,
		flatbuffers::Offset<flatbuffers::String> metadata = 0,
		int64_t created_at = 0,
		int64_t updated_at = 0,
		int64_t last_online_at = 0) {
	UserBuilder builder_(_fbb);
	builder_.add_last_online_at(last_online_at);
	builder_.add_updated_at(updated_at);
	builder_.add_created_at(created_at);
	builder_.add_metadata(metadata);
	builder_.add_timezone(timezone);
	builder_.add_location(location);
	builder_.add_lang(lang);
	builder_.add_avatar_url(avatar_url);
	builder_.add_fullname(fullname);
	builder_.add_handle(handle);
	builder_.add_id(id);
	return builder_.Finish();
}

inline flatbuffers::Offset<User> CreateUserDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *id = nullptr,
		const char *handle = nullptr,
		const char *fullname = nullptr,
		const char *avatar_url = nullptr,
		const char *lang = nullptr,
		const char *location = nullptr,
		const char *timezone = nullptr,
		const char *metadata = nullptr,
		int64_t created_at = 0,
		int64_t updated_at = 0,
		int64_t last_online_at = 0) {
	auto id__ = id ? _fbb.CreateString(id) : 0;
	auto handle__ = handle ? _fbb.CreateString(handle) : 0;
	auto fullname__ = fullname ? _fbb.CreateString(fullname) : 0;
	auto avatar_url__ = avatar_url ? _fbb.CreateString(avatar_url) : 0;
	auto lang__ = lang ? _fbb.CreateString(lang) : 0;
	auto location__ = location ? _fbb.CreateString(location) : 0;
	auto timezone__ = timezone ? _fbb.CreateString(timezone) : 0;
	auto metadata__ = metadata ? _fbb.CreateString(metadata) : 0;
	return server::CreateUser(
			_fbb,
			id__,
			handle__,
			fullname__,
			avatar_url__,
			lang__,
			location__,
			timezone__,
			metadata__,
			created_at,
			updated_at,
			last_online_at);
}

flatbuffers::Offset<User> CreateUser(flatbuffers::FlatBufferBuilder &_fbb, const UserT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SelfT : public flatbuffers::NativeTable {
	typedef Self TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.SelfT";
	}
	std::unique_ptr<server::UserT> user;
	bool verified;
	CharString email;
	std::vector<CharString> device_ids;
	CharString facebook_id;
	CharString google_id;
	CharString gamecenter_id;
	CharString steam_id;
	CharString custom_id;
	SelfT() :
			verified(false) {
	}
};

struct Self FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef SelfT NativeTableType;
	typedef SelfBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.Self";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_USER = 4,
		VT_VERIFIED = 6,
		VT_EMAIL = 8,
		VT_DEVICE_IDS = 10,
		VT_FACEBOOK_ID = 12,
		VT_GOOGLE_ID = 14,
		VT_GAMECENTER_ID = 16,
		VT_STEAM_ID = 18,
		VT_CUSTOM_ID = 20
	};
	/// User's account.
	const server::User *user() const {
		return GetPointer<const server::User *>(VT_USER);
	}
	/// Whether the user was verified, either via email or social accounts.
	bool verified() const {
		return GetField<uint8_t>(VT_VERIFIED, 0) != 0;
	}
	/// User's email address.
	const flatbuffers::String *email() const {
		return GetPointer<const flatbuffers::String *>(VT_EMAIL);
	}
	/// List of device IDs the user has.
	const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *device_ids() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_DEVICE_IDS);
	}
	/// User's Facebook ID.
	const flatbuffers::String *facebook_id() const {
		return GetPointer<const flatbuffers::String *>(VT_FACEBOOK_ID);
	}
	/// User's Google ID.
	const flatbuffers::String *google_id() const {
		return GetPointer<const flatbuffers::String *>(VT_GOOGLE_ID);
	}
	/// User's Game Center ID.
	const flatbuffers::String *gamecenter_id() const {
		return GetPointer<const flatbuffers::String *>(VT_GAMECENTER_ID);
	}
	/// User's Steam ID.
	const flatbuffers::String *steam_id() const {
		return GetPointer<const flatbuffers::String *>(VT_STEAM_ID);
	}
	/// Custom ID associated with the user.
	const flatbuffers::String *custom_id() const {
		return GetPointer<const flatbuffers::String *>(VT_CUSTOM_ID);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_USER) &&
				verifier.VerifyTable(user()) &&
				VerifyField<uint8_t>(verifier, VT_VERIFIED) &&
				VerifyOffset(verifier, VT_EMAIL) &&
				verifier.VerifyString(email()) &&
				VerifyOffset(verifier, VT_DEVICE_IDS) &&
				verifier.VerifyVector(device_ids()) &&
				verifier.VerifyVectorOfStrings(device_ids()) &&
				VerifyOffset(verifier, VT_FACEBOOK_ID) &&
				verifier.VerifyString(facebook_id()) &&
				VerifyOffset(verifier, VT_GOOGLE_ID) &&
				verifier.VerifyString(google_id()) &&
				VerifyOffset(verifier, VT_GAMECENTER_ID) &&
				verifier.VerifyString(gamecenter_id()) &&
				VerifyOffset(verifier, VT_STEAM_ID) &&
				verifier.VerifyString(steam_id()) &&
				VerifyOffset(verifier, VT_CUSTOM_ID) &&
				verifier.VerifyString(custom_id()) &&
				verifier.EndTable();
	}
	SelfT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(SelfT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<Self> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelfT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct SelfBuilder {
	typedef Self Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_user(flatbuffers::Offset<server::User> user) {
		fbb_.AddOffset(Self::VT_USER, user);
	}
	void add_verified(bool verified) {
		fbb_.AddElement<uint8_t>(Self::VT_VERIFIED, static_cast<uint8_t>(verified), 0);
	}
	void add_email(flatbuffers::Offset<flatbuffers::String> email) {
		fbb_.AddOffset(Self::VT_EMAIL, email);
	}
	void add_device_ids(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> device_ids) {
		fbb_.AddOffset(Self::VT_DEVICE_IDS, device_ids);
	}
	void add_facebook_id(flatbuffers::Offset<flatbuffers::String> facebook_id) {
		fbb_.AddOffset(Self::VT_FACEBOOK_ID, facebook_id);
	}
	void add_google_id(flatbuffers::Offset<flatbuffers::String> google_id) {
		fbb_.AddOffset(Self::VT_GOOGLE_ID, google_id);
	}
	void add_gamecenter_id(flatbuffers::Offset<flatbuffers::String> gamecenter_id) {
		fbb_.AddOffset(Self::VT_GAMECENTER_ID, gamecenter_id);
	}
	void add_steam_id(flatbuffers::Offset<flatbuffers::String> steam_id) {
		fbb_.AddOffset(Self::VT_STEAM_ID, steam_id);
	}
	void add_custom_id(flatbuffers::Offset<flatbuffers::String> custom_id) {
		fbb_.AddOffset(Self::VT_CUSTOM_ID, custom_id);
	}
	explicit SelfBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<Self> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Self>(end);
		return o;
	}
};

inline flatbuffers::Offset<Self> CreateSelf(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<server::User> user = 0,
		bool verified = false,
		flatbuffers::Offset<flatbuffers::String> email = 0,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> device_ids = 0,
		flatbuffers::Offset<flatbuffers::String> facebook_id = 0,
		flatbuffers::Offset<flatbuffers::String> google_id = 0,
		flatbuffers::Offset<flatbuffers::String> gamecenter_id = 0,
		flatbuffers::Offset<flatbuffers::String> steam_id = 0,
		flatbuffers::Offset<flatbuffers::String> custom_id = 0) {
	SelfBuilder builder_(_fbb);
	builder_.add_custom_id(custom_id);
	builder_.add_steam_id(steam_id);
	builder_.add_gamecenter_id(gamecenter_id);
	builder_.add_google_id(google_id);
	builder_.add_facebook_id(facebook_id);
	builder_.add_device_ids(device_ids);
	builder_.add_email(email);
	builder_.add_user(user);
	builder_.add_verified(verified);
	return builder_.Finish();
}

inline flatbuffers::Offset<Self> CreateSelfDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<server::User> user = 0,
		bool verified = false,
		const char *email = nullptr,
		const std::vector<flatbuffers::Offset<flatbuffers::String>> *device_ids = nullptr,
		const char *facebook_id = nullptr,
		const char *google_id = nullptr,
		const char *gamecenter_id = nullptr,
		const char *steam_id = nullptr,
		const char *custom_id = nullptr) {
	auto email__ = email ? _fbb.CreateString(email) : 0;
	auto device_ids__ = device_ids ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*device_ids) : 0;
	auto facebook_id__ = facebook_id ? _fbb.CreateString(facebook_id) : 0;
	auto google_id__ = google_id ? _fbb.CreateString(google_id) : 0;
	auto gamecenter_id__ = gamecenter_id ? _fbb.CreateString(gamecenter_id) : 0;
	auto steam_id__ = steam_id ? _fbb.CreateString(steam_id) : 0;
	auto custom_id__ = custom_id ? _fbb.CreateString(custom_id) : 0;
	return server::CreateSelf(
			_fbb,
			user,
			verified,
			email__,
			device_ids__,
			facebook_id__,
			google_id__,
			gamecenter_id__,
			steam_id__,
			custom_id__);
}

flatbuffers::Offset<Self> CreateSelf(flatbuffers::FlatBufferBuilder &_fbb, const SelfT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TSelfFetchT : public flatbuffers::NativeTable {
	typedef TSelfFetch TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TSelfFetchT";
	}
	TSelfFetchT() {
	}
};

struct TSelfFetch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TSelfFetchT NativeTableType;
	typedef TSelfFetchBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TSelfFetch";
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				verifier.EndTable();
	}
	TSelfFetchT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TSelfFetchT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TSelfFetch> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TSelfFetchT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TSelfFetchBuilder {
	typedef TSelfFetch Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	explicit TSelfFetchBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TSelfFetch> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TSelfFetch>(end);
		return o;
	}
};

inline flatbuffers::Offset<TSelfFetch> CreateTSelfFetch(
		flatbuffers::FlatBufferBuilder &_fbb) {
	TSelfFetchBuilder builder_(_fbb);
	return builder_.Finish();
}

flatbuffers::Offset<TSelfFetch> CreateTSelfFetch(flatbuffers::FlatBufferBuilder &_fbb, const TSelfFetchT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TSelfT : public flatbuffers::NativeTable {
	typedef TSelf TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TSelfT";
	}
	std::unique_ptr<server::SelfT> self;
	TSelfT() {
	}
};

struct TSelf FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TSelfT NativeTableType;
	typedef TSelfBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TSelf";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_SELF = 4
	};
	const server::Self *self() const {
		return GetPointer<const server::Self *>(VT_SELF);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_SELF) &&
				verifier.VerifyTable(self()) &&
				verifier.EndTable();
	}
	TSelfT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TSelfT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TSelf> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TSelfT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TSelfBuilder {
	typedef TSelf Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_self(flatbuffers::Offset<server::Self> self) {
		fbb_.AddOffset(TSelf::VT_SELF, self);
	}
	explicit TSelfBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TSelf> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TSelf>(end);
		return o;
	}
};

inline flatbuffers::Offset<TSelf> CreateTSelf(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<server::Self> self = 0) {
	TSelfBuilder builder_(_fbb);
	builder_.add_self(self);
	return builder_.Finish();
}

flatbuffers::Offset<TSelf> CreateTSelf(flatbuffers::FlatBufferBuilder &_fbb, const TSelfT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TSelfUpdateT : public flatbuffers::NativeTable {
	typedef TSelfUpdate TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TSelfUpdateT";
	}
	CharString handle;
	CharString fullname;
	CharString timezone;
	CharString location;
	CharString lang;
	CharString metadata;
	CharString avatar_url;
	TSelfUpdateT() {
	}
};

struct TSelfUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TSelfUpdateT NativeTableType;
	typedef TSelfUpdateBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TSelfUpdate";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_HANDLE = 4,
		VT_FULLNAME = 6,
		VT_TIMEZONE = 8,
		VT_LOCATION = 10,
		VT_LANG = 12,
		VT_METADATA = 14,
		VT_AVATAR_URL = 16
	};
	const flatbuffers::String *handle() const {
		return GetPointer<const flatbuffers::String *>(VT_HANDLE);
	}
	const flatbuffers::String *fullname() const {
		return GetPointer<const flatbuffers::String *>(VT_FULLNAME);
	}
	const flatbuffers::String *timezone() const {
		return GetPointer<const flatbuffers::String *>(VT_TIMEZONE);
	}
	const flatbuffers::String *location() const {
		return GetPointer<const flatbuffers::String *>(VT_LOCATION);
	}
	/// Language tag corresponding to the BCP 47 spec
	const flatbuffers::String *lang() const {
		return GetPointer<const flatbuffers::String *>(VT_LANG);
	}
	/// Set or remove User's metadata
	const flatbuffers::String *metadata() const {
		return GetPointer<const flatbuffers::String *>(VT_METADATA);
	}
	const flatbuffers::String *avatar_url() const {
		return GetPointer<const flatbuffers::String *>(VT_AVATAR_URL);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_HANDLE) &&
				verifier.VerifyString(handle()) &&
				VerifyOffset(verifier, VT_FULLNAME) &&
				verifier.VerifyString(fullname()) &&
				VerifyOffset(verifier, VT_TIMEZONE) &&
				verifier.VerifyString(timezone()) &&
				VerifyOffset(verifier, VT_LOCATION) &&
				verifier.VerifyString(location()) &&
				VerifyOffset(verifier, VT_LANG) &&
				verifier.VerifyString(lang()) &&
				VerifyOffset(verifier, VT_METADATA) &&
				verifier.VerifyString(metadata()) &&
				VerifyOffset(verifier, VT_AVATAR_URL) &&
				verifier.VerifyString(avatar_url()) &&
				verifier.EndTable();
	}
	TSelfUpdateT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TSelfUpdateT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TSelfUpdate> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TSelfUpdateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TSelfUpdateBuilder {
	typedef TSelfUpdate Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_handle(flatbuffers::Offset<flatbuffers::String> handle) {
		fbb_.AddOffset(TSelfUpdate::VT_HANDLE, handle);
	}
	void add_fullname(flatbuffers::Offset<flatbuffers::String> fullname) {
		fbb_.AddOffset(TSelfUpdate::VT_FULLNAME, fullname);
	}
	void add_timezone(flatbuffers::Offset<flatbuffers::String> timezone) {
		fbb_.AddOffset(TSelfUpdate::VT_TIMEZONE, timezone);
	}
	void add_location(flatbuffers::Offset<flatbuffers::String> location) {
		fbb_.AddOffset(TSelfUpdate::VT_LOCATION, location);
	}
	void add_lang(flatbuffers::Offset<flatbuffers::String> lang) {
		fbb_.AddOffset(TSelfUpdate::VT_LANG, lang);
	}
	void add_metadata(flatbuffers::Offset<flatbuffers::String> metadata) {
		fbb_.AddOffset(TSelfUpdate::VT_METADATA, metadata);
	}
	void add_avatar_url(flatbuffers::Offset<flatbuffers::String> avatar_url) {
		fbb_.AddOffset(TSelfUpdate::VT_AVATAR_URL, avatar_url);
	}
	explicit TSelfUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TSelfUpdate> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TSelfUpdate>(end);
		return o;
	}
};

inline flatbuffers::Offset<TSelfUpdate> CreateTSelfUpdate(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> handle = 0,
		flatbuffers::Offset<flatbuffers::String> fullname = 0,
		flatbuffers::Offset<flatbuffers::String> timezone = 0,
		flatbuffers::Offset<flatbuffers::String> location = 0,
		flatbuffers::Offset<flatbuffers::String> lang = 0,
		flatbuffers::Offset<flatbuffers::String> metadata = 0,
		flatbuffers::Offset<flatbuffers::String> avatar_url = 0) {
	TSelfUpdateBuilder builder_(_fbb);
	builder_.add_avatar_url(avatar_url);
	builder_.add_metadata(metadata);
	builder_.add_lang(lang);
	builder_.add_location(location);
	builder_.add_timezone(timezone);
	builder_.add_fullname(fullname);
	builder_.add_handle(handle);
	return builder_.Finish();
}

inline flatbuffers::Offset<TSelfUpdate> CreateTSelfUpdateDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *handle = nullptr,
		const char *fullname = nullptr,
		const char *timezone = nullptr,
		const char *location = nullptr,
		const char *lang = nullptr,
		const char *metadata = nullptr,
		const char *avatar_url = nullptr) {
	auto handle__ = handle ? _fbb.CreateString(handle) : 0;
	auto fullname__ = fullname ? _fbb.CreateString(fullname) : 0;
	auto timezone__ = timezone ? _fbb.CreateString(timezone) : 0;
	auto location__ = location ? _fbb.CreateString(location) : 0;
	auto lang__ = lang ? _fbb.CreateString(lang) : 0;
	auto metadata__ = metadata ? _fbb.CreateString(metadata) : 0;
	auto avatar_url__ = avatar_url ? _fbb.CreateString(avatar_url) : 0;
	return server::CreateTSelfUpdate(
			_fbb,
			handle__,
			fullname__,
			timezone__,
			location__,
			lang__,
			metadata__,
			avatar_url__);
}

flatbuffers::Offset<TSelfUpdate> CreateTSelfUpdate(flatbuffers::FlatBufferBuilder &_fbb, const TSelfUpdateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TUsersFetchT : public flatbuffers::NativeTable {
	typedef TUsersFetch TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TUsersFetchT";
	}
	std::vector<std::unique_ptr<server::TUsersFetch_::UsersFetchT>> users;
	TUsersFetchT() {
	}
};

struct TUsersFetch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TUsersFetchT NativeTableType;
	typedef TUsersFetchBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TUsersFetch";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_USERS = 4
	};
	/// Must at least contain one item.
	const flatbuffers::Vector<flatbuffers::Offset<server::TUsersFetch_::UsersFetch>> *users() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::TUsersFetch_::UsersFetch>> *>(VT_USERS);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_USERS) &&
				verifier.VerifyVector(users()) &&
				verifier.VerifyVectorOfTables(users()) &&
				verifier.EndTable();
	}
	TUsersFetchT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TUsersFetchT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TUsersFetch> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TUsersFetchT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TUsersFetchBuilder {
	typedef TUsersFetch Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_users(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TUsersFetch_::UsersFetch>>> users) {
		fbb_.AddOffset(TUsersFetch::VT_USERS, users);
	}
	explicit TUsersFetchBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TUsersFetch> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TUsersFetch>(end);
		return o;
	}
};

inline flatbuffers::Offset<TUsersFetch> CreateTUsersFetch(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TUsersFetch_::UsersFetch>>> users = 0) {
	TUsersFetchBuilder builder_(_fbb);
	builder_.add_users(users);
	return builder_.Finish();
}

inline flatbuffers::Offset<TUsersFetch> CreateTUsersFetchDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<server::TUsersFetch_::UsersFetch>> *users = nullptr) {
	auto users__ = users ? _fbb.CreateVector<flatbuffers::Offset<server::TUsersFetch_::UsersFetch>>(*users) : 0;
	return server::CreateTUsersFetch(
			_fbb,
			users__);
}

flatbuffers::Offset<TUsersFetch> CreateTUsersFetch(flatbuffers::FlatBufferBuilder &_fbb, const TUsersFetchT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace TUsersFetch_ {

struct UsersFetchT : public flatbuffers::NativeTable {
	typedef UsersFetch TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TUsersFetch_.UsersFetchT";
	}
	std::unique_ptr<server::TUsersFetch_::UsersFetch_::Anonymous5T> id;
	UsersFetchT() {
	}
};

struct UsersFetch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef UsersFetchT NativeTableType;
	typedef UsersFetchBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TUsersFetch_.UsersFetch";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_ID = 4
	};
	const server::TUsersFetch_::UsersFetch_::Anonymous5 *id() const {
		return GetPointer<const server::TUsersFetch_::UsersFetch_::Anonymous5 *>(VT_ID);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_ID) &&
				verifier.VerifyTable(id()) &&
				verifier.EndTable();
	}
	UsersFetchT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(UsersFetchT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<UsersFetch> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UsersFetchT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct UsersFetchBuilder {
	typedef UsersFetch Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_id(flatbuffers::Offset<server::TUsersFetch_::UsersFetch_::Anonymous5> id) {
		fbb_.AddOffset(UsersFetch::VT_ID, id);
	}
	explicit UsersFetchBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<UsersFetch> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<UsersFetch>(end);
		return o;
	}
};

inline flatbuffers::Offset<UsersFetch> CreateUsersFetch(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<server::TUsersFetch_::UsersFetch_::Anonymous5> id = 0) {
	UsersFetchBuilder builder_(_fbb);
	builder_.add_id(id);
	return builder_.Finish();
}

flatbuffers::Offset<UsersFetch> CreateUsersFetch(flatbuffers::FlatBufferBuilder &_fbb, const UsersFetchT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace UsersFetch_ {

struct Anonymous5T : public flatbuffers::NativeTable {
	typedef Anonymous5 TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TUsersFetch_.UsersFetch_.Anonymous5T";
	}
	CharString user_id;
	CharString handle;
	Anonymous5T() {
	}
};

struct Anonymous5 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef Anonymous5T NativeTableType;
	typedef Anonymous5Builder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TUsersFetch_.UsersFetch_.Anonymous5";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_USER_ID = 4,
		VT_HANDLE = 6
	};
	const flatbuffers::String *user_id() const {
		return GetPointer<const flatbuffers::String *>(VT_USER_ID);
	}
	const flatbuffers::String *handle() const {
		return GetPointer<const flatbuffers::String *>(VT_HANDLE);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_USER_ID) &&
				verifier.VerifyString(user_id()) &&
				VerifyOffset(verifier, VT_HANDLE) &&
				verifier.VerifyString(handle()) &&
				verifier.EndTable();
	}
	Anonymous5T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(Anonymous5T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<Anonymous5> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Anonymous5T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct Anonymous5Builder {
	typedef Anonymous5 Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_user_id(flatbuffers::Offset<flatbuffers::String> user_id) {
		fbb_.AddOffset(Anonymous5::VT_USER_ID, user_id);
	}
	void add_handle(flatbuffers::Offset<flatbuffers::String> handle) {
		fbb_.AddOffset(Anonymous5::VT_HANDLE, handle);
	}
	explicit Anonymous5Builder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<Anonymous5> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Anonymous5>(end);
		return o;
	}
};

inline flatbuffers::Offset<Anonymous5> CreateAnonymous5(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> user_id = 0,
		flatbuffers::Offset<flatbuffers::String> handle = 0) {
	Anonymous5Builder builder_(_fbb);
	builder_.add_handle(handle);
	builder_.add_user_id(user_id);
	return builder_.Finish();
}

inline flatbuffers::Offset<Anonymous5> CreateAnonymous5Direct(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *user_id = nullptr,
		const char *handle = nullptr) {
	auto user_id__ = user_id ? _fbb.CreateString(user_id) : 0;
	auto handle__ = handle ? _fbb.CreateString(handle) : 0;
	return server::TUsersFetch_::UsersFetch_::CreateAnonymous5(
			_fbb,
			user_id__,
			handle__);
}

flatbuffers::Offset<Anonymous5> CreateAnonymous5(flatbuffers::FlatBufferBuilder &_fbb, const Anonymous5T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

} // namespace UsersFetch_
} // namespace TUsersFetch_

struct TUsersT : public flatbuffers::NativeTable {
	typedef TUsers TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TUsersT";
	}
	std::vector<std::unique_ptr<server::UserT>> users;
	TUsersT() {
	}
};

struct TUsers FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TUsersT NativeTableType;
	typedef TUsersBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TUsers";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_USERS = 4
	};
	const flatbuffers::Vector<flatbuffers::Offset<server::User>> *users() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::User>> *>(VT_USERS);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_USERS) &&
				verifier.VerifyVector(users()) &&
				verifier.VerifyVectorOfTables(users()) &&
				verifier.EndTable();
	}
	TUsersT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TUsersT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TUsers> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TUsersT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TUsersBuilder {
	typedef TUsers Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_users(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::User>>> users) {
		fbb_.AddOffset(TUsers::VT_USERS, users);
	}
	explicit TUsersBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TUsers> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TUsers>(end);
		return o;
	}
};

inline flatbuffers::Offset<TUsers> CreateTUsers(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::User>>> users = 0) {
	TUsersBuilder builder_(_fbb);
	builder_.add_users(users);
	return builder_.Finish();
}

inline flatbuffers::Offset<TUsers> CreateTUsersDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<server::User>> *users = nullptr) {
	auto users__ = users ? _fbb.CreateVector<flatbuffers::Offset<server::User>>(*users) : 0;
	return server::CreateTUsers(
			_fbb,
			users__);
}

flatbuffers::Offset<TUsers> CreateTUsers(flatbuffers::FlatBufferBuilder &_fbb, const TUsersT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FriendT : public flatbuffers::NativeTable {
	typedef Friend TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.FriendT";
	}
	std::unique_ptr<server::UserT> user;
	int64_t state;
	FriendT() :
			state(0) {
	}
};

struct Friend FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef FriendT NativeTableType;
	typedef FriendBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.Friend";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_USER = 4,
		VT_STATE = 6
	};
	/// The user that is the friend of the currently connected user.
	const server::User *user() const {
		return GetPointer<const server::User *>(VT_USER);
	}
	/// The type of relationship this is. The value can be one of the following:
	/// Friend(0): Mutual friendship.
	/// Invite(1): Current user has sent an invitation.
	/// Invited(2): Current user has received an invitation.
	/// Blocked(3): Current user has blocked this friend.
	int64_t state() const {
		return GetField<int64_t>(VT_STATE, 0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_USER) &&
				verifier.VerifyTable(user()) &&
				VerifyField<int64_t>(verifier, VT_STATE) &&
				verifier.EndTable();
	}
	FriendT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(FriendT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<Friend> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FriendT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct FriendBuilder {
	typedef Friend Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_user(flatbuffers::Offset<server::User> user) {
		fbb_.AddOffset(Friend::VT_USER, user);
	}
	void add_state(int64_t state) {
		fbb_.AddElement<int64_t>(Friend::VT_STATE, state, 0);
	}
	explicit FriendBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<Friend> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Friend>(end);
		return o;
	}
};

inline flatbuffers::Offset<Friend> CreateFriend(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<server::User> user = 0,
		int64_t state = 0) {
	FriendBuilder builder_(_fbb);
	builder_.add_state(state);
	builder_.add_user(user);
	return builder_.Finish();
}

flatbuffers::Offset<Friend> CreateFriend(flatbuffers::FlatBufferBuilder &_fbb, const FriendT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TFriendsAddT : public flatbuffers::NativeTable {
	typedef TFriendsAdd TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TFriendsAddT";
	}
	std::vector<std::unique_ptr<server::TFriendsAdd_::FriendsAddT>> friends;
	TFriendsAddT() {
	}
};

struct TFriendsAdd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TFriendsAddT NativeTableType;
	typedef TFriendsAddBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TFriendsAdd";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_FRIENDS = 4
	};
	const flatbuffers::Vector<flatbuffers::Offset<server::TFriendsAdd_::FriendsAdd>> *friends() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::TFriendsAdd_::FriendsAdd>> *>(VT_FRIENDS);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_FRIENDS) &&
				verifier.VerifyVector(friends()) &&
				verifier.VerifyVectorOfTables(friends()) &&
				verifier.EndTable();
	}
	TFriendsAddT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TFriendsAddT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TFriendsAdd> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TFriendsAddT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TFriendsAddBuilder {
	typedef TFriendsAdd Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_friends(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TFriendsAdd_::FriendsAdd>>> friends) {
		fbb_.AddOffset(TFriendsAdd::VT_FRIENDS, friends);
	}
	explicit TFriendsAddBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TFriendsAdd> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TFriendsAdd>(end);
		return o;
	}
};

inline flatbuffers::Offset<TFriendsAdd> CreateTFriendsAdd(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TFriendsAdd_::FriendsAdd>>> friends = 0) {
	TFriendsAddBuilder builder_(_fbb);
	builder_.add_friends(friends);
	return builder_.Finish();
}

inline flatbuffers::Offset<TFriendsAdd> CreateTFriendsAddDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<server::TFriendsAdd_::FriendsAdd>> *friends = nullptr) {
	auto friends__ = friends ? _fbb.CreateVector<flatbuffers::Offset<server::TFriendsAdd_::FriendsAdd>>(*friends) : 0;
	return server::CreateTFriendsAdd(
			_fbb,
			friends__);
}

flatbuffers::Offset<TFriendsAdd> CreateTFriendsAdd(flatbuffers::FlatBufferBuilder &_fbb, const TFriendsAddT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace TFriendsAdd_ {

struct FriendsAddT : public flatbuffers::NativeTable {
	typedef FriendsAdd TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TFriendsAdd_.FriendsAddT";
	}
	std::unique_ptr<server::TFriendsAdd_::FriendsAdd_::Anonymous6T> id;
	FriendsAddT() {
	}
};

struct FriendsAdd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef FriendsAddT NativeTableType;
	typedef FriendsAddBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TFriendsAdd_.FriendsAdd";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_ID = 4
	};
	const server::TFriendsAdd_::FriendsAdd_::Anonymous6 *id() const {
		return GetPointer<const server::TFriendsAdd_::FriendsAdd_::Anonymous6 *>(VT_ID);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_ID) &&
				verifier.VerifyTable(id()) &&
				verifier.EndTable();
	}
	FriendsAddT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(FriendsAddT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<FriendsAdd> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FriendsAddT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct FriendsAddBuilder {
	typedef FriendsAdd Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_id(flatbuffers::Offset<server::TFriendsAdd_::FriendsAdd_::Anonymous6> id) {
		fbb_.AddOffset(FriendsAdd::VT_ID, id);
	}
	explicit FriendsAddBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<FriendsAdd> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<FriendsAdd>(end);
		return o;
	}
};

inline flatbuffers::Offset<FriendsAdd> CreateFriendsAdd(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<server::TFriendsAdd_::FriendsAdd_::Anonymous6> id = 0) {
	FriendsAddBuilder builder_(_fbb);
	builder_.add_id(id);
	return builder_.Finish();
}

flatbuffers::Offset<FriendsAdd> CreateFriendsAdd(flatbuffers::FlatBufferBuilder &_fbb, const FriendsAddT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace FriendsAdd_ {

struct Anonymous6T : public flatbuffers::NativeTable {
	typedef Anonymous6 TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TFriendsAdd_.FriendsAdd_.Anonymous6T";
	}
	CharString user_id;
	CharString handle;
	Anonymous6T() {
	}
};

struct Anonymous6 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef Anonymous6T NativeTableType;
	typedef Anonymous6Builder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TFriendsAdd_.FriendsAdd_.Anonymous6";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_USER_ID = 4,
		VT_HANDLE = 6
	};
	const flatbuffers::String *user_id() const {
		return GetPointer<const flatbuffers::String *>(VT_USER_ID);
	}
	const flatbuffers::String *handle() const {
		return GetPointer<const flatbuffers::String *>(VT_HANDLE);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_USER_ID) &&
				verifier.VerifyString(user_id()) &&
				VerifyOffset(verifier, VT_HANDLE) &&
				verifier.VerifyString(handle()) &&
				verifier.EndTable();
	}
	Anonymous6T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(Anonymous6T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<Anonymous6> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Anonymous6T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct Anonymous6Builder {
	typedef Anonymous6 Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_user_id(flatbuffers::Offset<flatbuffers::String> user_id) {
		fbb_.AddOffset(Anonymous6::VT_USER_ID, user_id);
	}
	void add_handle(flatbuffers::Offset<flatbuffers::String> handle) {
		fbb_.AddOffset(Anonymous6::VT_HANDLE, handle);
	}
	explicit Anonymous6Builder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<Anonymous6> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Anonymous6>(end);
		return o;
	}
};

inline flatbuffers::Offset<Anonymous6> CreateAnonymous6(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> user_id = 0,
		flatbuffers::Offset<flatbuffers::String> handle = 0) {
	Anonymous6Builder builder_(_fbb);
	builder_.add_handle(handle);
	builder_.add_user_id(user_id);
	return builder_.Finish();
}

inline flatbuffers::Offset<Anonymous6> CreateAnonymous6Direct(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *user_id = nullptr,
		const char *handle = nullptr) {
	auto user_id__ = user_id ? _fbb.CreateString(user_id) : 0;
	auto handle__ = handle ? _fbb.CreateString(handle) : 0;
	return server::TFriendsAdd_::FriendsAdd_::CreateAnonymous6(
			_fbb,
			user_id__,
			handle__);
}

flatbuffers::Offset<Anonymous6> CreateAnonymous6(flatbuffers::FlatBufferBuilder &_fbb, const Anonymous6T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

} // namespace FriendsAdd_
} // namespace TFriendsAdd_

struct TFriendsRemoveT : public flatbuffers::NativeTable {
	typedef TFriendsRemove TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TFriendsRemoveT";
	}
	std::vector<CharString> user_ids;
	TFriendsRemoveT() {
	}
};

struct TFriendsRemove FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TFriendsRemoveT NativeTableType;
	typedef TFriendsRemoveBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TFriendsRemove";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_USER_IDS = 4
	};
	const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *user_ids() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_USER_IDS);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_USER_IDS) &&
				verifier.VerifyVector(user_ids()) &&
				verifier.VerifyVectorOfStrings(user_ids()) &&
				verifier.EndTable();
	}
	TFriendsRemoveT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TFriendsRemoveT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TFriendsRemove> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TFriendsRemoveT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TFriendsRemoveBuilder {
	typedef TFriendsRemove Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_user_ids(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> user_ids) {
		fbb_.AddOffset(TFriendsRemove::VT_USER_IDS, user_ids);
	}
	explicit TFriendsRemoveBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TFriendsRemove> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TFriendsRemove>(end);
		return o;
	}
};

inline flatbuffers::Offset<TFriendsRemove> CreateTFriendsRemove(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> user_ids = 0) {
	TFriendsRemoveBuilder builder_(_fbb);
	builder_.add_user_ids(user_ids);
	return builder_.Finish();
}

inline flatbuffers::Offset<TFriendsRemove> CreateTFriendsRemoveDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<flatbuffers::String>> *user_ids = nullptr) {
	auto user_ids__ = user_ids ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*user_ids) : 0;
	return server::CreateTFriendsRemove(
			_fbb,
			user_ids__);
}

flatbuffers::Offset<TFriendsRemove> CreateTFriendsRemove(flatbuffers::FlatBufferBuilder &_fbb, const TFriendsRemoveT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TFriendsBlockT : public flatbuffers::NativeTable {
	typedef TFriendsBlock TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TFriendsBlockT";
	}
	std::vector<CharString> user_ids;
	TFriendsBlockT() {
	}
};

struct TFriendsBlock FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TFriendsBlockT NativeTableType;
	typedef TFriendsBlockBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TFriendsBlock";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_USER_IDS = 4
	};
	const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *user_ids() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_USER_IDS);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_USER_IDS) &&
				verifier.VerifyVector(user_ids()) &&
				verifier.VerifyVectorOfStrings(user_ids()) &&
				verifier.EndTable();
	}
	TFriendsBlockT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TFriendsBlockT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TFriendsBlock> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TFriendsBlockT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TFriendsBlockBuilder {
	typedef TFriendsBlock Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_user_ids(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> user_ids) {
		fbb_.AddOffset(TFriendsBlock::VT_USER_IDS, user_ids);
	}
	explicit TFriendsBlockBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TFriendsBlock> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TFriendsBlock>(end);
		return o;
	}
};

inline flatbuffers::Offset<TFriendsBlock> CreateTFriendsBlock(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> user_ids = 0) {
	TFriendsBlockBuilder builder_(_fbb);
	builder_.add_user_ids(user_ids);
	return builder_.Finish();
}

inline flatbuffers::Offset<TFriendsBlock> CreateTFriendsBlockDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<flatbuffers::String>> *user_ids = nullptr) {
	auto user_ids__ = user_ids ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*user_ids) : 0;
	return server::CreateTFriendsBlock(
			_fbb,
			user_ids__);
}

flatbuffers::Offset<TFriendsBlock> CreateTFriendsBlock(flatbuffers::FlatBufferBuilder &_fbb, const TFriendsBlockT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TFriendsListT : public flatbuffers::NativeTable {
	typedef TFriendsList TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TFriendsListT";
	}
	TFriendsListT() {
	}
};

struct TFriendsList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TFriendsListT NativeTableType;
	typedef TFriendsListBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TFriendsList";
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				verifier.EndTable();
	}
	TFriendsListT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TFriendsListT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TFriendsList> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TFriendsListT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TFriendsListBuilder {
	typedef TFriendsList Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	explicit TFriendsListBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TFriendsList> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TFriendsList>(end);
		return o;
	}
};

inline flatbuffers::Offset<TFriendsList> CreateTFriendsList(
		flatbuffers::FlatBufferBuilder &_fbb) {
	TFriendsListBuilder builder_(_fbb);
	return builder_.Finish();
}

flatbuffers::Offset<TFriendsList> CreateTFriendsList(flatbuffers::FlatBufferBuilder &_fbb, const TFriendsListT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TFriendsT : public flatbuffers::NativeTable {
	typedef TFriends TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TFriendsT";
	}
	std::vector<std::unique_ptr<server::FriendT>> friends;
	TFriendsT() {
	}
};

struct TFriends FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TFriendsT NativeTableType;
	typedef TFriendsBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TFriends";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_FRIENDS = 4
	};
	const flatbuffers::Vector<flatbuffers::Offset<server::Friend>> *friends() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::Friend>> *>(VT_FRIENDS);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_FRIENDS) &&
				verifier.VerifyVector(friends()) &&
				verifier.VerifyVectorOfTables(friends()) &&
				verifier.EndTable();
	}
	TFriendsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TFriendsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TFriends> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TFriendsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TFriendsBuilder {
	typedef TFriends Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_friends(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::Friend>>> friends) {
		fbb_.AddOffset(TFriends::VT_FRIENDS, friends);
	}
	explicit TFriendsBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TFriends> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TFriends>(end);
		return o;
	}
};

inline flatbuffers::Offset<TFriends> CreateTFriends(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::Friend>>> friends = 0) {
	TFriendsBuilder builder_(_fbb);
	builder_.add_friends(friends);
	return builder_.Finish();
}

inline flatbuffers::Offset<TFriends> CreateTFriendsDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<server::Friend>> *friends = nullptr) {
	auto friends__ = friends ? _fbb.CreateVector<flatbuffers::Offset<server::Friend>>(*friends) : 0;
	return server::CreateTFriends(
			_fbb,
			friends__);
}

flatbuffers::Offset<TFriends> CreateTFriends(flatbuffers::FlatBufferBuilder &_fbb, const TFriendsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GroupT : public flatbuffers::NativeTable {
	typedef Group TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.GroupT";
	}
	CharString id;
	bool private_;
	CharString creator_id;
	CharString name;
	CharString description;
	CharString avatar_url;
	CharString lang;
	int64_t utc_offset_ms;
	CharString metadata;
	int64_t count;
	int64_t created_at;
	int64_t updated_at;
	GroupT() :
			private_(false),
			utc_offset_ms(0),
			count(0),
			created_at(0),
			updated_at(0) {
	}
};

struct Group FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef GroupT NativeTableType;
	typedef GroupBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.Group";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_ID = 4,
		VT_PRIVATE_ = 6,
		VT_CREATOR_ID = 8,
		VT_NAME = 10,
		VT_DESCRIPTION = 12,
		VT_AVATAR_URL = 14,
		VT_LANG = 16,
		VT_UTC_OFFSET_MS = 18,
		VT_METADATA = 20,
		VT_COUNT = 22,
		VT_CREATED_AT = 24,
		VT_UPDATED_AT = 26
	};
	/// Group ID
	const flatbuffers::String *id() const {
		return GetPointer<const flatbuffers::String *>(VT_ID);
	}
	/// Whether the group is private or public. If private, group admins will accept user join requests.
	bool private_() const {
		return GetField<uint8_t>(VT_PRIVATE_, 0) != 0;
	}
	/// User ID of the group creator.
	const flatbuffers::String *creator_id() const {
		return GetPointer<const flatbuffers::String *>(VT_CREATOR_ID);
	}
	const flatbuffers::String *name() const {
		return GetPointer<const flatbuffers::String *>(VT_NAME);
	}
	const flatbuffers::String *description() const {
		return GetPointer<const flatbuffers::String *>(VT_DESCRIPTION);
	}
	const flatbuffers::String *avatar_url() const {
		return GetPointer<const flatbuffers::String *>(VT_AVATAR_URL);
	}
	/// Language tag corresponding to the BCP 47 spec. This is important and used for Group search.
	const flatbuffers::String *lang() const {
		return GetPointer<const flatbuffers::String *>(VT_LANG);
	}
	/// Offset time in millisecond from UTC.
	int64_t utc_offset_ms() const {
		return GetField<int64_t>(VT_UTC_OFFSET_MS, 0);
	}
	/// Group metadata information.
	const flatbuffers::String *metadata() const {
		return GetPointer<const flatbuffers::String *>(VT_METADATA);
	}
	/// Current number of users in this group.
	int64_t count() const {
		return GetField<int64_t>(VT_COUNT, 0);
	}
	int64_t created_at() const {
		return GetField<int64_t>(VT_CREATED_AT, 0);
	}
	int64_t updated_at() const {
		return GetField<int64_t>(VT_UPDATED_AT, 0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_ID) &&
				verifier.VerifyString(id()) &&
				VerifyField<uint8_t>(verifier, VT_PRIVATE_) &&
				VerifyOffset(verifier, VT_CREATOR_ID) &&
				verifier.VerifyString(creator_id()) &&
				VerifyOffset(verifier, VT_NAME) &&
				verifier.VerifyString(name()) &&
				VerifyOffset(verifier, VT_DESCRIPTION) &&
				verifier.VerifyString(description()) &&
				VerifyOffset(verifier, VT_AVATAR_URL) &&
				verifier.VerifyString(avatar_url()) &&
				VerifyOffset(verifier, VT_LANG) &&
				verifier.VerifyString(lang()) &&
				VerifyField<int64_t>(verifier, VT_UTC_OFFSET_MS) &&
				VerifyOffset(verifier, VT_METADATA) &&
				verifier.VerifyString(metadata()) &&
				VerifyField<int64_t>(verifier, VT_COUNT) &&
				VerifyField<int64_t>(verifier, VT_CREATED_AT) &&
				VerifyField<int64_t>(verifier, VT_UPDATED_AT) &&
				verifier.EndTable();
	}
	GroupT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(GroupT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<Group> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GroupT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct GroupBuilder {
	typedef Group Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_id(flatbuffers::Offset<flatbuffers::String> id) {
		fbb_.AddOffset(Group::VT_ID, id);
	}
	void add_private_(bool private_) {
		fbb_.AddElement<uint8_t>(Group::VT_PRIVATE_, static_cast<uint8_t>(private_), 0);
	}
	void add_creator_id(flatbuffers::Offset<flatbuffers::String> creator_id) {
		fbb_.AddOffset(Group::VT_CREATOR_ID, creator_id);
	}
	void add_name(flatbuffers::Offset<flatbuffers::String> name) {
		fbb_.AddOffset(Group::VT_NAME, name);
	}
	void add_description(flatbuffers::Offset<flatbuffers::String> description) {
		fbb_.AddOffset(Group::VT_DESCRIPTION, description);
	}
	void add_avatar_url(flatbuffers::Offset<flatbuffers::String> avatar_url) {
		fbb_.AddOffset(Group::VT_AVATAR_URL, avatar_url);
	}
	void add_lang(flatbuffers::Offset<flatbuffers::String> lang) {
		fbb_.AddOffset(Group::VT_LANG, lang);
	}
	void add_utc_offset_ms(int64_t utc_offset_ms) {
		fbb_.AddElement<int64_t>(Group::VT_UTC_OFFSET_MS, utc_offset_ms, 0);
	}
	void add_metadata(flatbuffers::Offset<flatbuffers::String> metadata) {
		fbb_.AddOffset(Group::VT_METADATA, metadata);
	}
	void add_count(int64_t count) {
		fbb_.AddElement<int64_t>(Group::VT_COUNT, count, 0);
	}
	void add_created_at(int64_t created_at) {
		fbb_.AddElement<int64_t>(Group::VT_CREATED_AT, created_at, 0);
	}
	void add_updated_at(int64_t updated_at) {
		fbb_.AddElement<int64_t>(Group::VT_UPDATED_AT, updated_at, 0);
	}
	explicit GroupBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<Group> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Group>(end);
		return o;
	}
};

inline flatbuffers::Offset<Group> CreateGroup(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> id = 0,
		bool private_ = false,
		flatbuffers::Offset<flatbuffers::String> creator_id = 0,
		flatbuffers::Offset<flatbuffers::String> name = 0,
		flatbuffers::Offset<flatbuffers::String> description = 0,
		flatbuffers::Offset<flatbuffers::String> avatar_url = 0,
		flatbuffers::Offset<flatbuffers::String> lang = 0,
		int64_t utc_offset_ms = 0,
		flatbuffers::Offset<flatbuffers::String> metadata = 0,
		int64_t count = 0,
		int64_t created_at = 0,
		int64_t updated_at = 0) {
	GroupBuilder builder_(_fbb);
	builder_.add_updated_at(updated_at);
	builder_.add_created_at(created_at);
	builder_.add_count(count);
	builder_.add_utc_offset_ms(utc_offset_ms);
	builder_.add_metadata(metadata);
	builder_.add_lang(lang);
	builder_.add_avatar_url(avatar_url);
	builder_.add_description(description);
	builder_.add_name(name);
	builder_.add_creator_id(creator_id);
	builder_.add_id(id);
	builder_.add_private_(private_);
	return builder_.Finish();
}

inline flatbuffers::Offset<Group> CreateGroupDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *id = nullptr,
		bool private_ = false,
		const char *creator_id = nullptr,
		const char *name = nullptr,
		const char *description = nullptr,
		const char *avatar_url = nullptr,
		const char *lang = nullptr,
		int64_t utc_offset_ms = 0,
		const char *metadata = nullptr,
		int64_t count = 0,
		int64_t created_at = 0,
		int64_t updated_at = 0) {
	auto id__ = id ? _fbb.CreateString(id) : 0;
	auto creator_id__ = creator_id ? _fbb.CreateString(creator_id) : 0;
	auto name__ = name ? _fbb.CreateString(name) : 0;
	auto description__ = description ? _fbb.CreateString(description) : 0;
	auto avatar_url__ = avatar_url ? _fbb.CreateString(avatar_url) : 0;
	auto lang__ = lang ? _fbb.CreateString(lang) : 0;
	auto metadata__ = metadata ? _fbb.CreateString(metadata) : 0;
	return server::CreateGroup(
			_fbb,
			id__,
			private_,
			creator_id__,
			name__,
			description__,
			avatar_url__,
			lang__,
			utc_offset_ms,
			metadata__,
			count,
			created_at,
			updated_at);
}

flatbuffers::Offset<Group> CreateGroup(flatbuffers::FlatBufferBuilder &_fbb, const GroupT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TGroupsCreateT : public flatbuffers::NativeTable {
	typedef TGroupsCreate TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupsCreateT";
	}
	std::vector<std::unique_ptr<server::TGroupsCreate_::GroupCreateT>> groups;
	TGroupsCreateT() {
	}
};

struct TGroupsCreate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TGroupsCreateT NativeTableType;
	typedef TGroupsCreateBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupsCreate";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_GROUPS = 4
	};
	const flatbuffers::Vector<flatbuffers::Offset<server::TGroupsCreate_::GroupCreate>> *groups() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::TGroupsCreate_::GroupCreate>> *>(VT_GROUPS);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_GROUPS) &&
				verifier.VerifyVector(groups()) &&
				verifier.VerifyVectorOfTables(groups()) &&
				verifier.EndTable();
	}
	TGroupsCreateT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TGroupsCreateT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TGroupsCreate> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TGroupsCreateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TGroupsCreateBuilder {
	typedef TGroupsCreate Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_groups(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TGroupsCreate_::GroupCreate>>> groups) {
		fbb_.AddOffset(TGroupsCreate::VT_GROUPS, groups);
	}
	explicit TGroupsCreateBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TGroupsCreate> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TGroupsCreate>(end);
		return o;
	}
};

inline flatbuffers::Offset<TGroupsCreate> CreateTGroupsCreate(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TGroupsCreate_::GroupCreate>>> groups = 0) {
	TGroupsCreateBuilder builder_(_fbb);
	builder_.add_groups(groups);
	return builder_.Finish();
}

inline flatbuffers::Offset<TGroupsCreate> CreateTGroupsCreateDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<server::TGroupsCreate_::GroupCreate>> *groups = nullptr) {
	auto groups__ = groups ? _fbb.CreateVector<flatbuffers::Offset<server::TGroupsCreate_::GroupCreate>>(*groups) : 0;
	return server::CreateTGroupsCreate(
			_fbb,
			groups__);
}

flatbuffers::Offset<TGroupsCreate> CreateTGroupsCreate(flatbuffers::FlatBufferBuilder &_fbb, const TGroupsCreateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace TGroupsCreate_ {

struct GroupCreateT : public flatbuffers::NativeTable {
	typedef GroupCreate TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupsCreate_.GroupCreateT";
	}
	CharString name;
	CharString description;
	CharString avatar_url;
	CharString lang;
	CharString metadata;
	bool private_;
	GroupCreateT() :
			private_(false) {
	}
};

struct GroupCreate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef GroupCreateT NativeTableType;
	typedef GroupCreateBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupsCreate_.GroupCreate";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_NAME = 4,
		VT_DESCRIPTION = 6,
		VT_AVATAR_URL = 8,
		VT_LANG = 10,
		VT_METADATA = 12,
		VT_PRIVATE_ = 14
	};
	/// Group name must be unique.
	const flatbuffers::String *name() const {
		return GetPointer<const flatbuffers::String *>(VT_NAME);
	}
	const flatbuffers::String *description() const {
		return GetPointer<const flatbuffers::String *>(VT_DESCRIPTION);
	}
	const flatbuffers::String *avatar_url() const {
		return GetPointer<const flatbuffers::String *>(VT_AVATAR_URL);
	}
	/// Language tag corresponding to the BCP 47 spec. This is important and used for Group search.
	const flatbuffers::String *lang() const {
		return GetPointer<const flatbuffers::String *>(VT_LANG);
	}
	/// Group metadata information.
	const flatbuffers::String *metadata() const {
		return GetPointer<const flatbuffers::String *>(VT_METADATA);
	}
	/// Whether the group is private or public. If private, group admins will accept user join requests.
	bool private_() const {
		return GetField<uint8_t>(VT_PRIVATE_, 0) != 0;
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_NAME) &&
				verifier.VerifyString(name()) &&
				VerifyOffset(verifier, VT_DESCRIPTION) &&
				verifier.VerifyString(description()) &&
				VerifyOffset(verifier, VT_AVATAR_URL) &&
				verifier.VerifyString(avatar_url()) &&
				VerifyOffset(verifier, VT_LANG) &&
				verifier.VerifyString(lang()) &&
				VerifyOffset(verifier, VT_METADATA) &&
				verifier.VerifyString(metadata()) &&
				VerifyField<uint8_t>(verifier, VT_PRIVATE_) &&
				verifier.EndTable();
	}
	GroupCreateT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(GroupCreateT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<GroupCreate> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GroupCreateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct GroupCreateBuilder {
	typedef GroupCreate Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_name(flatbuffers::Offset<flatbuffers::String> name) {
		fbb_.AddOffset(GroupCreate::VT_NAME, name);
	}
	void add_description(flatbuffers::Offset<flatbuffers::String> description) {
		fbb_.AddOffset(GroupCreate::VT_DESCRIPTION, description);
	}
	void add_avatar_url(flatbuffers::Offset<flatbuffers::String> avatar_url) {
		fbb_.AddOffset(GroupCreate::VT_AVATAR_URL, avatar_url);
	}
	void add_lang(flatbuffers::Offset<flatbuffers::String> lang) {
		fbb_.AddOffset(GroupCreate::VT_LANG, lang);
	}
	void add_metadata(flatbuffers::Offset<flatbuffers::String> metadata) {
		fbb_.AddOffset(GroupCreate::VT_METADATA, metadata);
	}
	void add_private_(bool private_) {
		fbb_.AddElement<uint8_t>(GroupCreate::VT_PRIVATE_, static_cast<uint8_t>(private_), 0);
	}
	explicit GroupCreateBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<GroupCreate> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<GroupCreate>(end);
		return o;
	}
};

inline flatbuffers::Offset<GroupCreate> CreateGroupCreate(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> name = 0,
		flatbuffers::Offset<flatbuffers::String> description = 0,
		flatbuffers::Offset<flatbuffers::String> avatar_url = 0,
		flatbuffers::Offset<flatbuffers::String> lang = 0,
		flatbuffers::Offset<flatbuffers::String> metadata = 0,
		bool private_ = false) {
	GroupCreateBuilder builder_(_fbb);
	builder_.add_metadata(metadata);
	builder_.add_lang(lang);
	builder_.add_avatar_url(avatar_url);
	builder_.add_description(description);
	builder_.add_name(name);
	builder_.add_private_(private_);
	return builder_.Finish();
}

inline flatbuffers::Offset<GroupCreate> CreateGroupCreateDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *name = nullptr,
		const char *description = nullptr,
		const char *avatar_url = nullptr,
		const char *lang = nullptr,
		const char *metadata = nullptr,
		bool private_ = false) {
	auto name__ = name ? _fbb.CreateString(name) : 0;
	auto description__ = description ? _fbb.CreateString(description) : 0;
	auto avatar_url__ = avatar_url ? _fbb.CreateString(avatar_url) : 0;
	auto lang__ = lang ? _fbb.CreateString(lang) : 0;
	auto metadata__ = metadata ? _fbb.CreateString(metadata) : 0;
	return server::TGroupsCreate_::CreateGroupCreate(
			_fbb,
			name__,
			description__,
			avatar_url__,
			lang__,
			metadata__,
			private_);
}

flatbuffers::Offset<GroupCreate> CreateGroupCreate(flatbuffers::FlatBufferBuilder &_fbb, const GroupCreateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

} // namespace TGroupsCreate_

struct TGroupsUpdateT : public flatbuffers::NativeTable {
	typedef TGroupsUpdate TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupsUpdateT";
	}
	std::vector<std::unique_ptr<server::TGroupsUpdate_::GroupUpdateT>> groups;
	TGroupsUpdateT() {
	}
};

struct TGroupsUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TGroupsUpdateT NativeTableType;
	typedef TGroupsUpdateBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupsUpdate";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_GROUPS = 4
	};
	const flatbuffers::Vector<flatbuffers::Offset<server::TGroupsUpdate_::GroupUpdate>> *groups() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::TGroupsUpdate_::GroupUpdate>> *>(VT_GROUPS);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_GROUPS) &&
				verifier.VerifyVector(groups()) &&
				verifier.VerifyVectorOfTables(groups()) &&
				verifier.EndTable();
	}
	TGroupsUpdateT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TGroupsUpdateT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TGroupsUpdate> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TGroupsUpdateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TGroupsUpdateBuilder {
	typedef TGroupsUpdate Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_groups(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TGroupsUpdate_::GroupUpdate>>> groups) {
		fbb_.AddOffset(TGroupsUpdate::VT_GROUPS, groups);
	}
	explicit TGroupsUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TGroupsUpdate> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TGroupsUpdate>(end);
		return o;
	}
};

inline flatbuffers::Offset<TGroupsUpdate> CreateTGroupsUpdate(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TGroupsUpdate_::GroupUpdate>>> groups = 0) {
	TGroupsUpdateBuilder builder_(_fbb);
	builder_.add_groups(groups);
	return builder_.Finish();
}

inline flatbuffers::Offset<TGroupsUpdate> CreateTGroupsUpdateDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<server::TGroupsUpdate_::GroupUpdate>> *groups = nullptr) {
	auto groups__ = groups ? _fbb.CreateVector<flatbuffers::Offset<server::TGroupsUpdate_::GroupUpdate>>(*groups) : 0;
	return server::CreateTGroupsUpdate(
			_fbb,
			groups__);
}

flatbuffers::Offset<TGroupsUpdate> CreateTGroupsUpdate(flatbuffers::FlatBufferBuilder &_fbb, const TGroupsUpdateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace TGroupsUpdate_ {

struct GroupUpdateT : public flatbuffers::NativeTable {
	typedef GroupUpdate TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupsUpdate_.GroupUpdateT";
	}
	CharString group_id;
	bool private_;
	CharString name;
	CharString description;
	CharString avatar_url;
	CharString lang;
	CharString metadata;
	GroupUpdateT() :
			private_(false) {
	}
};

struct GroupUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef GroupUpdateT NativeTableType;
	typedef GroupUpdateBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupsUpdate_.GroupUpdate";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_GROUP_ID = 4,
		VT_PRIVATE_ = 6,
		VT_NAME = 8,
		VT_DESCRIPTION = 10,
		VT_AVATAR_URL = 12,
		VT_LANG = 14,
		VT_METADATA = 16
	};
	const flatbuffers::String *group_id() const {
		return GetPointer<const flatbuffers::String *>(VT_GROUP_ID);
	}
	/// Whether the group is private or public. If private, group admins will accept user join requests.
	bool private_() const {
		return GetField<uint8_t>(VT_PRIVATE_, 0) != 0;
	}
	/// Group name must be unique.
	const flatbuffers::String *name() const {
		return GetPointer<const flatbuffers::String *>(VT_NAME);
	}
	const flatbuffers::String *description() const {
		return GetPointer<const flatbuffers::String *>(VT_DESCRIPTION);
	}
	const flatbuffers::String *avatar_url() const {
		return GetPointer<const flatbuffers::String *>(VT_AVATAR_URL);
	}
	/// Language tag corresponding to the BCP 47 spec. This is important and used for Group search.
	const flatbuffers::String *lang() const {
		return GetPointer<const flatbuffers::String *>(VT_LANG);
	}
	/// Set or remove metadata information.
	const flatbuffers::String *metadata() const {
		return GetPointer<const flatbuffers::String *>(VT_METADATA);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_GROUP_ID) &&
				verifier.VerifyString(group_id()) &&
				VerifyField<uint8_t>(verifier, VT_PRIVATE_) &&
				VerifyOffset(verifier, VT_NAME) &&
				verifier.VerifyString(name()) &&
				VerifyOffset(verifier, VT_DESCRIPTION) &&
				verifier.VerifyString(description()) &&
				VerifyOffset(verifier, VT_AVATAR_URL) &&
				verifier.VerifyString(avatar_url()) &&
				VerifyOffset(verifier, VT_LANG) &&
				verifier.VerifyString(lang()) &&
				VerifyOffset(verifier, VT_METADATA) &&
				verifier.VerifyString(metadata()) &&
				verifier.EndTable();
	}
	GroupUpdateT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(GroupUpdateT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<GroupUpdate> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GroupUpdateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct GroupUpdateBuilder {
	typedef GroupUpdate Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_group_id(flatbuffers::Offset<flatbuffers::String> group_id) {
		fbb_.AddOffset(GroupUpdate::VT_GROUP_ID, group_id);
	}
	void add_private_(bool private_) {
		fbb_.AddElement<uint8_t>(GroupUpdate::VT_PRIVATE_, static_cast<uint8_t>(private_), 0);
	}
	void add_name(flatbuffers::Offset<flatbuffers::String> name) {
		fbb_.AddOffset(GroupUpdate::VT_NAME, name);
	}
	void add_description(flatbuffers::Offset<flatbuffers::String> description) {
		fbb_.AddOffset(GroupUpdate::VT_DESCRIPTION, description);
	}
	void add_avatar_url(flatbuffers::Offset<flatbuffers::String> avatar_url) {
		fbb_.AddOffset(GroupUpdate::VT_AVATAR_URL, avatar_url);
	}
	void add_lang(flatbuffers::Offset<flatbuffers::String> lang) {
		fbb_.AddOffset(GroupUpdate::VT_LANG, lang);
	}
	void add_metadata(flatbuffers::Offset<flatbuffers::String> metadata) {
		fbb_.AddOffset(GroupUpdate::VT_METADATA, metadata);
	}
	explicit GroupUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<GroupUpdate> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<GroupUpdate>(end);
		return o;
	}
};

inline flatbuffers::Offset<GroupUpdate> CreateGroupUpdate(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> group_id = 0,
		bool private_ = false,
		flatbuffers::Offset<flatbuffers::String> name = 0,
		flatbuffers::Offset<flatbuffers::String> description = 0,
		flatbuffers::Offset<flatbuffers::String> avatar_url = 0,
		flatbuffers::Offset<flatbuffers::String> lang = 0,
		flatbuffers::Offset<flatbuffers::String> metadata = 0) {
	GroupUpdateBuilder builder_(_fbb);
	builder_.add_metadata(metadata);
	builder_.add_lang(lang);
	builder_.add_avatar_url(avatar_url);
	builder_.add_description(description);
	builder_.add_name(name);
	builder_.add_group_id(group_id);
	builder_.add_private_(private_);
	return builder_.Finish();
}

inline flatbuffers::Offset<GroupUpdate> CreateGroupUpdateDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *group_id = nullptr,
		bool private_ = false,
		const char *name = nullptr,
		const char *description = nullptr,
		const char *avatar_url = nullptr,
		const char *lang = nullptr,
		const char *metadata = nullptr) {
	auto group_id__ = group_id ? _fbb.CreateString(group_id) : 0;
	auto name__ = name ? _fbb.CreateString(name) : 0;
	auto description__ = description ? _fbb.CreateString(description) : 0;
	auto avatar_url__ = avatar_url ? _fbb.CreateString(avatar_url) : 0;
	auto lang__ = lang ? _fbb.CreateString(lang) : 0;
	auto metadata__ = metadata ? _fbb.CreateString(metadata) : 0;
	return server::TGroupsUpdate_::CreateGroupUpdate(
			_fbb,
			group_id__,
			private_,
			name__,
			description__,
			avatar_url__,
			lang__,
			metadata__);
}

flatbuffers::Offset<GroupUpdate> CreateGroupUpdate(flatbuffers::FlatBufferBuilder &_fbb, const GroupUpdateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

} // namespace TGroupsUpdate_

struct TGroupsRemoveT : public flatbuffers::NativeTable {
	typedef TGroupsRemove TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupsRemoveT";
	}
	std::vector<CharString> group_ids;
	TGroupsRemoveT() {
	}
};

struct TGroupsRemove FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TGroupsRemoveT NativeTableType;
	typedef TGroupsRemoveBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupsRemove";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_GROUP_IDS = 4
	};
	const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *group_ids() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_GROUP_IDS);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_GROUP_IDS) &&
				verifier.VerifyVector(group_ids()) &&
				verifier.VerifyVectorOfStrings(group_ids()) &&
				verifier.EndTable();
	}
	TGroupsRemoveT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TGroupsRemoveT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TGroupsRemove> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TGroupsRemoveT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TGroupsRemoveBuilder {
	typedef TGroupsRemove Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_group_ids(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> group_ids) {
		fbb_.AddOffset(TGroupsRemove::VT_GROUP_IDS, group_ids);
	}
	explicit TGroupsRemoveBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TGroupsRemove> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TGroupsRemove>(end);
		return o;
	}
};

inline flatbuffers::Offset<TGroupsRemove> CreateTGroupsRemove(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> group_ids = 0) {
	TGroupsRemoveBuilder builder_(_fbb);
	builder_.add_group_ids(group_ids);
	return builder_.Finish();
}

inline flatbuffers::Offset<TGroupsRemove> CreateTGroupsRemoveDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<flatbuffers::String>> *group_ids = nullptr) {
	auto group_ids__ = group_ids ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*group_ids) : 0;
	return server::CreateTGroupsRemove(
			_fbb,
			group_ids__);
}

flatbuffers::Offset<TGroupsRemove> CreateTGroupsRemove(flatbuffers::FlatBufferBuilder &_fbb, const TGroupsRemoveT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TGroupsSelfListT : public flatbuffers::NativeTable {
	typedef TGroupsSelfList TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupsSelfListT";
	}
	TGroupsSelfListT() {
	}
};

struct TGroupsSelfList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TGroupsSelfListT NativeTableType;
	typedef TGroupsSelfListBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupsSelfList";
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				verifier.EndTable();
	}
	TGroupsSelfListT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TGroupsSelfListT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TGroupsSelfList> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TGroupsSelfListT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TGroupsSelfListBuilder {
	typedef TGroupsSelfList Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	explicit TGroupsSelfListBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TGroupsSelfList> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TGroupsSelfList>(end);
		return o;
	}
};

inline flatbuffers::Offset<TGroupsSelfList> CreateTGroupsSelfList(
		flatbuffers::FlatBufferBuilder &_fbb) {
	TGroupsSelfListBuilder builder_(_fbb);
	return builder_.Finish();
}

flatbuffers::Offset<TGroupsSelfList> CreateTGroupsSelfList(flatbuffers::FlatBufferBuilder &_fbb, const TGroupsSelfListT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TGroupsFetchT : public flatbuffers::NativeTable {
	typedef TGroupsFetch TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupsFetchT";
	}
	std::vector<std::unique_ptr<server::TGroupsFetch_::GroupFetchT>> groups;
	TGroupsFetchT() {
	}
};

struct TGroupsFetch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TGroupsFetchT NativeTableType;
	typedef TGroupsFetchBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupsFetch";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_GROUPS = 4
	};
	const flatbuffers::Vector<flatbuffers::Offset<server::TGroupsFetch_::GroupFetch>> *groups() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::TGroupsFetch_::GroupFetch>> *>(VT_GROUPS);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_GROUPS) &&
				verifier.VerifyVector(groups()) &&
				verifier.VerifyVectorOfTables(groups()) &&
				verifier.EndTable();
	}
	TGroupsFetchT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TGroupsFetchT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TGroupsFetch> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TGroupsFetchT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TGroupsFetchBuilder {
	typedef TGroupsFetch Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_groups(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TGroupsFetch_::GroupFetch>>> groups) {
		fbb_.AddOffset(TGroupsFetch::VT_GROUPS, groups);
	}
	explicit TGroupsFetchBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TGroupsFetch> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TGroupsFetch>(end);
		return o;
	}
};

inline flatbuffers::Offset<TGroupsFetch> CreateTGroupsFetch(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TGroupsFetch_::GroupFetch>>> groups = 0) {
	TGroupsFetchBuilder builder_(_fbb);
	builder_.add_groups(groups);
	return builder_.Finish();
}

inline flatbuffers::Offset<TGroupsFetch> CreateTGroupsFetchDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<server::TGroupsFetch_::GroupFetch>> *groups = nullptr) {
	auto groups__ = groups ? _fbb.CreateVector<flatbuffers::Offset<server::TGroupsFetch_::GroupFetch>>(*groups) : 0;
	return server::CreateTGroupsFetch(
			_fbb,
			groups__);
}

flatbuffers::Offset<TGroupsFetch> CreateTGroupsFetch(flatbuffers::FlatBufferBuilder &_fbb, const TGroupsFetchT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace TGroupsFetch_ {

struct GroupFetchT : public flatbuffers::NativeTable {
	typedef GroupFetch TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupsFetch_.GroupFetchT";
	}
	std::unique_ptr<server::TGroupsFetch_::GroupFetch_::Anonymous7T> id;
	GroupFetchT() {
	}
};

struct GroupFetch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef GroupFetchT NativeTableType;
	typedef GroupFetchBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupsFetch_.GroupFetch";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_ID = 4
	};
	const server::TGroupsFetch_::GroupFetch_::Anonymous7 *id() const {
		return GetPointer<const server::TGroupsFetch_::GroupFetch_::Anonymous7 *>(VT_ID);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_ID) &&
				verifier.VerifyTable(id()) &&
				verifier.EndTable();
	}
	GroupFetchT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(GroupFetchT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<GroupFetch> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GroupFetchT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct GroupFetchBuilder {
	typedef GroupFetch Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_id(flatbuffers::Offset<server::TGroupsFetch_::GroupFetch_::Anonymous7> id) {
		fbb_.AddOffset(GroupFetch::VT_ID, id);
	}
	explicit GroupFetchBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<GroupFetch> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<GroupFetch>(end);
		return o;
	}
};

inline flatbuffers::Offset<GroupFetch> CreateGroupFetch(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<server::TGroupsFetch_::GroupFetch_::Anonymous7> id = 0) {
	GroupFetchBuilder builder_(_fbb);
	builder_.add_id(id);
	return builder_.Finish();
}

flatbuffers::Offset<GroupFetch> CreateGroupFetch(flatbuffers::FlatBufferBuilder &_fbb, const GroupFetchT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace GroupFetch_ {

struct Anonymous7T : public flatbuffers::NativeTable {
	typedef Anonymous7 TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupsFetch_.GroupFetch_.Anonymous7T";
	}
	CharString group_id;
	CharString name;
	Anonymous7T() {
	}
};

struct Anonymous7 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef Anonymous7T NativeTableType;
	typedef Anonymous7Builder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupsFetch_.GroupFetch_.Anonymous7";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_GROUP_ID = 4,
		VT_NAME = 6
	};
	const flatbuffers::String *group_id() const {
		return GetPointer<const flatbuffers::String *>(VT_GROUP_ID);
	}
	const flatbuffers::String *name() const {
		return GetPointer<const flatbuffers::String *>(VT_NAME);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_GROUP_ID) &&
				verifier.VerifyString(group_id()) &&
				VerifyOffset(verifier, VT_NAME) &&
				verifier.VerifyString(name()) &&
				verifier.EndTable();
	}
	Anonymous7T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(Anonymous7T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<Anonymous7> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Anonymous7T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct Anonymous7Builder {
	typedef Anonymous7 Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_group_id(flatbuffers::Offset<flatbuffers::String> group_id) {
		fbb_.AddOffset(Anonymous7::VT_GROUP_ID, group_id);
	}
	void add_name(flatbuffers::Offset<flatbuffers::String> name) {
		fbb_.AddOffset(Anonymous7::VT_NAME, name);
	}
	explicit Anonymous7Builder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<Anonymous7> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Anonymous7>(end);
		return o;
	}
};

inline flatbuffers::Offset<Anonymous7> CreateAnonymous7(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> group_id = 0,
		flatbuffers::Offset<flatbuffers::String> name = 0) {
	Anonymous7Builder builder_(_fbb);
	builder_.add_name(name);
	builder_.add_group_id(group_id);
	return builder_.Finish();
}

inline flatbuffers::Offset<Anonymous7> CreateAnonymous7Direct(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *group_id = nullptr,
		const char *name = nullptr) {
	auto group_id__ = group_id ? _fbb.CreateString(group_id) : 0;
	auto name__ = name ? _fbb.CreateString(name) : 0;
	return server::TGroupsFetch_::GroupFetch_::CreateAnonymous7(
			_fbb,
			group_id__,
			name__);
}

flatbuffers::Offset<Anonymous7> CreateAnonymous7(flatbuffers::FlatBufferBuilder &_fbb, const Anonymous7T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

} // namespace GroupFetch_
} // namespace TGroupsFetch_

struct TGroupsListT : public flatbuffers::NativeTable {
	typedef TGroupsList TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupsListT";
	}
	int64_t page_limit;
	bool order_by_asc;
	std::unique_ptr<server::TGroupsList_::Anonymous8T> filter;
	CharString cursor;
	TGroupsListT() :
			page_limit(0),
			order_by_asc(false) {
	}
};

struct TGroupsList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TGroupsListT NativeTableType;
	typedef TGroupsListBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupsList";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_PAGE_LIMIT = 4,
		VT_ORDER_BY_ASC = 6,
		VT_FILTER = 8,
		VT_CURSOR = 10
	};
	/// Upper limit on the maximum number of groups to return per request. Max value is 100.
	int64_t page_limit() const {
		return GetField<int64_t>(VT_PAGE_LIMIT, 0);
	}
	/// Whether to order the result ascending or descending based on the filters defined below.
	bool order_by_asc() const {
		return GetField<uint8_t>(VT_ORDER_BY_ASC, 0) != 0;
	}
	/// Filter used to search for groups.
	const server::TGroupsList_::Anonymous8 *filter() const {
		return GetPointer<const server::TGroupsList_::Anonymous8 *>(VT_FILTER);
	}
	/// Binary cursor value used to paginate results.
	/// The value of this comes from TGroups.cursor.
	const flatbuffers::String *cursor() const {
		return GetPointer<const flatbuffers::String *>(VT_CURSOR);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyField<int64_t>(verifier, VT_PAGE_LIMIT) &&
				VerifyField<uint8_t>(verifier, VT_ORDER_BY_ASC) &&
				VerifyOffset(verifier, VT_FILTER) &&
				verifier.VerifyTable(filter()) &&
				VerifyOffset(verifier, VT_CURSOR) &&
				verifier.VerifyString(cursor()) &&
				verifier.EndTable();
	}
	TGroupsListT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TGroupsListT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TGroupsList> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TGroupsListT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TGroupsListBuilder {
	typedef TGroupsList Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_page_limit(int64_t page_limit) {
		fbb_.AddElement<int64_t>(TGroupsList::VT_PAGE_LIMIT, page_limit, 0);
	}
	void add_order_by_asc(bool order_by_asc) {
		fbb_.AddElement<uint8_t>(TGroupsList::VT_ORDER_BY_ASC, static_cast<uint8_t>(order_by_asc), 0);
	}
	void add_filter(flatbuffers::Offset<server::TGroupsList_::Anonymous8> filter) {
		fbb_.AddOffset(TGroupsList::VT_FILTER, filter);
	}
	void add_cursor(flatbuffers::Offset<flatbuffers::String> cursor) {
		fbb_.AddOffset(TGroupsList::VT_CURSOR, cursor);
	}
	explicit TGroupsListBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TGroupsList> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TGroupsList>(end);
		return o;
	}
};

inline flatbuffers::Offset<TGroupsList> CreateTGroupsList(
		flatbuffers::FlatBufferBuilder &_fbb,
		int64_t page_limit = 0,
		bool order_by_asc = false,
		flatbuffers::Offset<server::TGroupsList_::Anonymous8> filter = 0,
		flatbuffers::Offset<flatbuffers::String> cursor = 0) {
	TGroupsListBuilder builder_(_fbb);
	builder_.add_page_limit(page_limit);
	builder_.add_cursor(cursor);
	builder_.add_filter(filter);
	builder_.add_order_by_asc(order_by_asc);
	return builder_.Finish();
}

inline flatbuffers::Offset<TGroupsList> CreateTGroupsListDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		int64_t page_limit = 0,
		bool order_by_asc = false,
		flatbuffers::Offset<server::TGroupsList_::Anonymous8> filter = 0,
		const char *cursor = nullptr) {
	auto cursor__ = cursor ? _fbb.CreateString(cursor) : 0;
	return server::CreateTGroupsList(
			_fbb,
			page_limit,
			order_by_asc,
			filter,
			cursor__);
}

flatbuffers::Offset<TGroupsList> CreateTGroupsList(flatbuffers::FlatBufferBuilder &_fbb, const TGroupsListT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace TGroupsList_ {

struct Anonymous8T : public flatbuffers::NativeTable {
	typedef Anonymous8 TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupsList_.Anonymous8T";
	}
	CharString lang;
	int64_t created_at;
	int64_t count;
	Anonymous8T() :
			created_at(0),
			count(0) {
	}
};

struct Anonymous8 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef Anonymous8T NativeTableType;
	typedef Anonymous8Builder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupsList_.Anonymous8";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_LANG = 4,
		VT_CREATED_AT = 6,
		VT_COUNT = 8
	};
	/// Find groups matching the given language tag.
	const flatbuffers::String *lang() const {
		return GetPointer<const flatbuffers::String *>(VT_LANG);
	}
	/// Find groups created after a given time.
	int64_t created_at() const {
		return GetField<int64_t>(VT_CREATED_AT, 0);
	}
	/// Find groups that have members up to (and equal to) the count value.
	int64_t count() const {
		return GetField<int64_t>(VT_COUNT, 0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_LANG) &&
				verifier.VerifyString(lang()) &&
				VerifyField<int64_t>(verifier, VT_CREATED_AT) &&
				VerifyField<int64_t>(verifier, VT_COUNT) &&
				verifier.EndTable();
	}
	Anonymous8T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(Anonymous8T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<Anonymous8> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Anonymous8T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct Anonymous8Builder {
	typedef Anonymous8 Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_lang(flatbuffers::Offset<flatbuffers::String> lang) {
		fbb_.AddOffset(Anonymous8::VT_LANG, lang);
	}
	void add_created_at(int64_t created_at) {
		fbb_.AddElement<int64_t>(Anonymous8::VT_CREATED_AT, created_at, 0);
	}
	void add_count(int64_t count) {
		fbb_.AddElement<int64_t>(Anonymous8::VT_COUNT, count, 0);
	}
	explicit Anonymous8Builder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<Anonymous8> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Anonymous8>(end);
		return o;
	}
};

inline flatbuffers::Offset<Anonymous8> CreateAnonymous8(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> lang = 0,
		int64_t created_at = 0,
		int64_t count = 0) {
	Anonymous8Builder builder_(_fbb);
	builder_.add_count(count);
	builder_.add_created_at(created_at);
	builder_.add_lang(lang);
	return builder_.Finish();
}

inline flatbuffers::Offset<Anonymous8> CreateAnonymous8Direct(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *lang = nullptr,
		int64_t created_at = 0,
		int64_t count = 0) {
	auto lang__ = lang ? _fbb.CreateString(lang) : 0;
	return server::TGroupsList_::CreateAnonymous8(
			_fbb,
			lang__,
			created_at,
			count);
}

flatbuffers::Offset<Anonymous8> CreateAnonymous8(flatbuffers::FlatBufferBuilder &_fbb, const Anonymous8T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

} // namespace TGroupsList_

struct TGroupsT : public flatbuffers::NativeTable {
	typedef TGroups TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupsT";
	}
	std::vector<std::unique_ptr<server::GroupT>> groups;
	CharString cursor;
	TGroupsT() {
	}
};

struct TGroups FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TGroupsT NativeTableType;
	typedef TGroupsBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroups";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_GROUPS = 4,
		VT_CURSOR = 6
	};
	const flatbuffers::Vector<flatbuffers::Offset<server::Group>> *groups() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::Group>> *>(VT_GROUPS);
	}
	/// Use cursor to paginate results.
	const flatbuffers::String *cursor() const {
		return GetPointer<const flatbuffers::String *>(VT_CURSOR);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_GROUPS) &&
				verifier.VerifyVector(groups()) &&
				verifier.VerifyVectorOfTables(groups()) &&
				VerifyOffset(verifier, VT_CURSOR) &&
				verifier.VerifyString(cursor()) &&
				verifier.EndTable();
	}
	TGroupsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TGroupsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TGroups> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TGroupsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TGroupsBuilder {
	typedef TGroups Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_groups(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::Group>>> groups) {
		fbb_.AddOffset(TGroups::VT_GROUPS, groups);
	}
	void add_cursor(flatbuffers::Offset<flatbuffers::String> cursor) {
		fbb_.AddOffset(TGroups::VT_CURSOR, cursor);
	}
	explicit TGroupsBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TGroups> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TGroups>(end);
		return o;
	}
};

inline flatbuffers::Offset<TGroups> CreateTGroups(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::Group>>> groups = 0,
		flatbuffers::Offset<flatbuffers::String> cursor = 0) {
	TGroupsBuilder builder_(_fbb);
	builder_.add_cursor(cursor);
	builder_.add_groups(groups);
	return builder_.Finish();
}

inline flatbuffers::Offset<TGroups> CreateTGroupsDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<server::Group>> *groups = nullptr,
		const char *cursor = nullptr) {
	auto groups__ = groups ? _fbb.CreateVector<flatbuffers::Offset<server::Group>>(*groups) : 0;
	auto cursor__ = cursor ? _fbb.CreateString(cursor) : 0;
	return server::CreateTGroups(
			_fbb,
			groups__,
			cursor__);
}

flatbuffers::Offset<TGroups> CreateTGroups(flatbuffers::FlatBufferBuilder &_fbb, const TGroupsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TGroupsSelfT : public flatbuffers::NativeTable {
	typedef TGroupsSelf TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupsSelfT";
	}
	std::vector<std::unique_ptr<server::TGroupsSelf_::GroupSelfT>> groups_self;
	TGroupsSelfT() {
	}
};

struct TGroupsSelf FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TGroupsSelfT NativeTableType;
	typedef TGroupsSelfBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupsSelf";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_GROUPS_SELF = 4
	};
	const flatbuffers::Vector<flatbuffers::Offset<server::TGroupsSelf_::GroupSelf>> *groups_self() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::TGroupsSelf_::GroupSelf>> *>(VT_GROUPS_SELF);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_GROUPS_SELF) &&
				verifier.VerifyVector(groups_self()) &&
				verifier.VerifyVectorOfTables(groups_self()) &&
				verifier.EndTable();
	}
	TGroupsSelfT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TGroupsSelfT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TGroupsSelf> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TGroupsSelfT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TGroupsSelfBuilder {
	typedef TGroupsSelf Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_groups_self(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TGroupsSelf_::GroupSelf>>> groups_self) {
		fbb_.AddOffset(TGroupsSelf::VT_GROUPS_SELF, groups_self);
	}
	explicit TGroupsSelfBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TGroupsSelf> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TGroupsSelf>(end);
		return o;
	}
};

inline flatbuffers::Offset<TGroupsSelf> CreateTGroupsSelf(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TGroupsSelf_::GroupSelf>>> groups_self = 0) {
	TGroupsSelfBuilder builder_(_fbb);
	builder_.add_groups_self(groups_self);
	return builder_.Finish();
}

inline flatbuffers::Offset<TGroupsSelf> CreateTGroupsSelfDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<server::TGroupsSelf_::GroupSelf>> *groups_self = nullptr) {
	auto groups_self__ = groups_self ? _fbb.CreateVector<flatbuffers::Offset<server::TGroupsSelf_::GroupSelf>>(*groups_self) : 0;
	return server::CreateTGroupsSelf(
			_fbb,
			groups_self__);
}

flatbuffers::Offset<TGroupsSelf> CreateTGroupsSelf(flatbuffers::FlatBufferBuilder &_fbb, const TGroupsSelfT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace TGroupsSelf_ {

struct GroupSelfT : public flatbuffers::NativeTable {
	typedef GroupSelf TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupsSelf_.GroupSelfT";
	}
	std::unique_ptr<server::GroupT> group;
	int64_t state;
	GroupSelfT() :
			state(0) {
	}
};

struct GroupSelf FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef GroupSelfT NativeTableType;
	typedef GroupSelfBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupsSelf_.GroupSelf";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_GROUP = 4,
		VT_STATE = 6
	};
	/// The core group information.
	const server::Group *group() const {
		return GetPointer<const server::Group *>(VT_GROUP);
	}
	/// The user's relationship to the group. One of:
	/// Admin(0): User is an admin for this group.
	/// Member(1): User is a regular member of this group.
	/// Join(2): User is currently waiting to be accepted in this group.
	int64_t state() const {
		return GetField<int64_t>(VT_STATE, 0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_GROUP) &&
				verifier.VerifyTable(group()) &&
				VerifyField<int64_t>(verifier, VT_STATE) &&
				verifier.EndTable();
	}
	GroupSelfT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(GroupSelfT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<GroupSelf> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GroupSelfT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct GroupSelfBuilder {
	typedef GroupSelf Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_group(flatbuffers::Offset<server::Group> group) {
		fbb_.AddOffset(GroupSelf::VT_GROUP, group);
	}
	void add_state(int64_t state) {
		fbb_.AddElement<int64_t>(GroupSelf::VT_STATE, state, 0);
	}
	explicit GroupSelfBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<GroupSelf> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<GroupSelf>(end);
		return o;
	}
};

inline flatbuffers::Offset<GroupSelf> CreateGroupSelf(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<server::Group> group = 0,
		int64_t state = 0) {
	GroupSelfBuilder builder_(_fbb);
	builder_.add_state(state);
	builder_.add_group(group);
	return builder_.Finish();
}

flatbuffers::Offset<GroupSelf> CreateGroupSelf(flatbuffers::FlatBufferBuilder &_fbb, const GroupSelfT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

} // namespace TGroupsSelf_

struct GroupUserT : public flatbuffers::NativeTable {
	typedef GroupUser TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.GroupUserT";
	}
	std::unique_ptr<server::UserT> user;
	int64_t state;
	GroupUserT() :
			state(0) {
	}
};

struct GroupUser FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef GroupUserT NativeTableType;
	typedef GroupUserBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.GroupUser";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_USER = 4,
		VT_STATE = 6
	};
	const server::User *user() const {
		return GetPointer<const server::User *>(VT_USER);
	}
	/// The type of relationship this is. The value can be one of the following:
	/// Admin(0): User is an admin for this group.
	/// Member(1): User is a regular member of this group.
	/// Join(2): User is currently waiting to be accepted in this group.
	int64_t state() const {
		return GetField<int64_t>(VT_STATE, 0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_USER) &&
				verifier.VerifyTable(user()) &&
				VerifyField<int64_t>(verifier, VT_STATE) &&
				verifier.EndTable();
	}
	GroupUserT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(GroupUserT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<GroupUser> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GroupUserT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct GroupUserBuilder {
	typedef GroupUser Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_user(flatbuffers::Offset<server::User> user) {
		fbb_.AddOffset(GroupUser::VT_USER, user);
	}
	void add_state(int64_t state) {
		fbb_.AddElement<int64_t>(GroupUser::VT_STATE, state, 0);
	}
	explicit GroupUserBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<GroupUser> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<GroupUser>(end);
		return o;
	}
};

inline flatbuffers::Offset<GroupUser> CreateGroupUser(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<server::User> user = 0,
		int64_t state = 0) {
	GroupUserBuilder builder_(_fbb);
	builder_.add_state(state);
	builder_.add_user(user);
	return builder_.Finish();
}

flatbuffers::Offset<GroupUser> CreateGroupUser(flatbuffers::FlatBufferBuilder &_fbb, const GroupUserT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TGroupUsersListT : public flatbuffers::NativeTable {
	typedef TGroupUsersList TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupUsersListT";
	}
	CharString group_id;
	TGroupUsersListT() {
	}
};

struct TGroupUsersList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TGroupUsersListT NativeTableType;
	typedef TGroupUsersListBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupUsersList";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_GROUP_ID = 4
	};
	const flatbuffers::String *group_id() const {
		return GetPointer<const flatbuffers::String *>(VT_GROUP_ID);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_GROUP_ID) &&
				verifier.VerifyString(group_id()) &&
				verifier.EndTable();
	}
	TGroupUsersListT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TGroupUsersListT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TGroupUsersList> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TGroupUsersListT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TGroupUsersListBuilder {
	typedef TGroupUsersList Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_group_id(flatbuffers::Offset<flatbuffers::String> group_id) {
		fbb_.AddOffset(TGroupUsersList::VT_GROUP_ID, group_id);
	}
	explicit TGroupUsersListBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TGroupUsersList> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TGroupUsersList>(end);
		return o;
	}
};

inline flatbuffers::Offset<TGroupUsersList> CreateTGroupUsersList(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> group_id = 0) {
	TGroupUsersListBuilder builder_(_fbb);
	builder_.add_group_id(group_id);
	return builder_.Finish();
}

inline flatbuffers::Offset<TGroupUsersList> CreateTGroupUsersListDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *group_id = nullptr) {
	auto group_id__ = group_id ? _fbb.CreateString(group_id) : 0;
	return server::CreateTGroupUsersList(
			_fbb,
			group_id__);
}

flatbuffers::Offset<TGroupUsersList> CreateTGroupUsersList(flatbuffers::FlatBufferBuilder &_fbb, const TGroupUsersListT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TGroupUsersT : public flatbuffers::NativeTable {
	typedef TGroupUsers TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupUsersT";
	}
	std::vector<std::unique_ptr<server::GroupUserT>> users;
	TGroupUsersT() {
	}
};

struct TGroupUsers FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TGroupUsersT NativeTableType;
	typedef TGroupUsersBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupUsers";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_USERS = 4
	};
	const flatbuffers::Vector<flatbuffers::Offset<server::GroupUser>> *users() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::GroupUser>> *>(VT_USERS);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_USERS) &&
				verifier.VerifyVector(users()) &&
				verifier.VerifyVectorOfTables(users()) &&
				verifier.EndTable();
	}
	TGroupUsersT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TGroupUsersT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TGroupUsers> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TGroupUsersT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TGroupUsersBuilder {
	typedef TGroupUsers Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_users(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::GroupUser>>> users) {
		fbb_.AddOffset(TGroupUsers::VT_USERS, users);
	}
	explicit TGroupUsersBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TGroupUsers> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TGroupUsers>(end);
		return o;
	}
};

inline flatbuffers::Offset<TGroupUsers> CreateTGroupUsers(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::GroupUser>>> users = 0) {
	TGroupUsersBuilder builder_(_fbb);
	builder_.add_users(users);
	return builder_.Finish();
}

inline flatbuffers::Offset<TGroupUsers> CreateTGroupUsersDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<server::GroupUser>> *users = nullptr) {
	auto users__ = users ? _fbb.CreateVector<flatbuffers::Offset<server::GroupUser>>(*users) : 0;
	return server::CreateTGroupUsers(
			_fbb,
			users__);
}

flatbuffers::Offset<TGroupUsers> CreateTGroupUsers(flatbuffers::FlatBufferBuilder &_fbb, const TGroupUsersT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TGroupsJoinT : public flatbuffers::NativeTable {
	typedef TGroupsJoin TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupsJoinT";
	}
	std::vector<CharString> group_ids;
	TGroupsJoinT() {
	}
};

struct TGroupsJoin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TGroupsJoinT NativeTableType;
	typedef TGroupsJoinBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupsJoin";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_GROUP_IDS = 4
	};
	const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *group_ids() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_GROUP_IDS);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_GROUP_IDS) &&
				verifier.VerifyVector(group_ids()) &&
				verifier.VerifyVectorOfStrings(group_ids()) &&
				verifier.EndTable();
	}
	TGroupsJoinT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TGroupsJoinT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TGroupsJoin> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TGroupsJoinT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TGroupsJoinBuilder {
	typedef TGroupsJoin Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_group_ids(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> group_ids) {
		fbb_.AddOffset(TGroupsJoin::VT_GROUP_IDS, group_ids);
	}
	explicit TGroupsJoinBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TGroupsJoin> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TGroupsJoin>(end);
		return o;
	}
};

inline flatbuffers::Offset<TGroupsJoin> CreateTGroupsJoin(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> group_ids = 0) {
	TGroupsJoinBuilder builder_(_fbb);
	builder_.add_group_ids(group_ids);
	return builder_.Finish();
}

inline flatbuffers::Offset<TGroupsJoin> CreateTGroupsJoinDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<flatbuffers::String>> *group_ids = nullptr) {
	auto group_ids__ = group_ids ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*group_ids) : 0;
	return server::CreateTGroupsJoin(
			_fbb,
			group_ids__);
}

flatbuffers::Offset<TGroupsJoin> CreateTGroupsJoin(flatbuffers::FlatBufferBuilder &_fbb, const TGroupsJoinT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TGroupsLeaveT : public flatbuffers::NativeTable {
	typedef TGroupsLeave TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupsLeaveT";
	}
	std::vector<CharString> group_ids;
	TGroupsLeaveT() {
	}
};

struct TGroupsLeave FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TGroupsLeaveT NativeTableType;
	typedef TGroupsLeaveBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupsLeave";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_GROUP_IDS = 4
	};
	const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *group_ids() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_GROUP_IDS);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_GROUP_IDS) &&
				verifier.VerifyVector(group_ids()) &&
				verifier.VerifyVectorOfStrings(group_ids()) &&
				verifier.EndTable();
	}
	TGroupsLeaveT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TGroupsLeaveT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TGroupsLeave> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TGroupsLeaveT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TGroupsLeaveBuilder {
	typedef TGroupsLeave Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_group_ids(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> group_ids) {
		fbb_.AddOffset(TGroupsLeave::VT_GROUP_IDS, group_ids);
	}
	explicit TGroupsLeaveBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TGroupsLeave> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TGroupsLeave>(end);
		return o;
	}
};

inline flatbuffers::Offset<TGroupsLeave> CreateTGroupsLeave(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> group_ids = 0) {
	TGroupsLeaveBuilder builder_(_fbb);
	builder_.add_group_ids(group_ids);
	return builder_.Finish();
}

inline flatbuffers::Offset<TGroupsLeave> CreateTGroupsLeaveDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<flatbuffers::String>> *group_ids = nullptr) {
	auto group_ids__ = group_ids ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*group_ids) : 0;
	return server::CreateTGroupsLeave(
			_fbb,
			group_ids__);
}

flatbuffers::Offset<TGroupsLeave> CreateTGroupsLeave(flatbuffers::FlatBufferBuilder &_fbb, const TGroupsLeaveT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TGroupUsersAddT : public flatbuffers::NativeTable {
	typedef TGroupUsersAdd TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupUsersAddT";
	}
	std::vector<std::unique_ptr<server::TGroupUsersAdd_::GroupUserAddT>> group_users;
	TGroupUsersAddT() {
	}
};

struct TGroupUsersAdd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TGroupUsersAddT NativeTableType;
	typedef TGroupUsersAddBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupUsersAdd";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_GROUP_USERS = 4
	};
	const flatbuffers::Vector<flatbuffers::Offset<server::TGroupUsersAdd_::GroupUserAdd>> *group_users() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::TGroupUsersAdd_::GroupUserAdd>> *>(VT_GROUP_USERS);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_GROUP_USERS) &&
				verifier.VerifyVector(group_users()) &&
				verifier.VerifyVectorOfTables(group_users()) &&
				verifier.EndTable();
	}
	TGroupUsersAddT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TGroupUsersAddT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TGroupUsersAdd> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TGroupUsersAddT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TGroupUsersAddBuilder {
	typedef TGroupUsersAdd Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_group_users(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TGroupUsersAdd_::GroupUserAdd>>> group_users) {
		fbb_.AddOffset(TGroupUsersAdd::VT_GROUP_USERS, group_users);
	}
	explicit TGroupUsersAddBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TGroupUsersAdd> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TGroupUsersAdd>(end);
		return o;
	}
};

inline flatbuffers::Offset<TGroupUsersAdd> CreateTGroupUsersAdd(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TGroupUsersAdd_::GroupUserAdd>>> group_users = 0) {
	TGroupUsersAddBuilder builder_(_fbb);
	builder_.add_group_users(group_users);
	return builder_.Finish();
}

inline flatbuffers::Offset<TGroupUsersAdd> CreateTGroupUsersAddDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<server::TGroupUsersAdd_::GroupUserAdd>> *group_users = nullptr) {
	auto group_users__ = group_users ? _fbb.CreateVector<flatbuffers::Offset<server::TGroupUsersAdd_::GroupUserAdd>>(*group_users) : 0;
	return server::CreateTGroupUsersAdd(
			_fbb,
			group_users__);
}

flatbuffers::Offset<TGroupUsersAdd> CreateTGroupUsersAdd(flatbuffers::FlatBufferBuilder &_fbb, const TGroupUsersAddT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace TGroupUsersAdd_ {

struct GroupUserAddT : public flatbuffers::NativeTable {
	typedef GroupUserAdd TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupUsersAdd_.GroupUserAddT";
	}
	CharString group_id;
	CharString user_id;
	GroupUserAddT() {
	}
};

struct GroupUserAdd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef GroupUserAddT NativeTableType;
	typedef GroupUserAddBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupUsersAdd_.GroupUserAdd";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_GROUP_ID = 4,
		VT_USER_ID = 6
	};
	const flatbuffers::String *group_id() const {
		return GetPointer<const flatbuffers::String *>(VT_GROUP_ID);
	}
	const flatbuffers::String *user_id() const {
		return GetPointer<const flatbuffers::String *>(VT_USER_ID);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_GROUP_ID) &&
				verifier.VerifyString(group_id()) &&
				VerifyOffset(verifier, VT_USER_ID) &&
				verifier.VerifyString(user_id()) &&
				verifier.EndTable();
	}
	GroupUserAddT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(GroupUserAddT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<GroupUserAdd> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GroupUserAddT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct GroupUserAddBuilder {
	typedef GroupUserAdd Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_group_id(flatbuffers::Offset<flatbuffers::String> group_id) {
		fbb_.AddOffset(GroupUserAdd::VT_GROUP_ID, group_id);
	}
	void add_user_id(flatbuffers::Offset<flatbuffers::String> user_id) {
		fbb_.AddOffset(GroupUserAdd::VT_USER_ID, user_id);
	}
	explicit GroupUserAddBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<GroupUserAdd> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<GroupUserAdd>(end);
		return o;
	}
};

inline flatbuffers::Offset<GroupUserAdd> CreateGroupUserAdd(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> group_id = 0,
		flatbuffers::Offset<flatbuffers::String> user_id = 0) {
	GroupUserAddBuilder builder_(_fbb);
	builder_.add_user_id(user_id);
	builder_.add_group_id(group_id);
	return builder_.Finish();
}

inline flatbuffers::Offset<GroupUserAdd> CreateGroupUserAddDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *group_id = nullptr,
		const char *user_id = nullptr) {
	auto group_id__ = group_id ? _fbb.CreateString(group_id) : 0;
	auto user_id__ = user_id ? _fbb.CreateString(user_id) : 0;
	return server::TGroupUsersAdd_::CreateGroupUserAdd(
			_fbb,
			group_id__,
			user_id__);
}

flatbuffers::Offset<GroupUserAdd> CreateGroupUserAdd(flatbuffers::FlatBufferBuilder &_fbb, const GroupUserAddT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

} // namespace TGroupUsersAdd_

struct TGroupUsersKickT : public flatbuffers::NativeTable {
	typedef TGroupUsersKick TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupUsersKickT";
	}
	std::vector<std::unique_ptr<server::TGroupUsersKick_::GroupUserKickT>> group_users;
	TGroupUsersKickT() {
	}
};

struct TGroupUsersKick FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TGroupUsersKickT NativeTableType;
	typedef TGroupUsersKickBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupUsersKick";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_GROUP_USERS = 4
	};
	const flatbuffers::Vector<flatbuffers::Offset<server::TGroupUsersKick_::GroupUserKick>> *group_users() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::TGroupUsersKick_::GroupUserKick>> *>(VT_GROUP_USERS);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_GROUP_USERS) &&
				verifier.VerifyVector(group_users()) &&
				verifier.VerifyVectorOfTables(group_users()) &&
				verifier.EndTable();
	}
	TGroupUsersKickT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TGroupUsersKickT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TGroupUsersKick> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TGroupUsersKickT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TGroupUsersKickBuilder {
	typedef TGroupUsersKick Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_group_users(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TGroupUsersKick_::GroupUserKick>>> group_users) {
		fbb_.AddOffset(TGroupUsersKick::VT_GROUP_USERS, group_users);
	}
	explicit TGroupUsersKickBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TGroupUsersKick> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TGroupUsersKick>(end);
		return o;
	}
};

inline flatbuffers::Offset<TGroupUsersKick> CreateTGroupUsersKick(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TGroupUsersKick_::GroupUserKick>>> group_users = 0) {
	TGroupUsersKickBuilder builder_(_fbb);
	builder_.add_group_users(group_users);
	return builder_.Finish();
}

inline flatbuffers::Offset<TGroupUsersKick> CreateTGroupUsersKickDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<server::TGroupUsersKick_::GroupUserKick>> *group_users = nullptr) {
	auto group_users__ = group_users ? _fbb.CreateVector<flatbuffers::Offset<server::TGroupUsersKick_::GroupUserKick>>(*group_users) : 0;
	return server::CreateTGroupUsersKick(
			_fbb,
			group_users__);
}

flatbuffers::Offset<TGroupUsersKick> CreateTGroupUsersKick(flatbuffers::FlatBufferBuilder &_fbb, const TGroupUsersKickT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace TGroupUsersKick_ {

struct GroupUserKickT : public flatbuffers::NativeTable {
	typedef GroupUserKick TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupUsersKick_.GroupUserKickT";
	}
	CharString group_id;
	CharString user_id;
	GroupUserKickT() {
	}
};

struct GroupUserKick FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef GroupUserKickT NativeTableType;
	typedef GroupUserKickBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupUsersKick_.GroupUserKick";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_GROUP_ID = 4,
		VT_USER_ID = 6
	};
	const flatbuffers::String *group_id() const {
		return GetPointer<const flatbuffers::String *>(VT_GROUP_ID);
	}
	const flatbuffers::String *user_id() const {
		return GetPointer<const flatbuffers::String *>(VT_USER_ID);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_GROUP_ID) &&
				verifier.VerifyString(group_id()) &&
				VerifyOffset(verifier, VT_USER_ID) &&
				verifier.VerifyString(user_id()) &&
				verifier.EndTable();
	}
	GroupUserKickT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(GroupUserKickT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<GroupUserKick> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GroupUserKickT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct GroupUserKickBuilder {
	typedef GroupUserKick Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_group_id(flatbuffers::Offset<flatbuffers::String> group_id) {
		fbb_.AddOffset(GroupUserKick::VT_GROUP_ID, group_id);
	}
	void add_user_id(flatbuffers::Offset<flatbuffers::String> user_id) {
		fbb_.AddOffset(GroupUserKick::VT_USER_ID, user_id);
	}
	explicit GroupUserKickBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<GroupUserKick> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<GroupUserKick>(end);
		return o;
	}
};

inline flatbuffers::Offset<GroupUserKick> CreateGroupUserKick(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> group_id = 0,
		flatbuffers::Offset<flatbuffers::String> user_id = 0) {
	GroupUserKickBuilder builder_(_fbb);
	builder_.add_user_id(user_id);
	builder_.add_group_id(group_id);
	return builder_.Finish();
}

inline flatbuffers::Offset<GroupUserKick> CreateGroupUserKickDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *group_id = nullptr,
		const char *user_id = nullptr) {
	auto group_id__ = group_id ? _fbb.CreateString(group_id) : 0;
	auto user_id__ = user_id ? _fbb.CreateString(user_id) : 0;
	return server::TGroupUsersKick_::CreateGroupUserKick(
			_fbb,
			group_id__,
			user_id__);
}

flatbuffers::Offset<GroupUserKick> CreateGroupUserKick(flatbuffers::FlatBufferBuilder &_fbb, const GroupUserKickT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

} // namespace TGroupUsersKick_

struct TGroupUsersPromoteT : public flatbuffers::NativeTable {
	typedef TGroupUsersPromote TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupUsersPromoteT";
	}
	std::vector<std::unique_ptr<server::TGroupUsersPromote_::GroupUserPromoteT>> group_users;
	TGroupUsersPromoteT() {
	}
};

struct TGroupUsersPromote FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TGroupUsersPromoteT NativeTableType;
	typedef TGroupUsersPromoteBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupUsersPromote";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_GROUP_USERS = 4
	};
	const flatbuffers::Vector<flatbuffers::Offset<server::TGroupUsersPromote_::GroupUserPromote>> *group_users() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::TGroupUsersPromote_::GroupUserPromote>> *>(VT_GROUP_USERS);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_GROUP_USERS) &&
				verifier.VerifyVector(group_users()) &&
				verifier.VerifyVectorOfTables(group_users()) &&
				verifier.EndTable();
	}
	TGroupUsersPromoteT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TGroupUsersPromoteT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TGroupUsersPromote> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TGroupUsersPromoteT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TGroupUsersPromoteBuilder {
	typedef TGroupUsersPromote Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_group_users(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TGroupUsersPromote_::GroupUserPromote>>> group_users) {
		fbb_.AddOffset(TGroupUsersPromote::VT_GROUP_USERS, group_users);
	}
	explicit TGroupUsersPromoteBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TGroupUsersPromote> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TGroupUsersPromote>(end);
		return o;
	}
};

inline flatbuffers::Offset<TGroupUsersPromote> CreateTGroupUsersPromote(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TGroupUsersPromote_::GroupUserPromote>>> group_users = 0) {
	TGroupUsersPromoteBuilder builder_(_fbb);
	builder_.add_group_users(group_users);
	return builder_.Finish();
}

inline flatbuffers::Offset<TGroupUsersPromote> CreateTGroupUsersPromoteDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<server::TGroupUsersPromote_::GroupUserPromote>> *group_users = nullptr) {
	auto group_users__ = group_users ? _fbb.CreateVector<flatbuffers::Offset<server::TGroupUsersPromote_::GroupUserPromote>>(*group_users) : 0;
	return server::CreateTGroupUsersPromote(
			_fbb,
			group_users__);
}

flatbuffers::Offset<TGroupUsersPromote> CreateTGroupUsersPromote(flatbuffers::FlatBufferBuilder &_fbb, const TGroupUsersPromoteT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace TGroupUsersPromote_ {

struct GroupUserPromoteT : public flatbuffers::NativeTable {
	typedef GroupUserPromote TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupUsersPromote_.GroupUserPromoteT";
	}
	CharString group_id;
	CharString user_id;
	GroupUserPromoteT() {
	}
};

struct GroupUserPromote FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef GroupUserPromoteT NativeTableType;
	typedef GroupUserPromoteBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TGroupUsersPromote_.GroupUserPromote";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_GROUP_ID = 4,
		VT_USER_ID = 6
	};
	const flatbuffers::String *group_id() const {
		return GetPointer<const flatbuffers::String *>(VT_GROUP_ID);
	}
	const flatbuffers::String *user_id() const {
		return GetPointer<const flatbuffers::String *>(VT_USER_ID);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_GROUP_ID) &&
				verifier.VerifyString(group_id()) &&
				VerifyOffset(verifier, VT_USER_ID) &&
				verifier.VerifyString(user_id()) &&
				verifier.EndTable();
	}
	GroupUserPromoteT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(GroupUserPromoteT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<GroupUserPromote> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GroupUserPromoteT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct GroupUserPromoteBuilder {
	typedef GroupUserPromote Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_group_id(flatbuffers::Offset<flatbuffers::String> group_id) {
		fbb_.AddOffset(GroupUserPromote::VT_GROUP_ID, group_id);
	}
	void add_user_id(flatbuffers::Offset<flatbuffers::String> user_id) {
		fbb_.AddOffset(GroupUserPromote::VT_USER_ID, user_id);
	}
	explicit GroupUserPromoteBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<GroupUserPromote> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<GroupUserPromote>(end);
		return o;
	}
};

inline flatbuffers::Offset<GroupUserPromote> CreateGroupUserPromote(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> group_id = 0,
		flatbuffers::Offset<flatbuffers::String> user_id = 0) {
	GroupUserPromoteBuilder builder_(_fbb);
	builder_.add_user_id(user_id);
	builder_.add_group_id(group_id);
	return builder_.Finish();
}

inline flatbuffers::Offset<GroupUserPromote> CreateGroupUserPromoteDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *group_id = nullptr,
		const char *user_id = nullptr) {
	auto group_id__ = group_id ? _fbb.CreateString(group_id) : 0;
	auto user_id__ = user_id ? _fbb.CreateString(user_id) : 0;
	return server::TGroupUsersPromote_::CreateGroupUserPromote(
			_fbb,
			group_id__,
			user_id__);
}

flatbuffers::Offset<GroupUserPromote> CreateGroupUserPromote(flatbuffers::FlatBufferBuilder &_fbb, const GroupUserPromoteT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

} // namespace TGroupUsersPromote_

struct TopicIdT : public flatbuffers::NativeTable {
	typedef TopicId TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TopicIdT";
	}
	std::unique_ptr<server::TopicId_::TopicTypeT> id;
	TopicIdT() {
	}
};

struct TopicId FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TopicIdT NativeTableType;
	typedef TopicIdBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TopicId";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_ID = 4
	};
	const server::TopicId_::TopicType *id() const {
		return GetPointer<const server::TopicId_::TopicType *>(VT_ID);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_ID) &&
				verifier.VerifyTable(id()) &&
				verifier.EndTable();
	}
	TopicIdT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TopicIdT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TopicId> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TopicIdT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TopicIdBuilder {
	typedef TopicId Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_id(flatbuffers::Offset<server::TopicId_::TopicType> id) {
		fbb_.AddOffset(TopicId::VT_ID, id);
	}
	explicit TopicIdBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TopicId> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TopicId>(end);
		return o;
	}
};

inline flatbuffers::Offset<TopicId> CreateTopicId(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<server::TopicId_::TopicType> id = 0) {
	TopicIdBuilder builder_(_fbb);
	builder_.add_id(id);
	return builder_.Finish();
}

flatbuffers::Offset<TopicId> CreateTopicId(flatbuffers::FlatBufferBuilder &_fbb, const TopicIdT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace TopicId_ {

struct TopicTypeT : public flatbuffers::NativeTable {
	typedef TopicType TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TopicId_.TopicTypeT";
	}
	CharString dm;
	CharString room;
	CharString group_id;
	TopicTypeT() {
	}
};

struct TopicType FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TopicTypeT NativeTableType;
	typedef TopicTypeBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TopicId_.TopicType";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_DM = 4,
		VT_ROOM = 6,
		VT_GROUP_ID = 8
	};
	const flatbuffers::String *dm() const {
		return GetPointer<const flatbuffers::String *>(VT_DM);
	}
	const flatbuffers::String *room() const {
		return GetPointer<const flatbuffers::String *>(VT_ROOM);
	}
	const flatbuffers::String *group_id() const {
		return GetPointer<const flatbuffers::String *>(VT_GROUP_ID);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_DM) &&
				verifier.VerifyString(dm()) &&
				VerifyOffset(verifier, VT_ROOM) &&
				verifier.VerifyString(room()) &&
				VerifyOffset(verifier, VT_GROUP_ID) &&
				verifier.VerifyString(group_id()) &&
				verifier.EndTable();
	}
	TopicTypeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TopicTypeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TopicType> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TopicTypeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TopicTypeBuilder {
	typedef TopicType Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_dm(flatbuffers::Offset<flatbuffers::String> dm) {
		fbb_.AddOffset(TopicType::VT_DM, dm);
	}
	void add_room(flatbuffers::Offset<flatbuffers::String> room) {
		fbb_.AddOffset(TopicType::VT_ROOM, room);
	}
	void add_group_id(flatbuffers::Offset<flatbuffers::String> group_id) {
		fbb_.AddOffset(TopicType::VT_GROUP_ID, group_id);
	}
	explicit TopicTypeBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TopicType> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TopicType>(end);
		return o;
	}
};

inline flatbuffers::Offset<TopicType> CreateTopicType(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> dm = 0,
		flatbuffers::Offset<flatbuffers::String> room = 0,
		flatbuffers::Offset<flatbuffers::String> group_id = 0) {
	TopicTypeBuilder builder_(_fbb);
	builder_.add_group_id(group_id);
	builder_.add_room(room);
	builder_.add_dm(dm);
	return builder_.Finish();
}

inline flatbuffers::Offset<TopicType> CreateTopicTypeDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *dm = nullptr,
		const char *room = nullptr,
		const char *group_id = nullptr) {
	auto dm__ = dm ? _fbb.CreateString(dm) : 0;
	auto room__ = room ? _fbb.CreateString(room) : 0;
	auto group_id__ = group_id ? _fbb.CreateString(group_id) : 0;
	return server::TopicId_::CreateTopicType(
			_fbb,
			dm__,
			room__,
			group_id__);
}

flatbuffers::Offset<TopicType> CreateTopicType(flatbuffers::FlatBufferBuilder &_fbb, const TopicTypeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

} // namespace TopicId_

struct UserPresenceT : public flatbuffers::NativeTable {
	typedef UserPresence TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.UserPresenceT";
	}
	CharString user_id;
	CharString session_id;
	CharString handle;
	UserPresenceT() {
	}
};

struct UserPresence FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef UserPresenceT NativeTableType;
	typedef UserPresenceBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.UserPresence";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_USER_ID = 4,
		VT_SESSION_ID = 6,
		VT_HANDLE = 8
	};
	/// User ID
	const flatbuffers::String *user_id() const {
		return GetPointer<const flatbuffers::String *>(VT_USER_ID);
	}
	/// Session ID
	const flatbuffers::String *session_id() const {
		return GetPointer<const flatbuffers::String *>(VT_SESSION_ID);
	}
	/// User handle
	const flatbuffers::String *handle() const {
		return GetPointer<const flatbuffers::String *>(VT_HANDLE);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_USER_ID) &&
				verifier.VerifyString(user_id()) &&
				VerifyOffset(verifier, VT_SESSION_ID) &&
				verifier.VerifyString(session_id()) &&
				VerifyOffset(verifier, VT_HANDLE) &&
				verifier.VerifyString(handle()) &&
				verifier.EndTable();
	}
	UserPresenceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(UserPresenceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<UserPresence> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UserPresenceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct UserPresenceBuilder {
	typedef UserPresence Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_user_id(flatbuffers::Offset<flatbuffers::String> user_id) {
		fbb_.AddOffset(UserPresence::VT_USER_ID, user_id);
	}
	void add_session_id(flatbuffers::Offset<flatbuffers::String> session_id) {
		fbb_.AddOffset(UserPresence::VT_SESSION_ID, session_id);
	}
	void add_handle(flatbuffers::Offset<flatbuffers::String> handle) {
		fbb_.AddOffset(UserPresence::VT_HANDLE, handle);
	}
	explicit UserPresenceBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<UserPresence> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<UserPresence>(end);
		return o;
	}
};

inline flatbuffers::Offset<UserPresence> CreateUserPresence(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> user_id = 0,
		flatbuffers::Offset<flatbuffers::String> session_id = 0,
		flatbuffers::Offset<flatbuffers::String> handle = 0) {
	UserPresenceBuilder builder_(_fbb);
	builder_.add_handle(handle);
	builder_.add_session_id(session_id);
	builder_.add_user_id(user_id);
	return builder_.Finish();
}

inline flatbuffers::Offset<UserPresence> CreateUserPresenceDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *user_id = nullptr,
		const char *session_id = nullptr,
		const char *handle = nullptr) {
	auto user_id__ = user_id ? _fbb.CreateString(user_id) : 0;
	auto session_id__ = session_id ? _fbb.CreateString(session_id) : 0;
	auto handle__ = handle ? _fbb.CreateString(handle) : 0;
	return server::CreateUserPresence(
			_fbb,
			user_id__,
			session_id__,
			handle__);
}

flatbuffers::Offset<UserPresence> CreateUserPresence(flatbuffers::FlatBufferBuilder &_fbb, const UserPresenceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TTopicsJoinT : public flatbuffers::NativeTable {
	typedef TTopicsJoin TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TTopicsJoinT";
	}
	std::vector<std::unique_ptr<server::TTopicsJoin_::TopicJoinT>> joins;
	TTopicsJoinT() {
	}
};

struct TTopicsJoin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TTopicsJoinT NativeTableType;
	typedef TTopicsJoinBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TTopicsJoin";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_JOINS = 4
	};
	const flatbuffers::Vector<flatbuffers::Offset<server::TTopicsJoin_::TopicJoin>> *joins() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::TTopicsJoin_::TopicJoin>> *>(VT_JOINS);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_JOINS) &&
				verifier.VerifyVector(joins()) &&
				verifier.VerifyVectorOfTables(joins()) &&
				verifier.EndTable();
	}
	TTopicsJoinT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TTopicsJoinT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TTopicsJoin> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TTopicsJoinT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TTopicsJoinBuilder {
	typedef TTopicsJoin Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_joins(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TTopicsJoin_::TopicJoin>>> joins) {
		fbb_.AddOffset(TTopicsJoin::VT_JOINS, joins);
	}
	explicit TTopicsJoinBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TTopicsJoin> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TTopicsJoin>(end);
		return o;
	}
};

inline flatbuffers::Offset<TTopicsJoin> CreateTTopicsJoin(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TTopicsJoin_::TopicJoin>>> joins = 0) {
	TTopicsJoinBuilder builder_(_fbb);
	builder_.add_joins(joins);
	return builder_.Finish();
}

inline flatbuffers::Offset<TTopicsJoin> CreateTTopicsJoinDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<server::TTopicsJoin_::TopicJoin>> *joins = nullptr) {
	auto joins__ = joins ? _fbb.CreateVector<flatbuffers::Offset<server::TTopicsJoin_::TopicJoin>>(*joins) : 0;
	return server::CreateTTopicsJoin(
			_fbb,
			joins__);
}

flatbuffers::Offset<TTopicsJoin> CreateTTopicsJoin(flatbuffers::FlatBufferBuilder &_fbb, const TTopicsJoinT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace TTopicsJoin_ {

struct TopicJoinT : public flatbuffers::NativeTable {
	typedef TopicJoin TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TTopicsJoin_.TopicJoinT";
	}
	std::unique_ptr<server::TTopicsJoin_::TopicJoin_::AuthenticateResult0T> id;
	TopicJoinT() {
	}
};

struct TopicJoin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TopicJoinT NativeTableType;
	typedef TopicJoinBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TTopicsJoin_.TopicJoin";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_ID = 4
	};
	const server::TTopicsJoin_::TopicJoin_::AuthenticateResult0 *id() const {
		return GetPointer<const server::TTopicsJoin_::TopicJoin_::AuthenticateResult0 *>(VT_ID);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_ID) &&
				verifier.VerifyTable(id()) &&
				verifier.EndTable();
	}
	TopicJoinT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TopicJoinT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TopicJoin> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TopicJoinT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TopicJoinBuilder {
	typedef TopicJoin Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_id(flatbuffers::Offset<server::TTopicsJoin_::TopicJoin_::AuthenticateResult0> id) {
		fbb_.AddOffset(TopicJoin::VT_ID, id);
	}
	explicit TopicJoinBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TopicJoin> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TopicJoin>(end);
		return o;
	}
};

inline flatbuffers::Offset<TopicJoin> CreateTopicJoin(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<server::TTopicsJoin_::TopicJoin_::AuthenticateResult0> id = 0) {
	TopicJoinBuilder builder_(_fbb);
	builder_.add_id(id);
	return builder_.Finish();
}

flatbuffers::Offset<TopicJoin> CreateTopicJoin(flatbuffers::FlatBufferBuilder &_fbb, const TopicJoinT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace TopicJoin_ {

struct AuthenticateResult0T : public flatbuffers::NativeTable {
	typedef AuthenticateResult0 TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TTopicsJoin_.TopicJoin_.AuthenticateResult0T";
	}
	CharString user_id;
	CharString room;
	CharString group_id;
	AuthenticateResult0T() {
	}
};

struct AuthenticateResult0 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef AuthenticateResult0T NativeTableType;
	typedef AuthenticateResult0Builder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TTopicsJoin_.TopicJoin_.AuthenticateResult0";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_USER_ID = 4,
		VT_ROOM = 6,
		VT_GROUP_ID = 8
	};
	const flatbuffers::String *user_id() const {
		return GetPointer<const flatbuffers::String *>(VT_USER_ID);
	}
	const flatbuffers::String *room() const {
		return GetPointer<const flatbuffers::String *>(VT_ROOM);
	}
	const flatbuffers::String *group_id() const {
		return GetPointer<const flatbuffers::String *>(VT_GROUP_ID);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_USER_ID) &&
				verifier.VerifyString(user_id()) &&
				VerifyOffset(verifier, VT_ROOM) &&
				verifier.VerifyString(room()) &&
				VerifyOffset(verifier, VT_GROUP_ID) &&
				verifier.VerifyString(group_id()) &&
				verifier.EndTable();
	}
	AuthenticateResult0T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(AuthenticateResult0T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<AuthenticateResult0> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateResult0T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct AuthenticateResult0Builder {
	typedef AuthenticateResult0 Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_user_id(flatbuffers::Offset<flatbuffers::String> user_id) {
		fbb_.AddOffset(AuthenticateResult0::VT_USER_ID, user_id);
	}
	void add_room(flatbuffers::Offset<flatbuffers::String> room) {
		fbb_.AddOffset(AuthenticateResult0::VT_ROOM, room);
	}
	void add_group_id(flatbuffers::Offset<flatbuffers::String> group_id) {
		fbb_.AddOffset(AuthenticateResult0::VT_GROUP_ID, group_id);
	}
	explicit AuthenticateResult0Builder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<AuthenticateResult0> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<AuthenticateResult0>(end);
		return o;
	}
};

inline flatbuffers::Offset<AuthenticateResult0> CreateAuthenticateResult0(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> user_id = 0,
		flatbuffers::Offset<flatbuffers::String> room = 0,
		flatbuffers::Offset<flatbuffers::String> group_id = 0) {
	AuthenticateResult0Builder builder_(_fbb);
	builder_.add_group_id(group_id);
	builder_.add_room(room);
	builder_.add_user_id(user_id);
	return builder_.Finish();
}

inline flatbuffers::Offset<AuthenticateResult0> CreateAuthenticateResult0Direct(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *user_id = nullptr,
		const char *room = nullptr,
		const char *group_id = nullptr) {
	auto user_id__ = user_id ? _fbb.CreateString(user_id) : 0;
	auto room__ = room ? _fbb.CreateString(room) : 0;
	auto group_id__ = group_id ? _fbb.CreateString(group_id) : 0;
	return server::TTopicsJoin_::TopicJoin_::CreateAuthenticateResult0(
			_fbb,
			user_id__,
			room__,
			group_id__);
}

flatbuffers::Offset<AuthenticateResult0> CreateAuthenticateResult0(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateResult0T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

} // namespace TopicJoin_
} // namespace TTopicsJoin_

struct TTopicsT : public flatbuffers::NativeTable {
	typedef TTopics TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TTopicsT";
	}
	std::vector<std::unique_ptr<server::TTopics_::TopicT>> topics;
	TTopicsT() {
	}
};

struct TTopics FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TTopicsT NativeTableType;
	typedef TTopicsBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TTopics";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_TOPICS = 4
	};
	const flatbuffers::Vector<flatbuffers::Offset<server::TTopics_::Topic>> *topics() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::TTopics_::Topic>> *>(VT_TOPICS);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_TOPICS) &&
				verifier.VerifyVector(topics()) &&
				verifier.VerifyVectorOfTables(topics()) &&
				verifier.EndTable();
	}
	TTopicsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TTopicsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TTopics> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TTopicsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TTopicsBuilder {
	typedef TTopics Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_topics(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TTopics_::Topic>>> topics) {
		fbb_.AddOffset(TTopics::VT_TOPICS, topics);
	}
	explicit TTopicsBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TTopics> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TTopics>(end);
		return o;
	}
};

inline flatbuffers::Offset<TTopics> CreateTTopics(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TTopics_::Topic>>> topics = 0) {
	TTopicsBuilder builder_(_fbb);
	builder_.add_topics(topics);
	return builder_.Finish();
}

inline flatbuffers::Offset<TTopics> CreateTTopicsDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<server::TTopics_::Topic>> *topics = nullptr) {
	auto topics__ = topics ? _fbb.CreateVector<flatbuffers::Offset<server::TTopics_::Topic>>(*topics) : 0;
	return server::CreateTTopics(
			_fbb,
			topics__);
}

flatbuffers::Offset<TTopics> CreateTTopics(flatbuffers::FlatBufferBuilder &_fbb, const TTopicsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace TTopics_ {

struct TopicT : public flatbuffers::NativeTable {
	typedef Topic TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TTopics_.TopicT";
	}
	std::unique_ptr<server::TopicIdT> topic;
	std::vector<std::unique_ptr<server::UserPresenceT>> presences;
	std::unique_ptr<server::UserPresenceT> self;
	TopicT() {
	}
};

struct Topic FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TopicT NativeTableType;
	typedef TopicBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TTopics_.Topic";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_TOPIC = 4,
		VT_PRESENCES = 6,
		VT_SELF = 8
	};
	/// Chat topics
	const server::TopicId *topic() const {
		return GetPointer<const server::TopicId *>(VT_TOPIC);
	}
	/// List of chat presences in the topic
	const flatbuffers::Vector<flatbuffers::Offset<server::UserPresence>> *presences() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::UserPresence>> *>(VT_PRESENCES);
	}
	/// Current user's chat presence
	const server::UserPresence *self() const {
		return GetPointer<const server::UserPresence *>(VT_SELF);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_TOPIC) &&
				verifier.VerifyTable(topic()) &&
				VerifyOffset(verifier, VT_PRESENCES) &&
				verifier.VerifyVector(presences()) &&
				verifier.VerifyVectorOfTables(presences()) &&
				VerifyOffset(verifier, VT_SELF) &&
				verifier.VerifyTable(self()) &&
				verifier.EndTable();
	}
	TopicT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TopicT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<Topic> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TopicT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TopicBuilder {
	typedef Topic Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_topic(flatbuffers::Offset<server::TopicId> topic) {
		fbb_.AddOffset(Topic::VT_TOPIC, topic);
	}
	void add_presences(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::UserPresence>>> presences) {
		fbb_.AddOffset(Topic::VT_PRESENCES, presences);
	}
	void add_self(flatbuffers::Offset<server::UserPresence> self) {
		fbb_.AddOffset(Topic::VT_SELF, self);
	}
	explicit TopicBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<Topic> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Topic>(end);
		return o;
	}
};

inline flatbuffers::Offset<Topic> CreateTopic(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<server::TopicId> topic = 0,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::UserPresence>>> presences = 0,
		flatbuffers::Offset<server::UserPresence> self = 0) {
	TopicBuilder builder_(_fbb);
	builder_.add_self(self);
	builder_.add_presences(presences);
	builder_.add_topic(topic);
	return builder_.Finish();
}

inline flatbuffers::Offset<Topic> CreateTopicDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<server::TopicId> topic = 0,
		const std::vector<flatbuffers::Offset<server::UserPresence>> *presences = nullptr,
		flatbuffers::Offset<server::UserPresence> self = 0) {
	auto presences__ = presences ? _fbb.CreateVector<flatbuffers::Offset<server::UserPresence>>(*presences) : 0;
	return server::TTopics_::CreateTopic(
			_fbb,
			topic,
			presences__,
			self);
}

flatbuffers::Offset<Topic> CreateTopic(flatbuffers::FlatBufferBuilder &_fbb, const TopicT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

} // namespace TTopics_

struct TTopicsLeaveT : public flatbuffers::NativeTable {
	typedef TTopicsLeave TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TTopicsLeaveT";
	}
	std::vector<std::unique_ptr<server::TopicIdT>> topics;
	TTopicsLeaveT() {
	}
};

struct TTopicsLeave FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TTopicsLeaveT NativeTableType;
	typedef TTopicsLeaveBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TTopicsLeave";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_TOPICS = 4
	};
	const flatbuffers::Vector<flatbuffers::Offset<server::TopicId>> *topics() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::TopicId>> *>(VT_TOPICS);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_TOPICS) &&
				verifier.VerifyVector(topics()) &&
				verifier.VerifyVectorOfTables(topics()) &&
				verifier.EndTable();
	}
	TTopicsLeaveT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TTopicsLeaveT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TTopicsLeave> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TTopicsLeaveT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TTopicsLeaveBuilder {
	typedef TTopicsLeave Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_topics(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TopicId>>> topics) {
		fbb_.AddOffset(TTopicsLeave::VT_TOPICS, topics);
	}
	explicit TTopicsLeaveBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TTopicsLeave> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TTopicsLeave>(end);
		return o;
	}
};

inline flatbuffers::Offset<TTopicsLeave> CreateTTopicsLeave(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TopicId>>> topics = 0) {
	TTopicsLeaveBuilder builder_(_fbb);
	builder_.add_topics(topics);
	return builder_.Finish();
}

inline flatbuffers::Offset<TTopicsLeave> CreateTTopicsLeaveDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<server::TopicId>> *topics = nullptr) {
	auto topics__ = topics ? _fbb.CreateVector<flatbuffers::Offset<server::TopicId>>(*topics) : 0;
	return server::CreateTTopicsLeave(
			_fbb,
			topics__);
}

flatbuffers::Offset<TTopicsLeave> CreateTTopicsLeave(flatbuffers::FlatBufferBuilder &_fbb, const TTopicsLeaveT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TTopicMessageSendT : public flatbuffers::NativeTable {
	typedef TTopicMessageSend TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TTopicMessageSendT";
	}
	std::unique_ptr<server::TopicIdT> topic;
	CharString data;
	TTopicMessageSendT() {
	}
};

struct TTopicMessageSend FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TTopicMessageSendT NativeTableType;
	typedef TTopicMessageSendBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TTopicMessageSend";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_TOPIC = 4,
		VT_DATA = 6
	};
	const server::TopicId *topic() const {
		return GetPointer<const server::TopicId *>(VT_TOPIC);
	}
	const flatbuffers::String *data() const {
		return GetPointer<const flatbuffers::String *>(VT_DATA);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_TOPIC) &&
				verifier.VerifyTable(topic()) &&
				VerifyOffset(verifier, VT_DATA) &&
				verifier.VerifyString(data()) &&
				verifier.EndTable();
	}
	TTopicMessageSendT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TTopicMessageSendT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TTopicMessageSend> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TTopicMessageSendT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TTopicMessageSendBuilder {
	typedef TTopicMessageSend Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_topic(flatbuffers::Offset<server::TopicId> topic) {
		fbb_.AddOffset(TTopicMessageSend::VT_TOPIC, topic);
	}
	void add_data(flatbuffers::Offset<flatbuffers::String> data) {
		fbb_.AddOffset(TTopicMessageSend::VT_DATA, data);
	}
	explicit TTopicMessageSendBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TTopicMessageSend> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TTopicMessageSend>(end);
		return o;
	}
};

inline flatbuffers::Offset<TTopicMessageSend> CreateTTopicMessageSend(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<server::TopicId> topic = 0,
		flatbuffers::Offset<flatbuffers::String> data = 0) {
	TTopicMessageSendBuilder builder_(_fbb);
	builder_.add_data(data);
	builder_.add_topic(topic);
	return builder_.Finish();
}

inline flatbuffers::Offset<TTopicMessageSend> CreateTTopicMessageSendDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<server::TopicId> topic = 0,
		const char *data = nullptr) {
	auto data__ = data ? _fbb.CreateString(data) : 0;
	return server::CreateTTopicMessageSend(
			_fbb,
			topic,
			data__);
}

flatbuffers::Offset<TTopicMessageSend> CreateTTopicMessageSend(flatbuffers::FlatBufferBuilder &_fbb, const TTopicMessageSendT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TTopicMessageAckT : public flatbuffers::NativeTable {
	typedef TTopicMessageAck TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TTopicMessageAckT";
	}
	CharString message_id;
	int64_t created_at;
	int64_t expires_at;
	CharString handle;
	TTopicMessageAckT() :
			created_at(0),
			expires_at(0) {
	}
};

struct TTopicMessageAck FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TTopicMessageAckT NativeTableType;
	typedef TTopicMessageAckBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TTopicMessageAck";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_MESSAGE_ID = 4,
		VT_CREATED_AT = 6,
		VT_EXPIRES_AT = 8,
		VT_HANDLE = 10
	};
	const flatbuffers::String *message_id() const {
		return GetPointer<const flatbuffers::String *>(VT_MESSAGE_ID);
	}
	int64_t created_at() const {
		return GetField<int64_t>(VT_CREATED_AT, 0);
	}
	int64_t expires_at() const {
		return GetField<int64_t>(VT_EXPIRES_AT, 0);
	}
	const flatbuffers::String *handle() const {
		return GetPointer<const flatbuffers::String *>(VT_HANDLE);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_MESSAGE_ID) &&
				verifier.VerifyString(message_id()) &&
				VerifyField<int64_t>(verifier, VT_CREATED_AT) &&
				VerifyField<int64_t>(verifier, VT_EXPIRES_AT) &&
				VerifyOffset(verifier, VT_HANDLE) &&
				verifier.VerifyString(handle()) &&
				verifier.EndTable();
	}
	TTopicMessageAckT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TTopicMessageAckT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TTopicMessageAck> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TTopicMessageAckT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TTopicMessageAckBuilder {
	typedef TTopicMessageAck Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_message_id(flatbuffers::Offset<flatbuffers::String> message_id) {
		fbb_.AddOffset(TTopicMessageAck::VT_MESSAGE_ID, message_id);
	}
	void add_created_at(int64_t created_at) {
		fbb_.AddElement<int64_t>(TTopicMessageAck::VT_CREATED_AT, created_at, 0);
	}
	void add_expires_at(int64_t expires_at) {
		fbb_.AddElement<int64_t>(TTopicMessageAck::VT_EXPIRES_AT, expires_at, 0);
	}
	void add_handle(flatbuffers::Offset<flatbuffers::String> handle) {
		fbb_.AddOffset(TTopicMessageAck::VT_HANDLE, handle);
	}
	explicit TTopicMessageAckBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TTopicMessageAck> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TTopicMessageAck>(end);
		return o;
	}
};

inline flatbuffers::Offset<TTopicMessageAck> CreateTTopicMessageAck(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> message_id = 0,
		int64_t created_at = 0,
		int64_t expires_at = 0,
		flatbuffers::Offset<flatbuffers::String> handle = 0) {
	TTopicMessageAckBuilder builder_(_fbb);
	builder_.add_expires_at(expires_at);
	builder_.add_created_at(created_at);
	builder_.add_handle(handle);
	builder_.add_message_id(message_id);
	return builder_.Finish();
}

inline flatbuffers::Offset<TTopicMessageAck> CreateTTopicMessageAckDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *message_id = nullptr,
		int64_t created_at = 0,
		int64_t expires_at = 0,
		const char *handle = nullptr) {
	auto message_id__ = message_id ? _fbb.CreateString(message_id) : 0;
	auto handle__ = handle ? _fbb.CreateString(handle) : 0;
	return server::CreateTTopicMessageAck(
			_fbb,
			message_id__,
			created_at,
			expires_at,
			handle__);
}

flatbuffers::Offset<TTopicMessageAck> CreateTTopicMessageAck(flatbuffers::FlatBufferBuilder &_fbb, const TTopicMessageAckT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TopicMessageT : public flatbuffers::NativeTable {
	typedef TopicMessage TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TopicMessageT";
	}
	std::unique_ptr<server::TopicIdT> topic;
	CharString user_id;
	CharString message_id;
	int64_t created_at;
	int64_t expires_at;
	CharString handle;
	int64_t type;
	CharString data;
	TopicMessageT() :
			created_at(0),
			expires_at(0),
			type(0) {
	}
};

struct TopicMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TopicMessageT NativeTableType;
	typedef TopicMessageBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TopicMessage";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_TOPIC = 4,
		VT_USER_ID = 6,
		VT_MESSAGE_ID = 8,
		VT_CREATED_AT = 10,
		VT_EXPIRES_AT = 12,
		VT_HANDLE = 14,
		VT_TYPE = 16,
		VT_DATA = 18
	};
	const server::TopicId *topic() const {
		return GetPointer<const server::TopicId *>(VT_TOPIC);
	}
	const flatbuffers::String *user_id() const {
		return GetPointer<const flatbuffers::String *>(VT_USER_ID);
	}
	const flatbuffers::String *message_id() const {
		return GetPointer<const flatbuffers::String *>(VT_MESSAGE_ID);
	}
	int64_t created_at() const {
		return GetField<int64_t>(VT_CREATED_AT, 0);
	}
	int64_t expires_at() const {
		return GetField<int64_t>(VT_EXPIRES_AT, 0);
	}
	const flatbuffers::String *handle() const {
		return GetPointer<const flatbuffers::String *>(VT_HANDLE);
	}
	/// The chat message types are:
	/// Chat message (0) - Chat messages sent by users
	/// Group Join (1) - Notification - a user joined the group - send by the system
	/// Group Add (2) - Notification - a user was added/accepted to the group - send by the system
	/// Group Leave (3) - Notification - a user left the group - send by the system
	/// Group Kick (4) - Notification - a user was kicked from the group - send by the system
	/// Group Promoted (5) - Notification - a user was promoted to group admin - send by the system
	int64_t type() const {
		return GetField<int64_t>(VT_TYPE, 0);
	}
	const flatbuffers::String *data() const {
		return GetPointer<const flatbuffers::String *>(VT_DATA);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_TOPIC) &&
				verifier.VerifyTable(topic()) &&
				VerifyOffset(verifier, VT_USER_ID) &&
				verifier.VerifyString(user_id()) &&
				VerifyOffset(verifier, VT_MESSAGE_ID) &&
				verifier.VerifyString(message_id()) &&
				VerifyField<int64_t>(verifier, VT_CREATED_AT) &&
				VerifyField<int64_t>(verifier, VT_EXPIRES_AT) &&
				VerifyOffset(verifier, VT_HANDLE) &&
				verifier.VerifyString(handle()) &&
				VerifyField<int64_t>(verifier, VT_TYPE) &&
				VerifyOffset(verifier, VT_DATA) &&
				verifier.VerifyString(data()) &&
				verifier.EndTable();
	}
	TopicMessageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TopicMessageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TopicMessage> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TopicMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TopicMessageBuilder {
	typedef TopicMessage Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_topic(flatbuffers::Offset<server::TopicId> topic) {
		fbb_.AddOffset(TopicMessage::VT_TOPIC, topic);
	}
	void add_user_id(flatbuffers::Offset<flatbuffers::String> user_id) {
		fbb_.AddOffset(TopicMessage::VT_USER_ID, user_id);
	}
	void add_message_id(flatbuffers::Offset<flatbuffers::String> message_id) {
		fbb_.AddOffset(TopicMessage::VT_MESSAGE_ID, message_id);
	}
	void add_created_at(int64_t created_at) {
		fbb_.AddElement<int64_t>(TopicMessage::VT_CREATED_AT, created_at, 0);
	}
	void add_expires_at(int64_t expires_at) {
		fbb_.AddElement<int64_t>(TopicMessage::VT_EXPIRES_AT, expires_at, 0);
	}
	void add_handle(flatbuffers::Offset<flatbuffers::String> handle) {
		fbb_.AddOffset(TopicMessage::VT_HANDLE, handle);
	}
	void add_type(int64_t type) {
		fbb_.AddElement<int64_t>(TopicMessage::VT_TYPE, type, 0);
	}
	void add_data(flatbuffers::Offset<flatbuffers::String> data) {
		fbb_.AddOffset(TopicMessage::VT_DATA, data);
	}
	explicit TopicMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TopicMessage> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TopicMessage>(end);
		return o;
	}
};

inline flatbuffers::Offset<TopicMessage> CreateTopicMessage(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<server::TopicId> topic = 0,
		flatbuffers::Offset<flatbuffers::String> user_id = 0,
		flatbuffers::Offset<flatbuffers::String> message_id = 0,
		int64_t created_at = 0,
		int64_t expires_at = 0,
		flatbuffers::Offset<flatbuffers::String> handle = 0,
		int64_t type = 0,
		flatbuffers::Offset<flatbuffers::String> data = 0) {
	TopicMessageBuilder builder_(_fbb);
	builder_.add_type(type);
	builder_.add_expires_at(expires_at);
	builder_.add_created_at(created_at);
	builder_.add_data(data);
	builder_.add_handle(handle);
	builder_.add_message_id(message_id);
	builder_.add_user_id(user_id);
	builder_.add_topic(topic);
	return builder_.Finish();
}

inline flatbuffers::Offset<TopicMessage> CreateTopicMessageDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<server::TopicId> topic = 0,
		const char *user_id = nullptr,
		const char *message_id = nullptr,
		int64_t created_at = 0,
		int64_t expires_at = 0,
		const char *handle = nullptr,
		int64_t type = 0,
		const char *data = nullptr) {
	auto user_id__ = user_id ? _fbb.CreateString(user_id) : 0;
	auto message_id__ = message_id ? _fbb.CreateString(message_id) : 0;
	auto handle__ = handle ? _fbb.CreateString(handle) : 0;
	auto data__ = data ? _fbb.CreateString(data) : 0;
	return server::CreateTopicMessage(
			_fbb,
			topic,
			user_id__,
			message_id__,
			created_at,
			expires_at,
			handle__,
			type,
			data__);
}

flatbuffers::Offset<TopicMessage> CreateTopicMessage(flatbuffers::FlatBufferBuilder &_fbb, const TopicMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TTopicMessagesListT : public flatbuffers::NativeTable {
	typedef TTopicMessagesList TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TTopicMessagesListT";
	}
	std::unique_ptr<server::TTopicMessagesList_::AuthenticateResult1T> id;
	CharString cursor;
	bool forward;
	int64_t limit;
	TTopicMessagesListT() :
			forward(false),
			limit(0) {
	}
};

struct TTopicMessagesList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TTopicMessagesListT NativeTableType;
	typedef TTopicMessagesListBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TTopicMessagesList";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_ID = 4,
		VT_CURSOR = 6,
		VT_FORWARD = 8,
		VT_LIMIT = 10
	};
	const server::TTopicMessagesList_::AuthenticateResult1 *id() const {
		return GetPointer<const server::TTopicMessagesList_::AuthenticateResult1 *>(VT_ID);
	}
	/// Use the cursor to paginate through more message.
	/// The value of this comes from TTopicMessages.cursor.
	const flatbuffers::String *cursor() const {
		return GetPointer<const flatbuffers::String *>(VT_CURSOR);
	}
	bool forward() const {
		return GetField<uint8_t>(VT_FORWARD, 0) != 0;
	}
	int64_t limit() const {
		return GetField<int64_t>(VT_LIMIT, 0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_ID) &&
				verifier.VerifyTable(id()) &&
				VerifyOffset(verifier, VT_CURSOR) &&
				verifier.VerifyString(cursor()) &&
				VerifyField<uint8_t>(verifier, VT_FORWARD) &&
				VerifyField<int64_t>(verifier, VT_LIMIT) &&
				verifier.EndTable();
	}
	TTopicMessagesListT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TTopicMessagesListT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TTopicMessagesList> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TTopicMessagesListT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TTopicMessagesListBuilder {
	typedef TTopicMessagesList Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_id(flatbuffers::Offset<server::TTopicMessagesList_::AuthenticateResult1> id) {
		fbb_.AddOffset(TTopicMessagesList::VT_ID, id);
	}
	void add_cursor(flatbuffers::Offset<flatbuffers::String> cursor) {
		fbb_.AddOffset(TTopicMessagesList::VT_CURSOR, cursor);
	}
	void add_forward(bool forward) {
		fbb_.AddElement<uint8_t>(TTopicMessagesList::VT_FORWARD, static_cast<uint8_t>(forward), 0);
	}
	void add_limit(int64_t limit) {
		fbb_.AddElement<int64_t>(TTopicMessagesList::VT_LIMIT, limit, 0);
	}
	explicit TTopicMessagesListBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TTopicMessagesList> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TTopicMessagesList>(end);
		return o;
	}
};

inline flatbuffers::Offset<TTopicMessagesList> CreateTTopicMessagesList(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<server::TTopicMessagesList_::AuthenticateResult1> id = 0,
		flatbuffers::Offset<flatbuffers::String> cursor = 0,
		bool forward = false,
		int64_t limit = 0) {
	TTopicMessagesListBuilder builder_(_fbb);
	builder_.add_limit(limit);
	builder_.add_cursor(cursor);
	builder_.add_id(id);
	builder_.add_forward(forward);
	return builder_.Finish();
}

inline flatbuffers::Offset<TTopicMessagesList> CreateTTopicMessagesListDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<server::TTopicMessagesList_::AuthenticateResult1> id = 0,
		const char *cursor = nullptr,
		bool forward = false,
		int64_t limit = 0) {
	auto cursor__ = cursor ? _fbb.CreateString(cursor) : 0;
	return server::CreateTTopicMessagesList(
			_fbb,
			id,
			cursor__,
			forward,
			limit);
}

flatbuffers::Offset<TTopicMessagesList> CreateTTopicMessagesList(flatbuffers::FlatBufferBuilder &_fbb, const TTopicMessagesListT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace TTopicMessagesList_ {

struct AuthenticateResult1T : public flatbuffers::NativeTable {
	typedef AuthenticateResult1 TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TTopicMessagesList_.AuthenticateResult1T";
	}
	CharString user_id;
	CharString room;
	CharString group_id;
	AuthenticateResult1T() {
	}
};

struct AuthenticateResult1 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef AuthenticateResult1T NativeTableType;
	typedef AuthenticateResult1Builder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TTopicMessagesList_.AuthenticateResult1";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_USER_ID = 4,
		VT_ROOM = 6,
		VT_GROUP_ID = 8
	};
	const flatbuffers::String *user_id() const {
		return GetPointer<const flatbuffers::String *>(VT_USER_ID);
	}
	const flatbuffers::String *room() const {
		return GetPointer<const flatbuffers::String *>(VT_ROOM);
	}
	const flatbuffers::String *group_id() const {
		return GetPointer<const flatbuffers::String *>(VT_GROUP_ID);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_USER_ID) &&
				verifier.VerifyString(user_id()) &&
				VerifyOffset(verifier, VT_ROOM) &&
				verifier.VerifyString(room()) &&
				VerifyOffset(verifier, VT_GROUP_ID) &&
				verifier.VerifyString(group_id()) &&
				verifier.EndTable();
	}
	AuthenticateResult1T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(AuthenticateResult1T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<AuthenticateResult1> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateResult1T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct AuthenticateResult1Builder {
	typedef AuthenticateResult1 Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_user_id(flatbuffers::Offset<flatbuffers::String> user_id) {
		fbb_.AddOffset(AuthenticateResult1::VT_USER_ID, user_id);
	}
	void add_room(flatbuffers::Offset<flatbuffers::String> room) {
		fbb_.AddOffset(AuthenticateResult1::VT_ROOM, room);
	}
	void add_group_id(flatbuffers::Offset<flatbuffers::String> group_id) {
		fbb_.AddOffset(AuthenticateResult1::VT_GROUP_ID, group_id);
	}
	explicit AuthenticateResult1Builder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<AuthenticateResult1> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<AuthenticateResult1>(end);
		return o;
	}
};

inline flatbuffers::Offset<AuthenticateResult1> CreateAuthenticateResult1(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> user_id = 0,
		flatbuffers::Offset<flatbuffers::String> room = 0,
		flatbuffers::Offset<flatbuffers::String> group_id = 0) {
	AuthenticateResult1Builder builder_(_fbb);
	builder_.add_group_id(group_id);
	builder_.add_room(room);
	builder_.add_user_id(user_id);
	return builder_.Finish();
}

inline flatbuffers::Offset<AuthenticateResult1> CreateAuthenticateResult1Direct(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *user_id = nullptr,
		const char *room = nullptr,
		const char *group_id = nullptr) {
	auto user_id__ = user_id ? _fbb.CreateString(user_id) : 0;
	auto room__ = room ? _fbb.CreateString(room) : 0;
	auto group_id__ = group_id ? _fbb.CreateString(group_id) : 0;
	return server::TTopicMessagesList_::CreateAuthenticateResult1(
			_fbb,
			user_id__,
			room__,
			group_id__);
}

flatbuffers::Offset<AuthenticateResult1> CreateAuthenticateResult1(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateResult1T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

} // namespace TTopicMessagesList_

struct TTopicMessagesT : public flatbuffers::NativeTable {
	typedef TTopicMessages TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TTopicMessagesT";
	}
	std::vector<std::unique_ptr<server::TopicMessageT>> messages;
	CharString cursor;
	TTopicMessagesT() {
	}
};

struct TTopicMessages FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TTopicMessagesT NativeTableType;
	typedef TTopicMessagesBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TTopicMessages";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_MESSAGES = 4,
		VT_CURSOR = 6
	};
	const flatbuffers::Vector<flatbuffers::Offset<server::TopicMessage>> *messages() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::TopicMessage>> *>(VT_MESSAGES);
	}
	const flatbuffers::String *cursor() const {
		return GetPointer<const flatbuffers::String *>(VT_CURSOR);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_MESSAGES) &&
				verifier.VerifyVector(messages()) &&
				verifier.VerifyVectorOfTables(messages()) &&
				VerifyOffset(verifier, VT_CURSOR) &&
				verifier.VerifyString(cursor()) &&
				verifier.EndTable();
	}
	TTopicMessagesT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TTopicMessagesT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TTopicMessages> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TTopicMessagesT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TTopicMessagesBuilder {
	typedef TTopicMessages Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_messages(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TopicMessage>>> messages) {
		fbb_.AddOffset(TTopicMessages::VT_MESSAGES, messages);
	}
	void add_cursor(flatbuffers::Offset<flatbuffers::String> cursor) {
		fbb_.AddOffset(TTopicMessages::VT_CURSOR, cursor);
	}
	explicit TTopicMessagesBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TTopicMessages> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TTopicMessages>(end);
		return o;
	}
};

inline flatbuffers::Offset<TTopicMessages> CreateTTopicMessages(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TopicMessage>>> messages = 0,
		flatbuffers::Offset<flatbuffers::String> cursor = 0) {
	TTopicMessagesBuilder builder_(_fbb);
	builder_.add_cursor(cursor);
	builder_.add_messages(messages);
	return builder_.Finish();
}

inline flatbuffers::Offset<TTopicMessages> CreateTTopicMessagesDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<server::TopicMessage>> *messages = nullptr,
		const char *cursor = nullptr) {
	auto messages__ = messages ? _fbb.CreateVector<flatbuffers::Offset<server::TopicMessage>>(*messages) : 0;
	auto cursor__ = cursor ? _fbb.CreateString(cursor) : 0;
	return server::CreateTTopicMessages(
			_fbb,
			messages__,
			cursor__);
}

flatbuffers::Offset<TTopicMessages> CreateTTopicMessages(flatbuffers::FlatBufferBuilder &_fbb, const TTopicMessagesT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TopicPresenceT : public flatbuffers::NativeTable {
	typedef TopicPresence TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TopicPresenceT";
	}
	std::unique_ptr<server::TopicIdT> topic;
	std::vector<std::unique_ptr<server::UserPresenceT>> joins;
	std::vector<std::unique_ptr<server::UserPresenceT>> leaves;
	TopicPresenceT() {
	}
};

struct TopicPresence FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TopicPresenceT NativeTableType;
	typedef TopicPresenceBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TopicPresence";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_TOPIC = 4,
		VT_JOINS = 6,
		VT_LEAVES = 8
	};
	const server::TopicId *topic() const {
		return GetPointer<const server::TopicId *>(VT_TOPIC);
	}
	const flatbuffers::Vector<flatbuffers::Offset<server::UserPresence>> *joins() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::UserPresence>> *>(VT_JOINS);
	}
	const flatbuffers::Vector<flatbuffers::Offset<server::UserPresence>> *leaves() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::UserPresence>> *>(VT_LEAVES);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_TOPIC) &&
				verifier.VerifyTable(topic()) &&
				VerifyOffset(verifier, VT_JOINS) &&
				verifier.VerifyVector(joins()) &&
				verifier.VerifyVectorOfTables(joins()) &&
				VerifyOffset(verifier, VT_LEAVES) &&
				verifier.VerifyVector(leaves()) &&
				verifier.VerifyVectorOfTables(leaves()) &&
				verifier.EndTable();
	}
	TopicPresenceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TopicPresenceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TopicPresence> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TopicPresenceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TopicPresenceBuilder {
	typedef TopicPresence Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_topic(flatbuffers::Offset<server::TopicId> topic) {
		fbb_.AddOffset(TopicPresence::VT_TOPIC, topic);
	}
	void add_joins(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::UserPresence>>> joins) {
		fbb_.AddOffset(TopicPresence::VT_JOINS, joins);
	}
	void add_leaves(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::UserPresence>>> leaves) {
		fbb_.AddOffset(TopicPresence::VT_LEAVES, leaves);
	}
	explicit TopicPresenceBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TopicPresence> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TopicPresence>(end);
		return o;
	}
};

inline flatbuffers::Offset<TopicPresence> CreateTopicPresence(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<server::TopicId> topic = 0,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::UserPresence>>> joins = 0,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::UserPresence>>> leaves = 0) {
	TopicPresenceBuilder builder_(_fbb);
	builder_.add_leaves(leaves);
	builder_.add_joins(joins);
	builder_.add_topic(topic);
	return builder_.Finish();
}

inline flatbuffers::Offset<TopicPresence> CreateTopicPresenceDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<server::TopicId> topic = 0,
		const std::vector<flatbuffers::Offset<server::UserPresence>> *joins = nullptr,
		const std::vector<flatbuffers::Offset<server::UserPresence>> *leaves = nullptr) {
	auto joins__ = joins ? _fbb.CreateVector<flatbuffers::Offset<server::UserPresence>>(*joins) : 0;
	auto leaves__ = leaves ? _fbb.CreateVector<flatbuffers::Offset<server::UserPresence>>(*leaves) : 0;
	return server::CreateTopicPresence(
			_fbb,
			topic,
			joins__,
			leaves__);
}

flatbuffers::Offset<TopicPresence> CreateTopicPresence(flatbuffers::FlatBufferBuilder &_fbb, const TopicPresenceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PropertyPairT : public flatbuffers::NativeTable {
	typedef PropertyPair TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.PropertyPairT";
	}
	CharString key;
	std::unique_ptr<server::PropertyPair_::AuthenticateResult2T> value;
	PropertyPairT() {
	}
};

struct PropertyPair FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef PropertyPairT NativeTableType;
	typedef PropertyPairBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.PropertyPair";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_KEY = 4,
		VT_VALUE = 6
	};
	const flatbuffers::String *key() const {
		return GetPointer<const flatbuffers::String *>(VT_KEY);
	}
	const server::PropertyPair_::AuthenticateResult2 *value() const {
		return GetPointer<const server::PropertyPair_::AuthenticateResult2 *>(VT_VALUE);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_KEY) &&
				verifier.VerifyString(key()) &&
				VerifyOffset(verifier, VT_VALUE) &&
				verifier.VerifyTable(value()) &&
				verifier.EndTable();
	}
	PropertyPairT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(PropertyPairT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<PropertyPair> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PropertyPairT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct PropertyPairBuilder {
	typedef PropertyPair Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_key(flatbuffers::Offset<flatbuffers::String> key) {
		fbb_.AddOffset(PropertyPair::VT_KEY, key);
	}
	void add_value(flatbuffers::Offset<server::PropertyPair_::AuthenticateResult2> value) {
		fbb_.AddOffset(PropertyPair::VT_VALUE, value);
	}
	explicit PropertyPairBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<PropertyPair> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<PropertyPair>(end);
		return o;
	}
};

inline flatbuffers::Offset<PropertyPair> CreatePropertyPair(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> key = 0,
		flatbuffers::Offset<server::PropertyPair_::AuthenticateResult2> value = 0) {
	PropertyPairBuilder builder_(_fbb);
	builder_.add_value(value);
	builder_.add_key(key);
	return builder_.Finish();
}

inline flatbuffers::Offset<PropertyPair> CreatePropertyPairDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *key = nullptr,
		flatbuffers::Offset<server::PropertyPair_::AuthenticateResult2> value = 0) {
	auto key__ = key ? _fbb.CreateString(key) : 0;
	return server::CreatePropertyPair(
			_fbb,
			key__,
			value);
}

flatbuffers::Offset<PropertyPair> CreatePropertyPair(flatbuffers::FlatBufferBuilder &_fbb, const PropertyPairT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace PropertyPair_ {

struct StringSetT : public flatbuffers::NativeTable {
	typedef StringSet TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.PropertyPair_.StringSetT";
	}
	std::vector<CharString> values;
	StringSetT() {
	}
};

/// Set of string user property
struct StringSet FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef StringSetT NativeTableType;
	typedef StringSetBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.PropertyPair_.StringSet";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_VALUES = 4
	};
	const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *values() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_VALUES);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_VALUES) &&
				verifier.VerifyVector(values()) &&
				verifier.VerifyVectorOfStrings(values()) &&
				verifier.EndTable();
	}
	StringSetT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(StringSetT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<StringSet> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StringSetT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct StringSetBuilder {
	typedef StringSet Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_values(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> values) {
		fbb_.AddOffset(StringSet::VT_VALUES, values);
	}
	explicit StringSetBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<StringSet> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<StringSet>(end);
		return o;
	}
};

inline flatbuffers::Offset<StringSet> CreateStringSet(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> values = 0) {
	StringSetBuilder builder_(_fbb);
	builder_.add_values(values);
	return builder_.Finish();
}

inline flatbuffers::Offset<StringSet> CreateStringSetDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<flatbuffers::String>> *values = nullptr) {
	auto values__ = values ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*values) : 0;
	return server::PropertyPair_::CreateStringSet(
			_fbb,
			values__);
}

flatbuffers::Offset<StringSet> CreateStringSet(flatbuffers::FlatBufferBuilder &_fbb, const StringSetT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AuthenticateResult2T : public flatbuffers::NativeTable {
	typedef AuthenticateResult2 TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.PropertyPair_.AuthenticateResult2T";
	}
	std::unique_ptr<server::PropertyPair_::StringSetT> string_set;
	bool bool_value;
	int64_t int_value;
	AuthenticateResult2T() :
			bool_value(false),
			int_value(0) {
	}
};

struct AuthenticateResult2 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef AuthenticateResult2T NativeTableType;
	typedef AuthenticateResult2Builder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.PropertyPair_.AuthenticateResult2";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_STRING_SET = 4,
		VT_BOOL_VALUE = 6,
		VT_INT_VALUE = 8
	};
	const server::PropertyPair_::StringSet *string_set() const {
		return GetPointer<const server::PropertyPair_::StringSet *>(VT_STRING_SET);
	}
	bool bool_value() const {
		return GetField<uint8_t>(VT_BOOL_VALUE, 0) != 0;
	}
	int64_t int_value() const {
		return GetField<int64_t>(VT_INT_VALUE, 0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_STRING_SET) &&
				verifier.VerifyTable(string_set()) &&
				VerifyField<uint8_t>(verifier, VT_BOOL_VALUE) &&
				VerifyField<int64_t>(verifier, VT_INT_VALUE) &&
				verifier.EndTable();
	}
	AuthenticateResult2T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(AuthenticateResult2T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<AuthenticateResult2> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateResult2T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct AuthenticateResult2Builder {
	typedef AuthenticateResult2 Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_string_set(flatbuffers::Offset<server::PropertyPair_::StringSet> string_set) {
		fbb_.AddOffset(AuthenticateResult2::VT_STRING_SET, string_set);
	}
	void add_bool_value(bool bool_value) {
		fbb_.AddElement<uint8_t>(AuthenticateResult2::VT_BOOL_VALUE, static_cast<uint8_t>(bool_value), 0);
	}
	void add_int_value(int64_t int_value) {
		fbb_.AddElement<int64_t>(AuthenticateResult2::VT_INT_VALUE, int_value, 0);
	}
	explicit AuthenticateResult2Builder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<AuthenticateResult2> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<AuthenticateResult2>(end);
		return o;
	}
};

inline flatbuffers::Offset<AuthenticateResult2> CreateAuthenticateResult2(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<server::PropertyPair_::StringSet> string_set = 0,
		bool bool_value = false,
		int64_t int_value = 0) {
	AuthenticateResult2Builder builder_(_fbb);
	builder_.add_int_value(int_value);
	builder_.add_string_set(string_set);
	builder_.add_bool_value(bool_value);
	return builder_.Finish();
}

flatbuffers::Offset<AuthenticateResult2> CreateAuthenticateResult2(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateResult2T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

} // namespace PropertyPair_

struct MatchmakeFilterT : public flatbuffers::NativeTable {
	typedef MatchmakeFilter TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.MatchmakeFilterT";
	}
	CharString name;
	std::unique_ptr<server::MatchmakeFilter_::AuthenticateResult3T> value;
	MatchmakeFilterT() {
	}
};

struct MatchmakeFilter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef MatchmakeFilterT NativeTableType;
	typedef MatchmakeFilterBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.MatchmakeFilter";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_NAME = 4,
		VT_VALUE = 6
	};
	const flatbuffers::String *name() const {
		return GetPointer<const flatbuffers::String *>(VT_NAME);
	}
	const server::MatchmakeFilter_::AuthenticateResult3 *value() const {
		return GetPointer<const server::MatchmakeFilter_::AuthenticateResult3 *>(VT_VALUE);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_NAME) &&
				verifier.VerifyString(name()) &&
				VerifyOffset(verifier, VT_VALUE) &&
				verifier.VerifyTable(value()) &&
				verifier.EndTable();
	}
	MatchmakeFilterT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(MatchmakeFilterT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<MatchmakeFilter> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatchmakeFilterT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct MatchmakeFilterBuilder {
	typedef MatchmakeFilter Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_name(flatbuffers::Offset<flatbuffers::String> name) {
		fbb_.AddOffset(MatchmakeFilter::VT_NAME, name);
	}
	void add_value(flatbuffers::Offset<server::MatchmakeFilter_::AuthenticateResult3> value) {
		fbb_.AddOffset(MatchmakeFilter::VT_VALUE, value);
	}
	explicit MatchmakeFilterBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<MatchmakeFilter> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<MatchmakeFilter>(end);
		return o;
	}
};

inline flatbuffers::Offset<MatchmakeFilter> CreateMatchmakeFilter(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> name = 0,
		flatbuffers::Offset<server::MatchmakeFilter_::AuthenticateResult3> value = 0) {
	MatchmakeFilterBuilder builder_(_fbb);
	builder_.add_value(value);
	builder_.add_name(name);
	return builder_.Finish();
}

inline flatbuffers::Offset<MatchmakeFilter> CreateMatchmakeFilterDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *name = nullptr,
		flatbuffers::Offset<server::MatchmakeFilter_::AuthenticateResult3> value = 0) {
	auto name__ = name ? _fbb.CreateString(name) : 0;
	return server::CreateMatchmakeFilter(
			_fbb,
			name__,
			value);
}

flatbuffers::Offset<MatchmakeFilter> CreateMatchmakeFilter(flatbuffers::FlatBufferBuilder &_fbb, const MatchmakeFilterT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace MatchmakeFilter_ {

struct TermFilterT : public flatbuffers::NativeTable {
	typedef TermFilter TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.MatchmakeFilter_.TermFilterT";
	}
	std::vector<CharString> terms;
	bool match_all_terms;
	TermFilterT() :
			match_all_terms(false) {
	}
};

/// String term filters
struct TermFilter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TermFilterT NativeTableType;
	typedef TermFilterBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.MatchmakeFilter_.TermFilter";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_TERMS = 4,
		VT_MATCH_ALL_TERMS = 6
	};
	const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *terms() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_TERMS);
	}
	bool match_all_terms() const {
		return GetField<uint8_t>(VT_MATCH_ALL_TERMS, 0) != 0;
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_TERMS) &&
				verifier.VerifyVector(terms()) &&
				verifier.VerifyVectorOfStrings(terms()) &&
				VerifyField<uint8_t>(verifier, VT_MATCH_ALL_TERMS) &&
				verifier.EndTable();
	}
	TermFilterT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TermFilterT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TermFilter> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TermFilterT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TermFilterBuilder {
	typedef TermFilter Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_terms(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> terms) {
		fbb_.AddOffset(TermFilter::VT_TERMS, terms);
	}
	void add_match_all_terms(bool match_all_terms) {
		fbb_.AddElement<uint8_t>(TermFilter::VT_MATCH_ALL_TERMS, static_cast<uint8_t>(match_all_terms), 0);
	}
	explicit TermFilterBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TermFilter> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TermFilter>(end);
		return o;
	}
};

inline flatbuffers::Offset<TermFilter> CreateTermFilter(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> terms = 0,
		bool match_all_terms = false) {
	TermFilterBuilder builder_(_fbb);
	builder_.add_terms(terms);
	builder_.add_match_all_terms(match_all_terms);
	return builder_.Finish();
}

inline flatbuffers::Offset<TermFilter> CreateTermFilterDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<flatbuffers::String>> *terms = nullptr,
		bool match_all_terms = false) {
	auto terms__ = terms ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*terms) : 0;
	return server::MatchmakeFilter_::CreateTermFilter(
			_fbb,
			terms__,
			match_all_terms);
}

flatbuffers::Offset<TermFilter> CreateTermFilter(flatbuffers::FlatBufferBuilder &_fbb, const TermFilterT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RangeFilterT : public flatbuffers::NativeTable {
	typedef RangeFilter TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.MatchmakeFilter_.RangeFilterT";
	}
	int64_t lower_bound;
	int64_t upper_bound;
	RangeFilterT() :
			lower_bound(0),
			upper_bound(0) {
	}
};

/// Numeric range filter
struct RangeFilter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef RangeFilterT NativeTableType;
	typedef RangeFilterBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.MatchmakeFilter_.RangeFilter";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_LOWER_BOUND = 4,
		VT_UPPER_BOUND = 6
	};
	int64_t lower_bound() const {
		return GetField<int64_t>(VT_LOWER_BOUND, 0);
	}
	int64_t upper_bound() const {
		return GetField<int64_t>(VT_UPPER_BOUND, 0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyField<int64_t>(verifier, VT_LOWER_BOUND) &&
				VerifyField<int64_t>(verifier, VT_UPPER_BOUND) &&
				verifier.EndTable();
	}
	RangeFilterT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(RangeFilterT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<RangeFilter> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RangeFilterT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct RangeFilterBuilder {
	typedef RangeFilter Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_lower_bound(int64_t lower_bound) {
		fbb_.AddElement<int64_t>(RangeFilter::VT_LOWER_BOUND, lower_bound, 0);
	}
	void add_upper_bound(int64_t upper_bound) {
		fbb_.AddElement<int64_t>(RangeFilter::VT_UPPER_BOUND, upper_bound, 0);
	}
	explicit RangeFilterBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<RangeFilter> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<RangeFilter>(end);
		return o;
	}
};

inline flatbuffers::Offset<RangeFilter> CreateRangeFilter(
		flatbuffers::FlatBufferBuilder &_fbb,
		int64_t lower_bound = 0,
		int64_t upper_bound = 0) {
	RangeFilterBuilder builder_(_fbb);
	builder_.add_upper_bound(upper_bound);
	builder_.add_lower_bound(lower_bound);
	return builder_.Finish();
}

flatbuffers::Offset<RangeFilter> CreateRangeFilter(flatbuffers::FlatBufferBuilder &_fbb, const RangeFilterT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AuthenticateResult3T : public flatbuffers::NativeTable {
	typedef AuthenticateResult3 TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.MatchmakeFilter_.AuthenticateResult3T";
	}
	std::unique_ptr<server::MatchmakeFilter_::TermFilterT> term;
	std::unique_ptr<server::MatchmakeFilter_::RangeFilterT> range;
	bool check;
	AuthenticateResult3T() :
			check(false) {
	}
};

struct AuthenticateResult3 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef AuthenticateResult3T NativeTableType;
	typedef AuthenticateResult3Builder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.MatchmakeFilter_.AuthenticateResult3";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_TERM = 4,
		VT_RANGE = 6,
		VT_CHECK = 8
	};
	const server::MatchmakeFilter_::TermFilter *term() const {
		return GetPointer<const server::MatchmakeFilter_::TermFilter *>(VT_TERM);
	}
	const server::MatchmakeFilter_::RangeFilter *range() const {
		return GetPointer<const server::MatchmakeFilter_::RangeFilter *>(VT_RANGE);
	}
	bool check() const {
		return GetField<uint8_t>(VT_CHECK, 0) != 0;
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_TERM) &&
				verifier.VerifyTable(term()) &&
				VerifyOffset(verifier, VT_RANGE) &&
				verifier.VerifyTable(range()) &&
				VerifyField<uint8_t>(verifier, VT_CHECK) &&
				verifier.EndTable();
	}
	AuthenticateResult3T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(AuthenticateResult3T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<AuthenticateResult3> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateResult3T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct AuthenticateResult3Builder {
	typedef AuthenticateResult3 Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_term(flatbuffers::Offset<server::MatchmakeFilter_::TermFilter> term) {
		fbb_.AddOffset(AuthenticateResult3::VT_TERM, term);
	}
	void add_range(flatbuffers::Offset<server::MatchmakeFilter_::RangeFilter> range) {
		fbb_.AddOffset(AuthenticateResult3::VT_RANGE, range);
	}
	void add_check(bool check) {
		fbb_.AddElement<uint8_t>(AuthenticateResult3::VT_CHECK, static_cast<uint8_t>(check), 0);
	}
	explicit AuthenticateResult3Builder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<AuthenticateResult3> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<AuthenticateResult3>(end);
		return o;
	}
};

inline flatbuffers::Offset<AuthenticateResult3> CreateAuthenticateResult3(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<server::MatchmakeFilter_::TermFilter> term = 0,
		flatbuffers::Offset<server::MatchmakeFilter_::RangeFilter> range = 0,
		bool check = false) {
	AuthenticateResult3Builder builder_(_fbb);
	builder_.add_range(range);
	builder_.add_term(term);
	builder_.add_check(check);
	return builder_.Finish();
}

flatbuffers::Offset<AuthenticateResult3> CreateAuthenticateResult3(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateResult3T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

} // namespace MatchmakeFilter_

struct TMatchmakeAddT : public flatbuffers::NativeTable {
	typedef TMatchmakeAdd TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TMatchmakeAddT";
	}
	int64_t required_count;
	std::vector<std::unique_ptr<server::MatchmakeFilterT>> filters;
	std::vector<std::unique_ptr<server::PropertyPairT>> properties;
	TMatchmakeAddT() :
			required_count(0) {
	}
};

struct TMatchmakeAdd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TMatchmakeAddT NativeTableType;
	typedef TMatchmakeAddBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TMatchmakeAdd";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_REQUIRED_COUNT = 4,
		VT_FILTERS = 6,
		VT_PROPERTIES = 8
	};
	/// Match user with other users looking for a match with the the following number of users.
	int64_t required_count() const {
		return GetField<int64_t>(VT_REQUIRED_COUNT, 0);
	}
	/// List of filters that need to match.
	const flatbuffers::Vector<flatbuffers::Offset<server::MatchmakeFilter>> *filters() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::MatchmakeFilter>> *>(VT_FILTERS);
	}
	/// List of properties for the current user.
	const flatbuffers::Vector<flatbuffers::Offset<server::PropertyPair>> *properties() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::PropertyPair>> *>(VT_PROPERTIES);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyField<int64_t>(verifier, VT_REQUIRED_COUNT) &&
				VerifyOffset(verifier, VT_FILTERS) &&
				verifier.VerifyVector(filters()) &&
				verifier.VerifyVectorOfTables(filters()) &&
				VerifyOffset(verifier, VT_PROPERTIES) &&
				verifier.VerifyVector(properties()) &&
				verifier.VerifyVectorOfTables(properties()) &&
				verifier.EndTable();
	}
	TMatchmakeAddT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TMatchmakeAddT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TMatchmakeAdd> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TMatchmakeAddT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TMatchmakeAddBuilder {
	typedef TMatchmakeAdd Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_required_count(int64_t required_count) {
		fbb_.AddElement<int64_t>(TMatchmakeAdd::VT_REQUIRED_COUNT, required_count, 0);
	}
	void add_filters(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::MatchmakeFilter>>> filters) {
		fbb_.AddOffset(TMatchmakeAdd::VT_FILTERS, filters);
	}
	void add_properties(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::PropertyPair>>> properties) {
		fbb_.AddOffset(TMatchmakeAdd::VT_PROPERTIES, properties);
	}
	explicit TMatchmakeAddBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TMatchmakeAdd> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TMatchmakeAdd>(end);
		return o;
	}
};

inline flatbuffers::Offset<TMatchmakeAdd> CreateTMatchmakeAdd(
		flatbuffers::FlatBufferBuilder &_fbb,
		int64_t required_count = 0,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::MatchmakeFilter>>> filters = 0,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::PropertyPair>>> properties = 0) {
	TMatchmakeAddBuilder builder_(_fbb);
	builder_.add_required_count(required_count);
	builder_.add_properties(properties);
	builder_.add_filters(filters);
	return builder_.Finish();
}

inline flatbuffers::Offset<TMatchmakeAdd> CreateTMatchmakeAddDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		int64_t required_count = 0,
		const std::vector<flatbuffers::Offset<server::MatchmakeFilter>> *filters = nullptr,
		const std::vector<flatbuffers::Offset<server::PropertyPair>> *properties = nullptr) {
	auto filters__ = filters ? _fbb.CreateVector<flatbuffers::Offset<server::MatchmakeFilter>>(*filters) : 0;
	auto properties__ = properties ? _fbb.CreateVector<flatbuffers::Offset<server::PropertyPair>>(*properties) : 0;
	return server::CreateTMatchmakeAdd(
			_fbb,
			required_count,
			filters__,
			properties__);
}

flatbuffers::Offset<TMatchmakeAdd> CreateTMatchmakeAdd(flatbuffers::FlatBufferBuilder &_fbb, const TMatchmakeAddT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TMatchmakeTicketT : public flatbuffers::NativeTable {
	typedef TMatchmakeTicket TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TMatchmakeTicketT";
	}
	CharString ticket;
	TMatchmakeTicketT() {
	}
};

struct TMatchmakeTicket FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TMatchmakeTicketT NativeTableType;
	typedef TMatchmakeTicketBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TMatchmakeTicket";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_TICKET = 4
	};
	const flatbuffers::String *ticket() const {
		return GetPointer<const flatbuffers::String *>(VT_TICKET);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_TICKET) &&
				verifier.VerifyString(ticket()) &&
				verifier.EndTable();
	}
	TMatchmakeTicketT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TMatchmakeTicketT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TMatchmakeTicket> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TMatchmakeTicketT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TMatchmakeTicketBuilder {
	typedef TMatchmakeTicket Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_ticket(flatbuffers::Offset<flatbuffers::String> ticket) {
		fbb_.AddOffset(TMatchmakeTicket::VT_TICKET, ticket);
	}
	explicit TMatchmakeTicketBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TMatchmakeTicket> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TMatchmakeTicket>(end);
		return o;
	}
};

inline flatbuffers::Offset<TMatchmakeTicket> CreateTMatchmakeTicket(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> ticket = 0) {
	TMatchmakeTicketBuilder builder_(_fbb);
	builder_.add_ticket(ticket);
	return builder_.Finish();
}

inline flatbuffers::Offset<TMatchmakeTicket> CreateTMatchmakeTicketDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *ticket = nullptr) {
	auto ticket__ = ticket ? _fbb.CreateString(ticket) : 0;
	return server::CreateTMatchmakeTicket(
			_fbb,
			ticket__);
}

flatbuffers::Offset<TMatchmakeTicket> CreateTMatchmakeTicket(flatbuffers::FlatBufferBuilder &_fbb, const TMatchmakeTicketT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TMatchmakeRemoveT : public flatbuffers::NativeTable {
	typedef TMatchmakeRemove TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TMatchmakeRemoveT";
	}
	CharString ticket;
	TMatchmakeRemoveT() {
	}
};

struct TMatchmakeRemove FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TMatchmakeRemoveT NativeTableType;
	typedef TMatchmakeRemoveBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TMatchmakeRemove";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_TICKET = 4
	};
	const flatbuffers::String *ticket() const {
		return GetPointer<const flatbuffers::String *>(VT_TICKET);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_TICKET) &&
				verifier.VerifyString(ticket()) &&
				verifier.EndTable();
	}
	TMatchmakeRemoveT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TMatchmakeRemoveT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TMatchmakeRemove> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TMatchmakeRemoveT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TMatchmakeRemoveBuilder {
	typedef TMatchmakeRemove Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_ticket(flatbuffers::Offset<flatbuffers::String> ticket) {
		fbb_.AddOffset(TMatchmakeRemove::VT_TICKET, ticket);
	}
	explicit TMatchmakeRemoveBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TMatchmakeRemove> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TMatchmakeRemove>(end);
		return o;
	}
};

inline flatbuffers::Offset<TMatchmakeRemove> CreateTMatchmakeRemove(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> ticket = 0) {
	TMatchmakeRemoveBuilder builder_(_fbb);
	builder_.add_ticket(ticket);
	return builder_.Finish();
}

inline flatbuffers::Offset<TMatchmakeRemove> CreateTMatchmakeRemoveDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *ticket = nullptr) {
	auto ticket__ = ticket ? _fbb.CreateString(ticket) : 0;
	return server::CreateTMatchmakeRemove(
			_fbb,
			ticket__);
}

flatbuffers::Offset<TMatchmakeRemove> CreateTMatchmakeRemove(flatbuffers::FlatBufferBuilder &_fbb, const TMatchmakeRemoveT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MatchmakeMatchedT : public flatbuffers::NativeTable {
	typedef MatchmakeMatched TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.MatchmakeMatchedT";
	}
	CharString ticket;
	CharString token;
	std::vector<std::unique_ptr<server::UserPresenceT>> presences;
	std::unique_ptr<server::UserPresenceT> self;
	std::vector<std::unique_ptr<server::MatchmakeMatched_::UserPropertyT>> properties;
	MatchmakeMatchedT() {
	}
};

struct MatchmakeMatched FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef MatchmakeMatchedT NativeTableType;
	typedef MatchmakeMatchedBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.MatchmakeMatched";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_TICKET = 4,
		VT_TOKEN = 6,
		VT_PRESENCES = 8,
		VT_SELF = 10,
		VT_PROPERTIES = 12
	};
	/// Matchmaking ticket. Use this to invalidate ticket cache on the client.
	const flatbuffers::String *ticket() const {
		return GetPointer<const flatbuffers::String *>(VT_TICKET);
	}
	/// Matchmaking token. Use this to accept the match. This is a onetime token which is only valid for a limited time.
	const flatbuffers::String *token() const {
		return GetPointer<const flatbuffers::String *>(VT_TOKEN);
	}
	const flatbuffers::Vector<flatbuffers::Offset<server::UserPresence>> *presences() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::UserPresence>> *>(VT_PRESENCES);
	}
	const server::UserPresence *self() const {
		return GetPointer<const server::UserPresence *>(VT_SELF);
	}
	const flatbuffers::Vector<flatbuffers::Offset<server::MatchmakeMatched_::UserProperty>> *properties() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::MatchmakeMatched_::UserProperty>> *>(VT_PROPERTIES);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_TICKET) &&
				verifier.VerifyString(ticket()) &&
				VerifyOffset(verifier, VT_TOKEN) &&
				verifier.VerifyString(token()) &&
				VerifyOffset(verifier, VT_PRESENCES) &&
				verifier.VerifyVector(presences()) &&
				verifier.VerifyVectorOfTables(presences()) &&
				VerifyOffset(verifier, VT_SELF) &&
				verifier.VerifyTable(self()) &&
				VerifyOffset(verifier, VT_PROPERTIES) &&
				verifier.VerifyVector(properties()) &&
				verifier.VerifyVectorOfTables(properties()) &&
				verifier.EndTable();
	}
	MatchmakeMatchedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(MatchmakeMatchedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<MatchmakeMatched> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatchmakeMatchedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct MatchmakeMatchedBuilder {
	typedef MatchmakeMatched Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_ticket(flatbuffers::Offset<flatbuffers::String> ticket) {
		fbb_.AddOffset(MatchmakeMatched::VT_TICKET, ticket);
	}
	void add_token(flatbuffers::Offset<flatbuffers::String> token) {
		fbb_.AddOffset(MatchmakeMatched::VT_TOKEN, token);
	}
	void add_presences(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::UserPresence>>> presences) {
		fbb_.AddOffset(MatchmakeMatched::VT_PRESENCES, presences);
	}
	void add_self(flatbuffers::Offset<server::UserPresence> self) {
		fbb_.AddOffset(MatchmakeMatched::VT_SELF, self);
	}
	void add_properties(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::MatchmakeMatched_::UserProperty>>> properties) {
		fbb_.AddOffset(MatchmakeMatched::VT_PROPERTIES, properties);
	}
	explicit MatchmakeMatchedBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<MatchmakeMatched> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<MatchmakeMatched>(end);
		return o;
	}
};

inline flatbuffers::Offset<MatchmakeMatched> CreateMatchmakeMatched(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> ticket = 0,
		flatbuffers::Offset<flatbuffers::String> token = 0,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::UserPresence>>> presences = 0,
		flatbuffers::Offset<server::UserPresence> self = 0,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::MatchmakeMatched_::UserProperty>>> properties = 0) {
	MatchmakeMatchedBuilder builder_(_fbb);
	builder_.add_properties(properties);
	builder_.add_self(self);
	builder_.add_presences(presences);
	builder_.add_token(token);
	builder_.add_ticket(ticket);
	return builder_.Finish();
}

inline flatbuffers::Offset<MatchmakeMatched> CreateMatchmakeMatchedDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *ticket = nullptr,
		const char *token = nullptr,
		const std::vector<flatbuffers::Offset<server::UserPresence>> *presences = nullptr,
		flatbuffers::Offset<server::UserPresence> self = 0,
		const std::vector<flatbuffers::Offset<server::MatchmakeMatched_::UserProperty>> *properties = nullptr) {
	auto ticket__ = ticket ? _fbb.CreateString(ticket) : 0;
	auto token__ = token ? _fbb.CreateString(token) : 0;
	auto presences__ = presences ? _fbb.CreateVector<flatbuffers::Offset<server::UserPresence>>(*presences) : 0;
	auto properties__ = properties ? _fbb.CreateVector<flatbuffers::Offset<server::MatchmakeMatched_::UserProperty>>(*properties) : 0;
	return server::CreateMatchmakeMatched(
			_fbb,
			ticket__,
			token__,
			presences__,
			self,
			properties__);
}

flatbuffers::Offset<MatchmakeMatched> CreateMatchmakeMatched(flatbuffers::FlatBufferBuilder &_fbb, const MatchmakeMatchedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace MatchmakeMatched_ {

struct UserPropertyT : public flatbuffers::NativeTable {
	typedef UserProperty TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.MatchmakeMatched_.UserPropertyT";
	}
	CharString user_id;
	std::vector<std::unique_ptr<server::PropertyPairT>> properties;
	std::vector<std::unique_ptr<server::MatchmakeFilterT>> filters;
	UserPropertyT() {
	}
};

/// Matched user presence and properties
struct UserProperty FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef UserPropertyT NativeTableType;
	typedef UserPropertyBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.MatchmakeMatched_.UserProperty";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_USER_ID = 4,
		VT_PROPERTIES = 6,
		VT_FILTERS = 8
	};
	const flatbuffers::String *user_id() const {
		return GetPointer<const flatbuffers::String *>(VT_USER_ID);
	}
	const flatbuffers::Vector<flatbuffers::Offset<server::PropertyPair>> *properties() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::PropertyPair>> *>(VT_PROPERTIES);
	}
	const flatbuffers::Vector<flatbuffers::Offset<server::MatchmakeFilter>> *filters() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::MatchmakeFilter>> *>(VT_FILTERS);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_USER_ID) &&
				verifier.VerifyString(user_id()) &&
				VerifyOffset(verifier, VT_PROPERTIES) &&
				verifier.VerifyVector(properties()) &&
				verifier.VerifyVectorOfTables(properties()) &&
				VerifyOffset(verifier, VT_FILTERS) &&
				verifier.VerifyVector(filters()) &&
				verifier.VerifyVectorOfTables(filters()) &&
				verifier.EndTable();
	}
	UserPropertyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(UserPropertyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<UserProperty> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UserPropertyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct UserPropertyBuilder {
	typedef UserProperty Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_user_id(flatbuffers::Offset<flatbuffers::String> user_id) {
		fbb_.AddOffset(UserProperty::VT_USER_ID, user_id);
	}
	void add_properties(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::PropertyPair>>> properties) {
		fbb_.AddOffset(UserProperty::VT_PROPERTIES, properties);
	}
	void add_filters(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::MatchmakeFilter>>> filters) {
		fbb_.AddOffset(UserProperty::VT_FILTERS, filters);
	}
	explicit UserPropertyBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<UserProperty> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<UserProperty>(end);
		return o;
	}
};

inline flatbuffers::Offset<UserProperty> CreateUserProperty(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> user_id = 0,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::PropertyPair>>> properties = 0,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::MatchmakeFilter>>> filters = 0) {
	UserPropertyBuilder builder_(_fbb);
	builder_.add_filters(filters);
	builder_.add_properties(properties);
	builder_.add_user_id(user_id);
	return builder_.Finish();
}

inline flatbuffers::Offset<UserProperty> CreateUserPropertyDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *user_id = nullptr,
		const std::vector<flatbuffers::Offset<server::PropertyPair>> *properties = nullptr,
		const std::vector<flatbuffers::Offset<server::MatchmakeFilter>> *filters = nullptr) {
	auto user_id__ = user_id ? _fbb.CreateString(user_id) : 0;
	auto properties__ = properties ? _fbb.CreateVector<flatbuffers::Offset<server::PropertyPair>>(*properties) : 0;
	auto filters__ = filters ? _fbb.CreateVector<flatbuffers::Offset<server::MatchmakeFilter>>(*filters) : 0;
	return server::MatchmakeMatched_::CreateUserProperty(
			_fbb,
			user_id__,
			properties__,
			filters__);
}

flatbuffers::Offset<UserProperty> CreateUserProperty(flatbuffers::FlatBufferBuilder &_fbb, const UserPropertyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

} // namespace MatchmakeMatched_

struct MatchT : public flatbuffers::NativeTable {
	typedef Match TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.MatchT";
	}
	CharString match_id;
	std::vector<std::unique_ptr<server::UserPresenceT>> presences;
	std::unique_ptr<server::UserPresenceT> self;
	MatchT() {
	}
};

struct Match FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef MatchT NativeTableType;
	typedef MatchBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.Match";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_MATCH_ID = 4,
		VT_PRESENCES = 6,
		VT_SELF = 8
	};
	const flatbuffers::String *match_id() const {
		return GetPointer<const flatbuffers::String *>(VT_MATCH_ID);
	}
	const flatbuffers::Vector<flatbuffers::Offset<server::UserPresence>> *presences() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::UserPresence>> *>(VT_PRESENCES);
	}
	const server::UserPresence *self() const {
		return GetPointer<const server::UserPresence *>(VT_SELF);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_MATCH_ID) &&
				verifier.VerifyString(match_id()) &&
				VerifyOffset(verifier, VT_PRESENCES) &&
				verifier.VerifyVector(presences()) &&
				verifier.VerifyVectorOfTables(presences()) &&
				VerifyOffset(verifier, VT_SELF) &&
				verifier.VerifyTable(self()) &&
				verifier.EndTable();
	}
	MatchT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(MatchT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<Match> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatchT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct MatchBuilder {
	typedef Match Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_match_id(flatbuffers::Offset<flatbuffers::String> match_id) {
		fbb_.AddOffset(Match::VT_MATCH_ID, match_id);
	}
	void add_presences(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::UserPresence>>> presences) {
		fbb_.AddOffset(Match::VT_PRESENCES, presences);
	}
	void add_self(flatbuffers::Offset<server::UserPresence> self) {
		fbb_.AddOffset(Match::VT_SELF, self);
	}
	explicit MatchBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<Match> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Match>(end);
		return o;
	}
};

inline flatbuffers::Offset<Match> CreateMatch(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> match_id = 0,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::UserPresence>>> presences = 0,
		flatbuffers::Offset<server::UserPresence> self = 0) {
	MatchBuilder builder_(_fbb);
	builder_.add_self(self);
	builder_.add_presences(presences);
	builder_.add_match_id(match_id);
	return builder_.Finish();
}

inline flatbuffers::Offset<Match> CreateMatchDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *match_id = nullptr,
		const std::vector<flatbuffers::Offset<server::UserPresence>> *presences = nullptr,
		flatbuffers::Offset<server::UserPresence> self = 0) {
	auto match_id__ = match_id ? _fbb.CreateString(match_id) : 0;
	auto presences__ = presences ? _fbb.CreateVector<flatbuffers::Offset<server::UserPresence>>(*presences) : 0;
	return server::CreateMatch(
			_fbb,
			match_id__,
			presences__,
			self);
}

flatbuffers::Offset<Match> CreateMatch(flatbuffers::FlatBufferBuilder &_fbb, const MatchT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MatchPresenceT : public flatbuffers::NativeTable {
	typedef MatchPresence TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.MatchPresenceT";
	}
	CharString match_id;
	std::vector<std::unique_ptr<server::UserPresenceT>> joins;
	std::vector<std::unique_ptr<server::UserPresenceT>> leaves;
	MatchPresenceT() {
	}
};

struct MatchPresence FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef MatchPresenceT NativeTableType;
	typedef MatchPresenceBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.MatchPresence";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_MATCH_ID = 4,
		VT_JOINS = 6,
		VT_LEAVES = 8
	};
	const flatbuffers::String *match_id() const {
		return GetPointer<const flatbuffers::String *>(VT_MATCH_ID);
	}
	const flatbuffers::Vector<flatbuffers::Offset<server::UserPresence>> *joins() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::UserPresence>> *>(VT_JOINS);
	}
	const flatbuffers::Vector<flatbuffers::Offset<server::UserPresence>> *leaves() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::UserPresence>> *>(VT_LEAVES);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_MATCH_ID) &&
				verifier.VerifyString(match_id()) &&
				VerifyOffset(verifier, VT_JOINS) &&
				verifier.VerifyVector(joins()) &&
				verifier.VerifyVectorOfTables(joins()) &&
				VerifyOffset(verifier, VT_LEAVES) &&
				verifier.VerifyVector(leaves()) &&
				verifier.VerifyVectorOfTables(leaves()) &&
				verifier.EndTable();
	}
	MatchPresenceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(MatchPresenceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<MatchPresence> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatchPresenceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct MatchPresenceBuilder {
	typedef MatchPresence Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_match_id(flatbuffers::Offset<flatbuffers::String> match_id) {
		fbb_.AddOffset(MatchPresence::VT_MATCH_ID, match_id);
	}
	void add_joins(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::UserPresence>>> joins) {
		fbb_.AddOffset(MatchPresence::VT_JOINS, joins);
	}
	void add_leaves(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::UserPresence>>> leaves) {
		fbb_.AddOffset(MatchPresence::VT_LEAVES, leaves);
	}
	explicit MatchPresenceBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<MatchPresence> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<MatchPresence>(end);
		return o;
	}
};

inline flatbuffers::Offset<MatchPresence> CreateMatchPresence(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> match_id = 0,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::UserPresence>>> joins = 0,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::UserPresence>>> leaves = 0) {
	MatchPresenceBuilder builder_(_fbb);
	builder_.add_leaves(leaves);
	builder_.add_joins(joins);
	builder_.add_match_id(match_id);
	return builder_.Finish();
}

inline flatbuffers::Offset<MatchPresence> CreateMatchPresenceDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *match_id = nullptr,
		const std::vector<flatbuffers::Offset<server::UserPresence>> *joins = nullptr,
		const std::vector<flatbuffers::Offset<server::UserPresence>> *leaves = nullptr) {
	auto match_id__ = match_id ? _fbb.CreateString(match_id) : 0;
	auto joins__ = joins ? _fbb.CreateVector<flatbuffers::Offset<server::UserPresence>>(*joins) : 0;
	auto leaves__ = leaves ? _fbb.CreateVector<flatbuffers::Offset<server::UserPresence>>(*leaves) : 0;
	return server::CreateMatchPresence(
			_fbb,
			match_id__,
			joins__,
			leaves__);
}

flatbuffers::Offset<MatchPresence> CreateMatchPresence(flatbuffers::FlatBufferBuilder &_fbb, const MatchPresenceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TMatchCreateT : public flatbuffers::NativeTable {
	typedef TMatchCreate TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TMatchCreateT";
	}
	TMatchCreateT() {
	}
};

struct TMatchCreate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TMatchCreateT NativeTableType;
	typedef TMatchCreateBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TMatchCreate";
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				verifier.EndTable();
	}
	TMatchCreateT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TMatchCreateT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TMatchCreate> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TMatchCreateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TMatchCreateBuilder {
	typedef TMatchCreate Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	explicit TMatchCreateBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TMatchCreate> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TMatchCreate>(end);
		return o;
	}
};

inline flatbuffers::Offset<TMatchCreate> CreateTMatchCreate(
		flatbuffers::FlatBufferBuilder &_fbb) {
	TMatchCreateBuilder builder_(_fbb);
	return builder_.Finish();
}

flatbuffers::Offset<TMatchCreate> CreateTMatchCreate(flatbuffers::FlatBufferBuilder &_fbb, const TMatchCreateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TMatchT : public flatbuffers::NativeTable {
	typedef TMatch TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TMatchT";
	}
	std::unique_ptr<server::MatchT> match;
	TMatchT() {
	}
};

struct TMatch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TMatchT NativeTableType;
	typedef TMatchBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TMatch";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_MATCH = 4
	};
	const server::Match *match() const {
		return GetPointer<const server::Match *>(VT_MATCH);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_MATCH) &&
				verifier.VerifyTable(match()) &&
				verifier.EndTable();
	}
	TMatchT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TMatchT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TMatch> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TMatchT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TMatchBuilder {
	typedef TMatch Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_match(flatbuffers::Offset<server::Match> match) {
		fbb_.AddOffset(TMatch::VT_MATCH, match);
	}
	explicit TMatchBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TMatch> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TMatch>(end);
		return o;
	}
};

inline flatbuffers::Offset<TMatch> CreateTMatch(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<server::Match> match = 0) {
	TMatchBuilder builder_(_fbb);
	builder_.add_match(match);
	return builder_.Finish();
}

flatbuffers::Offset<TMatch> CreateTMatch(flatbuffers::FlatBufferBuilder &_fbb, const TMatchT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TMatchesJoinT : public flatbuffers::NativeTable {
	typedef TMatchesJoin TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TMatchesJoinT";
	}
	std::vector<std::unique_ptr<server::TMatchesJoin_::MatchJoinT>> matches;
	TMatchesJoinT() {
	}
};

struct TMatchesJoin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TMatchesJoinT NativeTableType;
	typedef TMatchesJoinBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TMatchesJoin";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_MATCHES = 4
	};
	const flatbuffers::Vector<flatbuffers::Offset<server::TMatchesJoin_::MatchJoin>> *matches() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::TMatchesJoin_::MatchJoin>> *>(VT_MATCHES);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_MATCHES) &&
				verifier.VerifyVector(matches()) &&
				verifier.VerifyVectorOfTables(matches()) &&
				verifier.EndTable();
	}
	TMatchesJoinT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TMatchesJoinT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TMatchesJoin> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TMatchesJoinT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TMatchesJoinBuilder {
	typedef TMatchesJoin Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_matches(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TMatchesJoin_::MatchJoin>>> matches) {
		fbb_.AddOffset(TMatchesJoin::VT_MATCHES, matches);
	}
	explicit TMatchesJoinBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TMatchesJoin> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TMatchesJoin>(end);
		return o;
	}
};

inline flatbuffers::Offset<TMatchesJoin> CreateTMatchesJoin(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TMatchesJoin_::MatchJoin>>> matches = 0) {
	TMatchesJoinBuilder builder_(_fbb);
	builder_.add_matches(matches);
	return builder_.Finish();
}

inline flatbuffers::Offset<TMatchesJoin> CreateTMatchesJoinDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<server::TMatchesJoin_::MatchJoin>> *matches = nullptr) {
	auto matches__ = matches ? _fbb.CreateVector<flatbuffers::Offset<server::TMatchesJoin_::MatchJoin>>(*matches) : 0;
	return server::CreateTMatchesJoin(
			_fbb,
			matches__);
}

flatbuffers::Offset<TMatchesJoin> CreateTMatchesJoin(flatbuffers::FlatBufferBuilder &_fbb, const TMatchesJoinT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace TMatchesJoin_ {

struct MatchJoinT : public flatbuffers::NativeTable {
	typedef MatchJoin TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TMatchesJoin_.MatchJoinT";
	}
	std::unique_ptr<server::TMatchesJoin_::MatchJoin_::AuthenticateResult4T> id;
	MatchJoinT() {
	}
};

struct MatchJoin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef MatchJoinT NativeTableType;
	typedef MatchJoinBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TMatchesJoin_.MatchJoin";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_ID = 4
	};
	const server::TMatchesJoin_::MatchJoin_::AuthenticateResult4 *id() const {
		return GetPointer<const server::TMatchesJoin_::MatchJoin_::AuthenticateResult4 *>(VT_ID);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_ID) &&
				verifier.VerifyTable(id()) &&
				verifier.EndTable();
	}
	MatchJoinT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(MatchJoinT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<MatchJoin> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatchJoinT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct MatchJoinBuilder {
	typedef MatchJoin Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_id(flatbuffers::Offset<server::TMatchesJoin_::MatchJoin_::AuthenticateResult4> id) {
		fbb_.AddOffset(MatchJoin::VT_ID, id);
	}
	explicit MatchJoinBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<MatchJoin> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<MatchJoin>(end);
		return o;
	}
};

inline flatbuffers::Offset<MatchJoin> CreateMatchJoin(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<server::TMatchesJoin_::MatchJoin_::AuthenticateResult4> id = 0) {
	MatchJoinBuilder builder_(_fbb);
	builder_.add_id(id);
	return builder_.Finish();
}

flatbuffers::Offset<MatchJoin> CreateMatchJoin(flatbuffers::FlatBufferBuilder &_fbb, const MatchJoinT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace MatchJoin_ {

struct AuthenticateResult4T : public flatbuffers::NativeTable {
	typedef AuthenticateResult4 TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TMatchesJoin_.MatchJoin_.AuthenticateResult4T";
	}
	CharString match_id;
	CharString token;
	AuthenticateResult4T() {
	}
};

struct AuthenticateResult4 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef AuthenticateResult4T NativeTableType;
	typedef AuthenticateResult4Builder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TMatchesJoin_.MatchJoin_.AuthenticateResult4";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_MATCH_ID = 4,
		VT_TOKEN = 6
	};
	const flatbuffers::String *match_id() const {
		return GetPointer<const flatbuffers::String *>(VT_MATCH_ID);
	}
	const flatbuffers::String *token() const {
		return GetPointer<const flatbuffers::String *>(VT_TOKEN);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_MATCH_ID) &&
				verifier.VerifyString(match_id()) &&
				VerifyOffset(verifier, VT_TOKEN) &&
				verifier.VerifyString(token()) &&
				verifier.EndTable();
	}
	AuthenticateResult4T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(AuthenticateResult4T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<AuthenticateResult4> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateResult4T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct AuthenticateResult4Builder {
	typedef AuthenticateResult4 Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_match_id(flatbuffers::Offset<flatbuffers::String> match_id) {
		fbb_.AddOffset(AuthenticateResult4::VT_MATCH_ID, match_id);
	}
	void add_token(flatbuffers::Offset<flatbuffers::String> token) {
		fbb_.AddOffset(AuthenticateResult4::VT_TOKEN, token);
	}
	explicit AuthenticateResult4Builder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<AuthenticateResult4> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<AuthenticateResult4>(end);
		return o;
	}
};

inline flatbuffers::Offset<AuthenticateResult4> CreateAuthenticateResult4(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> match_id = 0,
		flatbuffers::Offset<flatbuffers::String> token = 0) {
	AuthenticateResult4Builder builder_(_fbb);
	builder_.add_token(token);
	builder_.add_match_id(match_id);
	return builder_.Finish();
}

inline flatbuffers::Offset<AuthenticateResult4> CreateAuthenticateResult4Direct(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *match_id = nullptr,
		const char *token = nullptr) {
	auto match_id__ = match_id ? _fbb.CreateString(match_id) : 0;
	auto token__ = token ? _fbb.CreateString(token) : 0;
	return server::TMatchesJoin_::MatchJoin_::CreateAuthenticateResult4(
			_fbb,
			match_id__,
			token__);
}

flatbuffers::Offset<AuthenticateResult4> CreateAuthenticateResult4(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateResult4T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

} // namespace MatchJoin_
} // namespace TMatchesJoin_

struct TMatchesT : public flatbuffers::NativeTable {
	typedef TMatches TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TMatchesT";
	}
	std::vector<std::unique_ptr<server::MatchT>> matches;
	TMatchesT() {
	}
};

struct TMatches FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TMatchesT NativeTableType;
	typedef TMatchesBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TMatches";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_MATCHES = 4
	};
	const flatbuffers::Vector<flatbuffers::Offset<server::Match>> *matches() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::Match>> *>(VT_MATCHES);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_MATCHES) &&
				verifier.VerifyVector(matches()) &&
				verifier.VerifyVectorOfTables(matches()) &&
				verifier.EndTable();
	}
	TMatchesT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TMatchesT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TMatches> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TMatchesT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TMatchesBuilder {
	typedef TMatches Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_matches(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::Match>>> matches) {
		fbb_.AddOffset(TMatches::VT_MATCHES, matches);
	}
	explicit TMatchesBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TMatches> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TMatches>(end);
		return o;
	}
};

inline flatbuffers::Offset<TMatches> CreateTMatches(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::Match>>> matches = 0) {
	TMatchesBuilder builder_(_fbb);
	builder_.add_matches(matches);
	return builder_.Finish();
}

inline flatbuffers::Offset<TMatches> CreateTMatchesDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<server::Match>> *matches = nullptr) {
	auto matches__ = matches ? _fbb.CreateVector<flatbuffers::Offset<server::Match>>(*matches) : 0;
	return server::CreateTMatches(
			_fbb,
			matches__);
}

flatbuffers::Offset<TMatches> CreateTMatches(flatbuffers::FlatBufferBuilder &_fbb, const TMatchesT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MatchDataSendT : public flatbuffers::NativeTable {
	typedef MatchDataSend TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.MatchDataSendT";
	}
	CharString match_id;
	int64_t op_code;
	std::vector<uint8_t> data;
	std::vector<std::unique_ptr<server::UserPresenceT>> presences;
	MatchDataSendT() :
			op_code(0) {
	}
};

struct MatchDataSend FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef MatchDataSendT NativeTableType;
	typedef MatchDataSendBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.MatchDataSend";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_MATCH_ID = 4,
		VT_OP_CODE = 6,
		VT_DATA = 8,
		VT_PRESENCES = 10
	};
	const flatbuffers::String *match_id() const {
		return GetPointer<const flatbuffers::String *>(VT_MATCH_ID);
	}
	/// Custom Op code to make disguishing different message types easier.
	int64_t op_code() const {
		return GetField<int64_t>(VT_OP_CODE, 0);
	}
	const flatbuffers::Vector<uint8_t> *data() const {
		return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
	}
	const flatbuffers::Vector<flatbuffers::Offset<server::UserPresence>> *presences() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::UserPresence>> *>(VT_PRESENCES);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_MATCH_ID) &&
				verifier.VerifyString(match_id()) &&
				VerifyField<int64_t>(verifier, VT_OP_CODE) &&
				VerifyOffset(verifier, VT_DATA) &&
				verifier.VerifyVector(data()) &&
				VerifyOffset(verifier, VT_PRESENCES) &&
				verifier.VerifyVector(presences()) &&
				verifier.VerifyVectorOfTables(presences()) &&
				verifier.EndTable();
	}
	MatchDataSendT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(MatchDataSendT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<MatchDataSend> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatchDataSendT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct MatchDataSendBuilder {
	typedef MatchDataSend Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_match_id(flatbuffers::Offset<flatbuffers::String> match_id) {
		fbb_.AddOffset(MatchDataSend::VT_MATCH_ID, match_id);
	}
	void add_op_code(int64_t op_code) {
		fbb_.AddElement<int64_t>(MatchDataSend::VT_OP_CODE, op_code, 0);
	}
	void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
		fbb_.AddOffset(MatchDataSend::VT_DATA, data);
	}
	void add_presences(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::UserPresence>>> presences) {
		fbb_.AddOffset(MatchDataSend::VT_PRESENCES, presences);
	}
	explicit MatchDataSendBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<MatchDataSend> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<MatchDataSend>(end);
		return o;
	}
};

inline flatbuffers::Offset<MatchDataSend> CreateMatchDataSend(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> match_id = 0,
		int64_t op_code = 0,
		flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::UserPresence>>> presences = 0) {
	MatchDataSendBuilder builder_(_fbb);
	builder_.add_op_code(op_code);
	builder_.add_presences(presences);
	builder_.add_data(data);
	builder_.add_match_id(match_id);
	return builder_.Finish();
}

inline flatbuffers::Offset<MatchDataSend> CreateMatchDataSendDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *match_id = nullptr,
		int64_t op_code = 0,
		const std::vector<uint8_t> *data = nullptr,
		const std::vector<flatbuffers::Offset<server::UserPresence>> *presences = nullptr) {
	auto match_id__ = match_id ? _fbb.CreateString(match_id) : 0;
	auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
	auto presences__ = presences ? _fbb.CreateVector<flatbuffers::Offset<server::UserPresence>>(*presences) : 0;
	return server::CreateMatchDataSend(
			_fbb,
			match_id__,
			op_code,
			data__,
			presences__);
}

flatbuffers::Offset<MatchDataSend> CreateMatchDataSend(flatbuffers::FlatBufferBuilder &_fbb, const MatchDataSendT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MatchDataT : public flatbuffers::NativeTable {
	typedef MatchData TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.MatchDataT";
	}
	CharString match_id;
	std::unique_ptr<server::UserPresenceT> presence;
	int64_t op_code;
	std::vector<uint8_t> data;
	MatchDataT() :
			op_code(0) {
	}
};

struct MatchData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef MatchDataT NativeTableType;
	typedef MatchDataBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.MatchData";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_MATCH_ID = 4,
		VT_PRESENCE = 6,
		VT_OP_CODE = 8,
		VT_DATA = 10
	};
	const flatbuffers::String *match_id() const {
		return GetPointer<const flatbuffers::String *>(VT_MATCH_ID);
	}
	const server::UserPresence *presence() const {
		return GetPointer<const server::UserPresence *>(VT_PRESENCE);
	}
	int64_t op_code() const {
		return GetField<int64_t>(VT_OP_CODE, 0);
	}
	const flatbuffers::Vector<uint8_t> *data() const {
		return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_MATCH_ID) &&
				verifier.VerifyString(match_id()) &&
				VerifyOffset(verifier, VT_PRESENCE) &&
				verifier.VerifyTable(presence()) &&
				VerifyField<int64_t>(verifier, VT_OP_CODE) &&
				VerifyOffset(verifier, VT_DATA) &&
				verifier.VerifyVector(data()) &&
				verifier.EndTable();
	}
	MatchDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(MatchDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<MatchData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatchDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct MatchDataBuilder {
	typedef MatchData Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_match_id(flatbuffers::Offset<flatbuffers::String> match_id) {
		fbb_.AddOffset(MatchData::VT_MATCH_ID, match_id);
	}
	void add_presence(flatbuffers::Offset<server::UserPresence> presence) {
		fbb_.AddOffset(MatchData::VT_PRESENCE, presence);
	}
	void add_op_code(int64_t op_code) {
		fbb_.AddElement<int64_t>(MatchData::VT_OP_CODE, op_code, 0);
	}
	void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
		fbb_.AddOffset(MatchData::VT_DATA, data);
	}
	explicit MatchDataBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<MatchData> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<MatchData>(end);
		return o;
	}
};

inline flatbuffers::Offset<MatchData> CreateMatchData(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> match_id = 0,
		flatbuffers::Offset<server::UserPresence> presence = 0,
		int64_t op_code = 0,
		flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
	MatchDataBuilder builder_(_fbb);
	builder_.add_op_code(op_code);
	builder_.add_data(data);
	builder_.add_presence(presence);
	builder_.add_match_id(match_id);
	return builder_.Finish();
}

inline flatbuffers::Offset<MatchData> CreateMatchDataDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *match_id = nullptr,
		flatbuffers::Offset<server::UserPresence> presence = 0,
		int64_t op_code = 0,
		const std::vector<uint8_t> *data = nullptr) {
	auto match_id__ = match_id ? _fbb.CreateString(match_id) : 0;
	auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
	return server::CreateMatchData(
			_fbb,
			match_id__,
			presence,
			op_code,
			data__);
}

flatbuffers::Offset<MatchData> CreateMatchData(flatbuffers::FlatBufferBuilder &_fbb, const MatchDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TMatchesLeaveT : public flatbuffers::NativeTable {
	typedef TMatchesLeave TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TMatchesLeaveT";
	}
	std::vector<CharString> match_ids;
	TMatchesLeaveT() {
	}
};

struct TMatchesLeave FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TMatchesLeaveT NativeTableType;
	typedef TMatchesLeaveBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TMatchesLeave";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_MATCH_IDS = 4
	};
	const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *match_ids() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_MATCH_IDS);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_MATCH_IDS) &&
				verifier.VerifyVector(match_ids()) &&
				verifier.VerifyVectorOfStrings(match_ids()) &&
				verifier.EndTable();
	}
	TMatchesLeaveT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TMatchesLeaveT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TMatchesLeave> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TMatchesLeaveT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TMatchesLeaveBuilder {
	typedef TMatchesLeave Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_match_ids(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> match_ids) {
		fbb_.AddOffset(TMatchesLeave::VT_MATCH_IDS, match_ids);
	}
	explicit TMatchesLeaveBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TMatchesLeave> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TMatchesLeave>(end);
		return o;
	}
};

inline flatbuffers::Offset<TMatchesLeave> CreateTMatchesLeave(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> match_ids = 0) {
	TMatchesLeaveBuilder builder_(_fbb);
	builder_.add_match_ids(match_ids);
	return builder_.Finish();
}

inline flatbuffers::Offset<TMatchesLeave> CreateTMatchesLeaveDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<flatbuffers::String>> *match_ids = nullptr) {
	auto match_ids__ = match_ids ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*match_ids) : 0;
	return server::CreateTMatchesLeave(
			_fbb,
			match_ids__);
}

flatbuffers::Offset<TMatchesLeave> CreateTMatchesLeave(flatbuffers::FlatBufferBuilder &_fbb, const TMatchesLeaveT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TStorageListT : public flatbuffers::NativeTable {
	typedef TStorageList TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TStorageListT";
	}
	CharString user_id;
	CharString bucket;
	CharString collection;
	int64_t limit;
	CharString cursor;
	TStorageListT() :
			limit(0) {
	}
};

struct TStorageList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TStorageListT NativeTableType;
	typedef TStorageListBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TStorageList";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_USER_ID = 4,
		VT_BUCKET = 6,
		VT_COLLECTION = 8,
		VT_LIMIT = 10,
		VT_CURSOR = 12
	};
	const flatbuffers::String *user_id() const {
		return GetPointer<const flatbuffers::String *>(VT_USER_ID);
	}
	const flatbuffers::String *bucket() const {
		return GetPointer<const flatbuffers::String *>(VT_BUCKET);
	}
	const flatbuffers::String *collection() const {
		return GetPointer<const flatbuffers::String *>(VT_COLLECTION);
	}
	int64_t limit() const {
		return GetField<int64_t>(VT_LIMIT, 0);
	}
	const flatbuffers::String *cursor() const {
		return GetPointer<const flatbuffers::String *>(VT_CURSOR);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_USER_ID) &&
				verifier.VerifyString(user_id()) &&
				VerifyOffset(verifier, VT_BUCKET) &&
				verifier.VerifyString(bucket()) &&
				VerifyOffset(verifier, VT_COLLECTION) &&
				verifier.VerifyString(collection()) &&
				VerifyField<int64_t>(verifier, VT_LIMIT) &&
				VerifyOffset(verifier, VT_CURSOR) &&
				verifier.VerifyString(cursor()) &&
				verifier.EndTable();
	}
	TStorageListT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TStorageListT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TStorageList> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TStorageListT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TStorageListBuilder {
	typedef TStorageList Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_user_id(flatbuffers::Offset<flatbuffers::String> user_id) {
		fbb_.AddOffset(TStorageList::VT_USER_ID, user_id);
	}
	void add_bucket(flatbuffers::Offset<flatbuffers::String> bucket) {
		fbb_.AddOffset(TStorageList::VT_BUCKET, bucket);
	}
	void add_collection(flatbuffers::Offset<flatbuffers::String> collection) {
		fbb_.AddOffset(TStorageList::VT_COLLECTION, collection);
	}
	void add_limit(int64_t limit) {
		fbb_.AddElement<int64_t>(TStorageList::VT_LIMIT, limit, 0);
	}
	void add_cursor(flatbuffers::Offset<flatbuffers::String> cursor) {
		fbb_.AddOffset(TStorageList::VT_CURSOR, cursor);
	}
	explicit TStorageListBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TStorageList> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TStorageList>(end);
		return o;
	}
};

inline flatbuffers::Offset<TStorageList> CreateTStorageList(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> user_id = 0,
		flatbuffers::Offset<flatbuffers::String> bucket = 0,
		flatbuffers::Offset<flatbuffers::String> collection = 0,
		int64_t limit = 0,
		flatbuffers::Offset<flatbuffers::String> cursor = 0) {
	TStorageListBuilder builder_(_fbb);
	builder_.add_limit(limit);
	builder_.add_cursor(cursor);
	builder_.add_collection(collection);
	builder_.add_bucket(bucket);
	builder_.add_user_id(user_id);
	return builder_.Finish();
}

inline flatbuffers::Offset<TStorageList> CreateTStorageListDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *user_id = nullptr,
		const char *bucket = nullptr,
		const char *collection = nullptr,
		int64_t limit = 0,
		const char *cursor = nullptr) {
	auto user_id__ = user_id ? _fbb.CreateString(user_id) : 0;
	auto bucket__ = bucket ? _fbb.CreateString(bucket) : 0;
	auto collection__ = collection ? _fbb.CreateString(collection) : 0;
	auto cursor__ = cursor ? _fbb.CreateString(cursor) : 0;
	return server::CreateTStorageList(
			_fbb,
			user_id__,
			bucket__,
			collection__,
			limit,
			cursor__);
}

flatbuffers::Offset<TStorageList> CreateTStorageList(flatbuffers::FlatBufferBuilder &_fbb, const TStorageListT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TStorageFetchT : public flatbuffers::NativeTable {
	typedef TStorageFetch TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TStorageFetchT";
	}
	std::vector<std::unique_ptr<server::TStorageFetch_::StorageKeyT>> keys;
	TStorageFetchT() {
	}
};

struct TStorageFetch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TStorageFetchT NativeTableType;
	typedef TStorageFetchBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TStorageFetch";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_KEYS = 4
	};
	const flatbuffers::Vector<flatbuffers::Offset<server::TStorageFetch_::StorageKey>> *keys() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::TStorageFetch_::StorageKey>> *>(VT_KEYS);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_KEYS) &&
				verifier.VerifyVector(keys()) &&
				verifier.VerifyVectorOfTables(keys()) &&
				verifier.EndTable();
	}
	TStorageFetchT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TStorageFetchT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TStorageFetch> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TStorageFetchT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TStorageFetchBuilder {
	typedef TStorageFetch Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_keys(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TStorageFetch_::StorageKey>>> keys) {
		fbb_.AddOffset(TStorageFetch::VT_KEYS, keys);
	}
	explicit TStorageFetchBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TStorageFetch> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TStorageFetch>(end);
		return o;
	}
};

inline flatbuffers::Offset<TStorageFetch> CreateTStorageFetch(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TStorageFetch_::StorageKey>>> keys = 0) {
	TStorageFetchBuilder builder_(_fbb);
	builder_.add_keys(keys);
	return builder_.Finish();
}

inline flatbuffers::Offset<TStorageFetch> CreateTStorageFetchDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<server::TStorageFetch_::StorageKey>> *keys = nullptr) {
	auto keys__ = keys ? _fbb.CreateVector<flatbuffers::Offset<server::TStorageFetch_::StorageKey>>(*keys) : 0;
	return server::CreateTStorageFetch(
			_fbb,
			keys__);
}

flatbuffers::Offset<TStorageFetch> CreateTStorageFetch(flatbuffers::FlatBufferBuilder &_fbb, const TStorageFetchT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace TStorageFetch_ {

struct StorageKeyT : public flatbuffers::NativeTable {
	typedef StorageKey TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TStorageFetch_.StorageKeyT";
	}
	CharString bucket;
	CharString collection;
	CharString record;
	CharString user_id;
	StorageKeyT() {
	}
};

struct StorageKey FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef StorageKeyT NativeTableType;
	typedef StorageKeyBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TStorageFetch_.StorageKey";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_BUCKET = 4,
		VT_COLLECTION = 6,
		VT_RECORD = 8,
		VT_USER_ID = 10
	};
	const flatbuffers::String *bucket() const {
		return GetPointer<const flatbuffers::String *>(VT_BUCKET);
	}
	const flatbuffers::String *collection() const {
		return GetPointer<const flatbuffers::String *>(VT_COLLECTION);
	}
	const flatbuffers::String *record() const {
		return GetPointer<const flatbuffers::String *>(VT_RECORD);
	}
	const flatbuffers::String *user_id() const {
		return GetPointer<const flatbuffers::String *>(VT_USER_ID);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_BUCKET) &&
				verifier.VerifyString(bucket()) &&
				VerifyOffset(verifier, VT_COLLECTION) &&
				verifier.VerifyString(collection()) &&
				VerifyOffset(verifier, VT_RECORD) &&
				verifier.VerifyString(record()) &&
				VerifyOffset(verifier, VT_USER_ID) &&
				verifier.VerifyString(user_id()) &&
				verifier.EndTable();
	}
	StorageKeyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(StorageKeyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<StorageKey> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StorageKeyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct StorageKeyBuilder {
	typedef StorageKey Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_bucket(flatbuffers::Offset<flatbuffers::String> bucket) {
		fbb_.AddOffset(StorageKey::VT_BUCKET, bucket);
	}
	void add_collection(flatbuffers::Offset<flatbuffers::String> collection) {
		fbb_.AddOffset(StorageKey::VT_COLLECTION, collection);
	}
	void add_record(flatbuffers::Offset<flatbuffers::String> record) {
		fbb_.AddOffset(StorageKey::VT_RECORD, record);
	}
	void add_user_id(flatbuffers::Offset<flatbuffers::String> user_id) {
		fbb_.AddOffset(StorageKey::VT_USER_ID, user_id);
	}
	explicit StorageKeyBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<StorageKey> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<StorageKey>(end);
		return o;
	}
};

inline flatbuffers::Offset<StorageKey> CreateStorageKey(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> bucket = 0,
		flatbuffers::Offset<flatbuffers::String> collection = 0,
		flatbuffers::Offset<flatbuffers::String> record = 0,
		flatbuffers::Offset<flatbuffers::String> user_id = 0) {
	StorageKeyBuilder builder_(_fbb);
	builder_.add_user_id(user_id);
	builder_.add_record(record);
	builder_.add_collection(collection);
	builder_.add_bucket(bucket);
	return builder_.Finish();
}

inline flatbuffers::Offset<StorageKey> CreateStorageKeyDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *bucket = nullptr,
		const char *collection = nullptr,
		const char *record = nullptr,
		const char *user_id = nullptr) {
	auto bucket__ = bucket ? _fbb.CreateString(bucket) : 0;
	auto collection__ = collection ? _fbb.CreateString(collection) : 0;
	auto record__ = record ? _fbb.CreateString(record) : 0;
	auto user_id__ = user_id ? _fbb.CreateString(user_id) : 0;
	return server::TStorageFetch_::CreateStorageKey(
			_fbb,
			bucket__,
			collection__,
			record__,
			user_id__);
}

flatbuffers::Offset<StorageKey> CreateStorageKey(flatbuffers::FlatBufferBuilder &_fbb, const StorageKeyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

} // namespace TStorageFetch_

struct TStorageDataT : public flatbuffers::NativeTable {
	typedef TStorageData TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TStorageDataT";
	}
	std::vector<std::unique_ptr<server::TStorageData_::StorageDataT>> data;
	CharString cursor;
	TStorageDataT() {
	}
};

struct TStorageData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TStorageDataT NativeTableType;
	typedef TStorageDataBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TStorageData";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_DATA = 4,
		VT_CURSOR = 6
	};
	const flatbuffers::Vector<flatbuffers::Offset<server::TStorageData_::StorageData>> *data() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::TStorageData_::StorageData>> *>(VT_DATA);
	}
	const flatbuffers::String *cursor() const {
		return GetPointer<const flatbuffers::String *>(VT_CURSOR);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_DATA) &&
				verifier.VerifyVector(data()) &&
				verifier.VerifyVectorOfTables(data()) &&
				VerifyOffset(verifier, VT_CURSOR) &&
				verifier.VerifyString(cursor()) &&
				verifier.EndTable();
	}
	TStorageDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TStorageDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TStorageData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TStorageDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TStorageDataBuilder {
	typedef TStorageData Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TStorageData_::StorageData>>> data) {
		fbb_.AddOffset(TStorageData::VT_DATA, data);
	}
	void add_cursor(flatbuffers::Offset<flatbuffers::String> cursor) {
		fbb_.AddOffset(TStorageData::VT_CURSOR, cursor);
	}
	explicit TStorageDataBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TStorageData> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TStorageData>(end);
		return o;
	}
};

inline flatbuffers::Offset<TStorageData> CreateTStorageData(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TStorageData_::StorageData>>> data = 0,
		flatbuffers::Offset<flatbuffers::String> cursor = 0) {
	TStorageDataBuilder builder_(_fbb);
	builder_.add_cursor(cursor);
	builder_.add_data(data);
	return builder_.Finish();
}

inline flatbuffers::Offset<TStorageData> CreateTStorageDataDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<server::TStorageData_::StorageData>> *data = nullptr,
		const char *cursor = nullptr) {
	auto data__ = data ? _fbb.CreateVector<flatbuffers::Offset<server::TStorageData_::StorageData>>(*data) : 0;
	auto cursor__ = cursor ? _fbb.CreateString(cursor) : 0;
	return server::CreateTStorageData(
			_fbb,
			data__,
			cursor__);
}

flatbuffers::Offset<TStorageData> CreateTStorageData(flatbuffers::FlatBufferBuilder &_fbb, const TStorageDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace TStorageData_ {

struct StorageDataT : public flatbuffers::NativeTable {
	typedef StorageData TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TStorageData_.StorageDataT";
	}
	CharString bucket;
	CharString collection;
	CharString record;
	CharString user_id;
	CharString value;
	CharString version;
	int32_t permission_read;
	int32_t permission_write;
	int64_t created_at;
	int64_t updated_at;
	int64_t expires_at;
	StorageDataT() :
			permission_read(0),
			permission_write(0),
			created_at(0),
			updated_at(0),
			expires_at(0) {
	}
};

struct StorageData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef StorageDataT NativeTableType;
	typedef StorageDataBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TStorageData_.StorageData";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_BUCKET = 4,
		VT_COLLECTION = 6,
		VT_RECORD = 8,
		VT_USER_ID = 10,
		VT_VALUE = 12,
		VT_VERSION = 14,
		VT_PERMISSION_READ = 16,
		VT_PERMISSION_WRITE = 18,
		VT_CREATED_AT = 20,
		VT_UPDATED_AT = 22,
		VT_EXPIRES_AT = 24
	};
	const flatbuffers::String *bucket() const {
		return GetPointer<const flatbuffers::String *>(VT_BUCKET);
	}
	const flatbuffers::String *collection() const {
		return GetPointer<const flatbuffers::String *>(VT_COLLECTION);
	}
	const flatbuffers::String *record() const {
		return GetPointer<const flatbuffers::String *>(VT_RECORD);
	}
	const flatbuffers::String *user_id() const {
		return GetPointer<const flatbuffers::String *>(VT_USER_ID);
	}
	const flatbuffers::String *value() const {
		return GetPointer<const flatbuffers::String *>(VT_VALUE);
	}
	const flatbuffers::String *version() const {
		return GetPointer<const flatbuffers::String *>(VT_VERSION);
	}
	int32_t permission_read() const {
		return GetField<int32_t>(VT_PERMISSION_READ, 0);
	}
	int32_t permission_write() const {
		return GetField<int32_t>(VT_PERMISSION_WRITE, 0);
	}
	int64_t created_at() const {
		return GetField<int64_t>(VT_CREATED_AT, 0);
	}
	int64_t updated_at() const {
		return GetField<int64_t>(VT_UPDATED_AT, 0);
	}
	int64_t expires_at() const {
		return GetField<int64_t>(VT_EXPIRES_AT, 0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_BUCKET) &&
				verifier.VerifyString(bucket()) &&
				VerifyOffset(verifier, VT_COLLECTION) &&
				verifier.VerifyString(collection()) &&
				VerifyOffset(verifier, VT_RECORD) &&
				verifier.VerifyString(record()) &&
				VerifyOffset(verifier, VT_USER_ID) &&
				verifier.VerifyString(user_id()) &&
				VerifyOffset(verifier, VT_VALUE) &&
				verifier.VerifyString(value()) &&
				VerifyOffset(verifier, VT_VERSION) &&
				verifier.VerifyString(version()) &&
				VerifyField<int32_t>(verifier, VT_PERMISSION_READ) &&
				VerifyField<int32_t>(verifier, VT_PERMISSION_WRITE) &&
				VerifyField<int64_t>(verifier, VT_CREATED_AT) &&
				VerifyField<int64_t>(verifier, VT_UPDATED_AT) &&
				VerifyField<int64_t>(verifier, VT_EXPIRES_AT) &&
				verifier.EndTable();
	}
	StorageDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(StorageDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<StorageData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StorageDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct StorageDataBuilder {
	typedef StorageData Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_bucket(flatbuffers::Offset<flatbuffers::String> bucket) {
		fbb_.AddOffset(StorageData::VT_BUCKET, bucket);
	}
	void add_collection(flatbuffers::Offset<flatbuffers::String> collection) {
		fbb_.AddOffset(StorageData::VT_COLLECTION, collection);
	}
	void add_record(flatbuffers::Offset<flatbuffers::String> record) {
		fbb_.AddOffset(StorageData::VT_RECORD, record);
	}
	void add_user_id(flatbuffers::Offset<flatbuffers::String> user_id) {
		fbb_.AddOffset(StorageData::VT_USER_ID, user_id);
	}
	void add_value(flatbuffers::Offset<flatbuffers::String> value) {
		fbb_.AddOffset(StorageData::VT_VALUE, value);
	}
	void add_version(flatbuffers::Offset<flatbuffers::String> version) {
		fbb_.AddOffset(StorageData::VT_VERSION, version);
	}
	void add_permission_read(int32_t permission_read) {
		fbb_.AddElement<int32_t>(StorageData::VT_PERMISSION_READ, permission_read, 0);
	}
	void add_permission_write(int32_t permission_write) {
		fbb_.AddElement<int32_t>(StorageData::VT_PERMISSION_WRITE, permission_write, 0);
	}
	void add_created_at(int64_t created_at) {
		fbb_.AddElement<int64_t>(StorageData::VT_CREATED_AT, created_at, 0);
	}
	void add_updated_at(int64_t updated_at) {
		fbb_.AddElement<int64_t>(StorageData::VT_UPDATED_AT, updated_at, 0);
	}
	void add_expires_at(int64_t expires_at) {
		fbb_.AddElement<int64_t>(StorageData::VT_EXPIRES_AT, expires_at, 0);
	}
	explicit StorageDataBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<StorageData> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<StorageData>(end);
		return o;
	}
};

inline flatbuffers::Offset<StorageData> CreateStorageData(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> bucket = 0,
		flatbuffers::Offset<flatbuffers::String> collection = 0,
		flatbuffers::Offset<flatbuffers::String> record = 0,
		flatbuffers::Offset<flatbuffers::String> user_id = 0,
		flatbuffers::Offset<flatbuffers::String> value = 0,
		flatbuffers::Offset<flatbuffers::String> version = 0,
		int32_t permission_read = 0,
		int32_t permission_write = 0,
		int64_t created_at = 0,
		int64_t updated_at = 0,
		int64_t expires_at = 0) {
	StorageDataBuilder builder_(_fbb);
	builder_.add_expires_at(expires_at);
	builder_.add_updated_at(updated_at);
	builder_.add_created_at(created_at);
	builder_.add_permission_write(permission_write);
	builder_.add_permission_read(permission_read);
	builder_.add_version(version);
	builder_.add_value(value);
	builder_.add_user_id(user_id);
	builder_.add_record(record);
	builder_.add_collection(collection);
	builder_.add_bucket(bucket);
	return builder_.Finish();
}

inline flatbuffers::Offset<StorageData> CreateStorageDataDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *bucket = nullptr,
		const char *collection = nullptr,
		const char *record = nullptr,
		const char *user_id = nullptr,
		const char *value = nullptr,
		const char *version = nullptr,
		int32_t permission_read = 0,
		int32_t permission_write = 0,
		int64_t created_at = 0,
		int64_t updated_at = 0,
		int64_t expires_at = 0) {
	auto bucket__ = bucket ? _fbb.CreateString(bucket) : 0;
	auto collection__ = collection ? _fbb.CreateString(collection) : 0;
	auto record__ = record ? _fbb.CreateString(record) : 0;
	auto user_id__ = user_id ? _fbb.CreateString(user_id) : 0;
	auto value__ = value ? _fbb.CreateString(value) : 0;
	auto version__ = version ? _fbb.CreateString(version) : 0;
	return server::TStorageData_::CreateStorageData(
			_fbb,
			bucket__,
			collection__,
			record__,
			user_id__,
			value__,
			version__,
			permission_read,
			permission_write,
			created_at,
			updated_at,
			expires_at);
}

flatbuffers::Offset<StorageData> CreateStorageData(flatbuffers::FlatBufferBuilder &_fbb, const StorageDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

} // namespace TStorageData_

struct TStorageWriteT : public flatbuffers::NativeTable {
	typedef TStorageWrite TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TStorageWriteT";
	}
	std::vector<std::unique_ptr<server::TStorageWrite_::StorageDataT>> data;
	TStorageWriteT() {
	}
};

struct TStorageWrite FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TStorageWriteT NativeTableType;
	typedef TStorageWriteBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TStorageWrite";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_DATA = 4
	};
	const flatbuffers::Vector<flatbuffers::Offset<server::TStorageWrite_::StorageData>> *data() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::TStorageWrite_::StorageData>> *>(VT_DATA);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_DATA) &&
				verifier.VerifyVector(data()) &&
				verifier.VerifyVectorOfTables(data()) &&
				verifier.EndTable();
	}
	TStorageWriteT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TStorageWriteT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TStorageWrite> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TStorageWriteT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TStorageWriteBuilder {
	typedef TStorageWrite Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TStorageWrite_::StorageData>>> data) {
		fbb_.AddOffset(TStorageWrite::VT_DATA, data);
	}
	explicit TStorageWriteBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TStorageWrite> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TStorageWrite>(end);
		return o;
	}
};

inline flatbuffers::Offset<TStorageWrite> CreateTStorageWrite(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TStorageWrite_::StorageData>>> data = 0) {
	TStorageWriteBuilder builder_(_fbb);
	builder_.add_data(data);
	return builder_.Finish();
}

inline flatbuffers::Offset<TStorageWrite> CreateTStorageWriteDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<server::TStorageWrite_::StorageData>> *data = nullptr) {
	auto data__ = data ? _fbb.CreateVector<flatbuffers::Offset<server::TStorageWrite_::StorageData>>(*data) : 0;
	return server::CreateTStorageWrite(
			_fbb,
			data__);
}

flatbuffers::Offset<TStorageWrite> CreateTStorageWrite(flatbuffers::FlatBufferBuilder &_fbb, const TStorageWriteT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace TStorageWrite_ {

struct StorageDataT : public flatbuffers::NativeTable {
	typedef StorageData TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TStorageWrite_.StorageDataT";
	}
	CharString bucket;
	CharString collection;
	CharString record;
	CharString value;
	CharString version;
	int32_t permission_read;
	int32_t permission_write;
	StorageDataT() :
			permission_read(0),
			permission_write(0) {
	}
};

struct StorageData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef StorageDataT NativeTableType;
	typedef StorageDataBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TStorageWrite_.StorageData";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_BUCKET = 4,
		VT_COLLECTION = 6,
		VT_RECORD = 8,
		VT_VALUE = 10,
		VT_VERSION = 12,
		VT_PERMISSION_READ = 14,
		VT_PERMISSION_WRITE = 16
	};
	const flatbuffers::String *bucket() const {
		return GetPointer<const flatbuffers::String *>(VT_BUCKET);
	}
	const flatbuffers::String *collection() const {
		return GetPointer<const flatbuffers::String *>(VT_COLLECTION);
	}
	const flatbuffers::String *record() const {
		return GetPointer<const flatbuffers::String *>(VT_RECORD);
	}
	const flatbuffers::String *value() const {
		return GetPointer<const flatbuffers::String *>(VT_VALUE);
	}
	const flatbuffers::String *version() const {
		return GetPointer<const flatbuffers::String *>(VT_VERSION);
	}
	int32_t permission_read() const {
		return GetField<int32_t>(VT_PERMISSION_READ, 0);
	}
	int32_t permission_write() const {
		return GetField<int32_t>(VT_PERMISSION_WRITE, 0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_BUCKET) &&
				verifier.VerifyString(bucket()) &&
				VerifyOffset(verifier, VT_COLLECTION) &&
				verifier.VerifyString(collection()) &&
				VerifyOffset(verifier, VT_RECORD) &&
				verifier.VerifyString(record()) &&
				VerifyOffset(verifier, VT_VALUE) &&
				verifier.VerifyString(value()) &&
				VerifyOffset(verifier, VT_VERSION) &&
				verifier.VerifyString(version()) &&
				VerifyField<int32_t>(verifier, VT_PERMISSION_READ) &&
				VerifyField<int32_t>(verifier, VT_PERMISSION_WRITE) &&
				verifier.EndTable();
	}
	StorageDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(StorageDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<StorageData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StorageDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct StorageDataBuilder {
	typedef StorageData Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_bucket(flatbuffers::Offset<flatbuffers::String> bucket) {
		fbb_.AddOffset(StorageData::VT_BUCKET, bucket);
	}
	void add_collection(flatbuffers::Offset<flatbuffers::String> collection) {
		fbb_.AddOffset(StorageData::VT_COLLECTION, collection);
	}
	void add_record(flatbuffers::Offset<flatbuffers::String> record) {
		fbb_.AddOffset(StorageData::VT_RECORD, record);
	}
	void add_value(flatbuffers::Offset<flatbuffers::String> value) {
		fbb_.AddOffset(StorageData::VT_VALUE, value);
	}
	void add_version(flatbuffers::Offset<flatbuffers::String> version) {
		fbb_.AddOffset(StorageData::VT_VERSION, version);
	}
	void add_permission_read(int32_t permission_read) {
		fbb_.AddElement<int32_t>(StorageData::VT_PERMISSION_READ, permission_read, 0);
	}
	void add_permission_write(int32_t permission_write) {
		fbb_.AddElement<int32_t>(StorageData::VT_PERMISSION_WRITE, permission_write, 0);
	}
	explicit StorageDataBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<StorageData> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<StorageData>(end);
		return o;
	}
};

inline flatbuffers::Offset<StorageData> CreateStorageData(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> bucket = 0,
		flatbuffers::Offset<flatbuffers::String> collection = 0,
		flatbuffers::Offset<flatbuffers::String> record = 0,
		flatbuffers::Offset<flatbuffers::String> value = 0,
		flatbuffers::Offset<flatbuffers::String> version = 0,
		int32_t permission_read = 0,
		int32_t permission_write = 0) {
	StorageDataBuilder builder_(_fbb);
	builder_.add_permission_write(permission_write);
	builder_.add_permission_read(permission_read);
	builder_.add_version(version);
	builder_.add_value(value);
	builder_.add_record(record);
	builder_.add_collection(collection);
	builder_.add_bucket(bucket);
	return builder_.Finish();
}

inline flatbuffers::Offset<StorageData> CreateStorageDataDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *bucket = nullptr,
		const char *collection = nullptr,
		const char *record = nullptr,
		const char *value = nullptr,
		const char *version = nullptr,
		int32_t permission_read = 0,
		int32_t permission_write = 0) {
	auto bucket__ = bucket ? _fbb.CreateString(bucket) : 0;
	auto collection__ = collection ? _fbb.CreateString(collection) : 0;
	auto record__ = record ? _fbb.CreateString(record) : 0;
	auto value__ = value ? _fbb.CreateString(value) : 0;
	auto version__ = version ? _fbb.CreateString(version) : 0;
	return server::TStorageWrite_::CreateStorageData(
			_fbb,
			bucket__,
			collection__,
			record__,
			value__,
			version__,
			permission_read,
			permission_write);
}

flatbuffers::Offset<StorageData> CreateStorageData(flatbuffers::FlatBufferBuilder &_fbb, const StorageDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

} // namespace TStorageWrite_

struct TStorageUpdateT : public flatbuffers::NativeTable {
	typedef TStorageUpdate TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TStorageUpdateT";
	}
	std::vector<std::unique_ptr<server::TStorageUpdate_::StorageUpdateT>> updates;
	TStorageUpdateT() {
	}
};

struct TStorageUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TStorageUpdateT NativeTableType;
	typedef TStorageUpdateBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TStorageUpdate";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_UPDATES = 4
	};
	const flatbuffers::Vector<flatbuffers::Offset<server::TStorageUpdate_::StorageUpdate>> *updates() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::TStorageUpdate_::StorageUpdate>> *>(VT_UPDATES);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_UPDATES) &&
				verifier.VerifyVector(updates()) &&
				verifier.VerifyVectorOfTables(updates()) &&
				verifier.EndTable();
	}
	TStorageUpdateT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TStorageUpdateT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TStorageUpdate> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TStorageUpdateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TStorageUpdateBuilder {
	typedef TStorageUpdate Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_updates(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TStorageUpdate_::StorageUpdate>>> updates) {
		fbb_.AddOffset(TStorageUpdate::VT_UPDATES, updates);
	}
	explicit TStorageUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TStorageUpdate> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TStorageUpdate>(end);
		return o;
	}
};

inline flatbuffers::Offset<TStorageUpdate> CreateTStorageUpdate(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TStorageUpdate_::StorageUpdate>>> updates = 0) {
	TStorageUpdateBuilder builder_(_fbb);
	builder_.add_updates(updates);
	return builder_.Finish();
}

inline flatbuffers::Offset<TStorageUpdate> CreateTStorageUpdateDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<server::TStorageUpdate_::StorageUpdate>> *updates = nullptr) {
	auto updates__ = updates ? _fbb.CreateVector<flatbuffers::Offset<server::TStorageUpdate_::StorageUpdate>>(*updates) : 0;
	return server::CreateTStorageUpdate(
			_fbb,
			updates__);
}

flatbuffers::Offset<TStorageUpdate> CreateTStorageUpdate(flatbuffers::FlatBufferBuilder &_fbb, const TStorageUpdateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace TStorageUpdate_ {

struct StorageUpdateT : public flatbuffers::NativeTable {
	typedef StorageUpdate TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TStorageUpdate_.StorageUpdateT";
	}
	std::unique_ptr<server::TStorageUpdate_::StorageUpdate_::StorageKeyT> key;
	int32_t permission_read;
	int32_t permission_write;
	std::vector<std::unique_ptr<server::TStorageUpdate_::StorageUpdate_::UpdateOpT>> ops;
	StorageUpdateT() :
			permission_read(0),
			permission_write(0) {
	}
};

struct StorageUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef StorageUpdateT NativeTableType;
	typedef StorageUpdateBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TStorageUpdate_.StorageUpdate";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_KEY = 4,
		VT_PERMISSION_READ = 6,
		VT_PERMISSION_WRITE = 8,
		VT_OPS = 10
	};
	const server::TStorageUpdate_::StorageUpdate_::StorageKey *key() const {
		return GetPointer<const server::TStorageUpdate_::StorageUpdate_::StorageKey *>(VT_KEY);
	}
	int32_t permission_read() const {
		return GetField<int32_t>(VT_PERMISSION_READ, 0);
	}
	int32_t permission_write() const {
		return GetField<int32_t>(VT_PERMISSION_WRITE, 0);
	}
	const flatbuffers::Vector<flatbuffers::Offset<server::TStorageUpdate_::StorageUpdate_::UpdateOp>> *ops() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::TStorageUpdate_::StorageUpdate_::UpdateOp>> *>(VT_OPS);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_KEY) &&
				verifier.VerifyTable(key()) &&
				VerifyField<int32_t>(verifier, VT_PERMISSION_READ) &&
				VerifyField<int32_t>(verifier, VT_PERMISSION_WRITE) &&
				VerifyOffset(verifier, VT_OPS) &&
				verifier.VerifyVector(ops()) &&
				verifier.VerifyVectorOfTables(ops()) &&
				verifier.EndTable();
	}
	StorageUpdateT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(StorageUpdateT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<StorageUpdate> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StorageUpdateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct StorageUpdateBuilder {
	typedef StorageUpdate Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_key(flatbuffers::Offset<server::TStorageUpdate_::StorageUpdate_::StorageKey> key) {
		fbb_.AddOffset(StorageUpdate::VT_KEY, key);
	}
	void add_permission_read(int32_t permission_read) {
		fbb_.AddElement<int32_t>(StorageUpdate::VT_PERMISSION_READ, permission_read, 0);
	}
	void add_permission_write(int32_t permission_write) {
		fbb_.AddElement<int32_t>(StorageUpdate::VT_PERMISSION_WRITE, permission_write, 0);
	}
	void add_ops(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TStorageUpdate_::StorageUpdate_::UpdateOp>>> ops) {
		fbb_.AddOffset(StorageUpdate::VT_OPS, ops);
	}
	explicit StorageUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<StorageUpdate> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<StorageUpdate>(end);
		return o;
	}
};

inline flatbuffers::Offset<StorageUpdate> CreateStorageUpdate(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<server::TStorageUpdate_::StorageUpdate_::StorageKey> key = 0,
		int32_t permission_read = 0,
		int32_t permission_write = 0,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TStorageUpdate_::StorageUpdate_::UpdateOp>>> ops = 0) {
	StorageUpdateBuilder builder_(_fbb);
	builder_.add_ops(ops);
	builder_.add_permission_write(permission_write);
	builder_.add_permission_read(permission_read);
	builder_.add_key(key);
	return builder_.Finish();
}

inline flatbuffers::Offset<StorageUpdate> CreateStorageUpdateDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<server::TStorageUpdate_::StorageUpdate_::StorageKey> key = 0,
		int32_t permission_read = 0,
		int32_t permission_write = 0,
		const std::vector<flatbuffers::Offset<server::TStorageUpdate_::StorageUpdate_::UpdateOp>> *ops = nullptr) {
	auto ops__ = ops ? _fbb.CreateVector<flatbuffers::Offset<server::TStorageUpdate_::StorageUpdate_::UpdateOp>>(*ops) : 0;
	return server::TStorageUpdate_::CreateStorageUpdate(
			_fbb,
			key,
			permission_read,
			permission_write,
			ops__);
}

flatbuffers::Offset<StorageUpdate> CreateStorageUpdate(flatbuffers::FlatBufferBuilder &_fbb, const StorageUpdateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace StorageUpdate_ {

struct UpdateOpT : public flatbuffers::NativeTable {
	typedef UpdateOp TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TStorageUpdate_.StorageUpdate_.UpdateOpT";
	}
	int32_t op;
	CharString path;
	CharString value;
	CharString from;
	bool conditional;
	int64_t assertion;
	std::vector<std::unique_ptr<server::TStorageUpdate_::StorageUpdate_::UpdateOpT>> ops;
	UpdateOpT() :
			op(0),
			conditional(false),
			assertion(0) {
	}
};

struct UpdateOp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef UpdateOpT NativeTableType;
	typedef UpdateOpBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TStorageUpdate_.StorageUpdate_.UpdateOp";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_OP = 4,
		VT_PATH = 6,
		VT_VALUE = 8,
		VT_FROM = 10,
		VT_CONDITIONAL = 12,
		VT_ASSERT = 14,
		VT_OPS = 16
	};
	/// Update op code - must be one of the UpdateOpCode enums above.
	int32_t op() const {
		return GetField<int32_t>(VT_OP, 0);
	}
	const flatbuffers::String *path() const {
		return GetPointer<const flatbuffers::String *>(VT_PATH);
	}
	const flatbuffers::String *value() const {
		return GetPointer<const flatbuffers::String *>(VT_VALUE);
	}
	const flatbuffers::String *from() const {
		return GetPointer<const flatbuffers::String *>(VT_FROM);
	}
	bool conditional() const {
		return GetField<uint8_t>(VT_CONDITIONAL, 0) != 0;
	}
	int64_t assertion() const {
		return GetField<int64_t>(VT_ASSERT, 0);
	}
	const flatbuffers::Vector<flatbuffers::Offset<server::TStorageUpdate_::StorageUpdate_::UpdateOp>> *ops() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::TStorageUpdate_::StorageUpdate_::UpdateOp>> *>(VT_OPS);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyField<int32_t>(verifier, VT_OP) &&
				VerifyOffset(verifier, VT_PATH) &&
				verifier.VerifyString(path()) &&
				VerifyOffset(verifier, VT_VALUE) &&
				verifier.VerifyString(value()) &&
				VerifyOffset(verifier, VT_FROM) &&
				verifier.VerifyString(from()) &&
				VerifyField<uint8_t>(verifier, VT_CONDITIONAL) &&
				VerifyField<int64_t>(verifier, VT_ASSERT) &&
				VerifyOffset(verifier, VT_OPS) &&
				verifier.VerifyVector(ops()) &&
				verifier.VerifyVectorOfTables(ops()) &&
				verifier.EndTable();
	}
	UpdateOpT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(UpdateOpT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<UpdateOp> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UpdateOpT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct UpdateOpBuilder {
	typedef UpdateOp Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_op(int32_t op) {
		fbb_.AddElement<int32_t>(UpdateOp::VT_OP, op, 0);
	}
	void add_path(flatbuffers::Offset<flatbuffers::String> path) {
		fbb_.AddOffset(UpdateOp::VT_PATH, path);
	}
	void add_value(flatbuffers::Offset<flatbuffers::String> value) {
		fbb_.AddOffset(UpdateOp::VT_VALUE, value);
	}
	void add_from(flatbuffers::Offset<flatbuffers::String> from) {
		fbb_.AddOffset(UpdateOp::VT_FROM, from);
	}
	void add_conditional(bool conditional) {
		fbb_.AddElement<uint8_t>(UpdateOp::VT_CONDITIONAL, static_cast<uint8_t>(conditional), 0);
	}
	void add_assertion(int64_t assertion) {
		fbb_.AddElement<int64_t>(UpdateOp::VT_ASSERT, assertion, 0);
	}
	void add_ops(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TStorageUpdate_::StorageUpdate_::UpdateOp>>> ops) {
		fbb_.AddOffset(UpdateOp::VT_OPS, ops);
	}
	explicit UpdateOpBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<UpdateOp> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<UpdateOp>(end);
		return o;
	}
};

inline flatbuffers::Offset<UpdateOp> CreateUpdateOp(
		flatbuffers::FlatBufferBuilder &_fbb,
		int32_t op = 0,
		flatbuffers::Offset<flatbuffers::String> path = 0,
		flatbuffers::Offset<flatbuffers::String> value = 0,
		flatbuffers::Offset<flatbuffers::String> from = 0,
		bool conditional = false,
		int64_t assertion = 0,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TStorageUpdate_::StorageUpdate_::UpdateOp>>> ops = 0) {
	UpdateOpBuilder builder_(_fbb);
	builder_.add_assertion(assertion);
	builder_.add_ops(ops);
	builder_.add_from(from);
	builder_.add_value(value);
	builder_.add_path(path);
	builder_.add_op(op);
	builder_.add_conditional(conditional);
	return builder_.Finish();
}

inline flatbuffers::Offset<UpdateOp> CreateUpdateOpDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		int32_t op = 0,
		const char *path = nullptr,
		const char *value = nullptr,
		const char *from = nullptr,
		bool conditional = false,
		int64_t assertion = 0,
		const std::vector<flatbuffers::Offset<server::TStorageUpdate_::StorageUpdate_::UpdateOp>> *ops = nullptr) {
	auto path__ = path ? _fbb.CreateString(path) : 0;
	auto value__ = value ? _fbb.CreateString(value) : 0;
	auto from__ = from ? _fbb.CreateString(from) : 0;
	auto ops__ = ops ? _fbb.CreateVector<flatbuffers::Offset<server::TStorageUpdate_::StorageUpdate_::UpdateOp>>(*ops) : 0;
	return server::TStorageUpdate_::StorageUpdate_::CreateUpdateOp(
			_fbb,
			op,
			path__,
			value__,
			from__,
			conditional,
			assertion,
			ops__);
}

flatbuffers::Offset<UpdateOp> CreateUpdateOp(flatbuffers::FlatBufferBuilder &_fbb, const UpdateOpT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StorageKeyT : public flatbuffers::NativeTable {
	typedef StorageKey TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TStorageUpdate_.StorageUpdate_.StorageKeyT";
	}
	CharString bucket;
	CharString collection;
	CharString record;
	CharString version;
	StorageKeyT() {
	}
};

struct StorageKey FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef StorageKeyT NativeTableType;
	typedef StorageKeyBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TStorageUpdate_.StorageUpdate_.StorageKey";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_BUCKET = 4,
		VT_COLLECTION = 6,
		VT_RECORD = 8,
		VT_VERSION = 10
	};
	const flatbuffers::String *bucket() const {
		return GetPointer<const flatbuffers::String *>(VT_BUCKET);
	}
	const flatbuffers::String *collection() const {
		return GetPointer<const flatbuffers::String *>(VT_COLLECTION);
	}
	const flatbuffers::String *record() const {
		return GetPointer<const flatbuffers::String *>(VT_RECORD);
	}
	const flatbuffers::String *version() const {
		return GetPointer<const flatbuffers::String *>(VT_VERSION);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_BUCKET) &&
				verifier.VerifyString(bucket()) &&
				VerifyOffset(verifier, VT_COLLECTION) &&
				verifier.VerifyString(collection()) &&
				VerifyOffset(verifier, VT_RECORD) &&
				verifier.VerifyString(record()) &&
				VerifyOffset(verifier, VT_VERSION) &&
				verifier.VerifyString(version()) &&
				verifier.EndTable();
	}
	StorageKeyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(StorageKeyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<StorageKey> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StorageKeyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct StorageKeyBuilder {
	typedef StorageKey Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_bucket(flatbuffers::Offset<flatbuffers::String> bucket) {
		fbb_.AddOffset(StorageKey::VT_BUCKET, bucket);
	}
	void add_collection(flatbuffers::Offset<flatbuffers::String> collection) {
		fbb_.AddOffset(StorageKey::VT_COLLECTION, collection);
	}
	void add_record(flatbuffers::Offset<flatbuffers::String> record) {
		fbb_.AddOffset(StorageKey::VT_RECORD, record);
	}
	void add_version(flatbuffers::Offset<flatbuffers::String> version) {
		fbb_.AddOffset(StorageKey::VT_VERSION, version);
	}
	explicit StorageKeyBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<StorageKey> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<StorageKey>(end);
		return o;
	}
};

inline flatbuffers::Offset<StorageKey> CreateStorageKey(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> bucket = 0,
		flatbuffers::Offset<flatbuffers::String> collection = 0,
		flatbuffers::Offset<flatbuffers::String> record = 0,
		flatbuffers::Offset<flatbuffers::String> version = 0) {
	StorageKeyBuilder builder_(_fbb);
	builder_.add_version(version);
	builder_.add_record(record);
	builder_.add_collection(collection);
	builder_.add_bucket(bucket);
	return builder_.Finish();
}

inline flatbuffers::Offset<StorageKey> CreateStorageKeyDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *bucket = nullptr,
		const char *collection = nullptr,
		const char *record = nullptr,
		const char *version = nullptr) {
	auto bucket__ = bucket ? _fbb.CreateString(bucket) : 0;
	auto collection__ = collection ? _fbb.CreateString(collection) : 0;
	auto record__ = record ? _fbb.CreateString(record) : 0;
	auto version__ = version ? _fbb.CreateString(version) : 0;
	return server::TStorageUpdate_::StorageUpdate_::CreateStorageKey(
			_fbb,
			bucket__,
			collection__,
			record__,
			version__);
}

flatbuffers::Offset<StorageKey> CreateStorageKey(flatbuffers::FlatBufferBuilder &_fbb, const StorageKeyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

} // namespace StorageUpdate_
} // namespace TStorageUpdate_

struct TStorageKeysT : public flatbuffers::NativeTable {
	typedef TStorageKeys TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TStorageKeysT";
	}
	std::vector<std::unique_ptr<server::TStorageKeys_::StorageKeyT>> keys;
	TStorageKeysT() {
	}
};

struct TStorageKeys FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TStorageKeysT NativeTableType;
	typedef TStorageKeysBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TStorageKeys";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_KEYS = 4
	};
	const flatbuffers::Vector<flatbuffers::Offset<server::TStorageKeys_::StorageKey>> *keys() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::TStorageKeys_::StorageKey>> *>(VT_KEYS);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_KEYS) &&
				verifier.VerifyVector(keys()) &&
				verifier.VerifyVectorOfTables(keys()) &&
				verifier.EndTable();
	}
	TStorageKeysT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TStorageKeysT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TStorageKeys> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TStorageKeysT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TStorageKeysBuilder {
	typedef TStorageKeys Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_keys(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TStorageKeys_::StorageKey>>> keys) {
		fbb_.AddOffset(TStorageKeys::VT_KEYS, keys);
	}
	explicit TStorageKeysBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TStorageKeys> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TStorageKeys>(end);
		return o;
	}
};

inline flatbuffers::Offset<TStorageKeys> CreateTStorageKeys(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TStorageKeys_::StorageKey>>> keys = 0) {
	TStorageKeysBuilder builder_(_fbb);
	builder_.add_keys(keys);
	return builder_.Finish();
}

inline flatbuffers::Offset<TStorageKeys> CreateTStorageKeysDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<server::TStorageKeys_::StorageKey>> *keys = nullptr) {
	auto keys__ = keys ? _fbb.CreateVector<flatbuffers::Offset<server::TStorageKeys_::StorageKey>>(*keys) : 0;
	return server::CreateTStorageKeys(
			_fbb,
			keys__);
}

flatbuffers::Offset<TStorageKeys> CreateTStorageKeys(flatbuffers::FlatBufferBuilder &_fbb, const TStorageKeysT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace TStorageKeys_ {

struct StorageKeyT : public flatbuffers::NativeTable {
	typedef StorageKey TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TStorageKeys_.StorageKeyT";
	}
	CharString bucket;
	CharString collection;
	CharString record;
	CharString version;
	StorageKeyT() {
	}
};

struct StorageKey FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef StorageKeyT NativeTableType;
	typedef StorageKeyBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TStorageKeys_.StorageKey";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_BUCKET = 4,
		VT_COLLECTION = 6,
		VT_RECORD = 8,
		VT_VERSION = 10
	};
	const flatbuffers::String *bucket() const {
		return GetPointer<const flatbuffers::String *>(VT_BUCKET);
	}
	const flatbuffers::String *collection() const {
		return GetPointer<const flatbuffers::String *>(VT_COLLECTION);
	}
	const flatbuffers::String *record() const {
		return GetPointer<const flatbuffers::String *>(VT_RECORD);
	}
	const flatbuffers::String *version() const {
		return GetPointer<const flatbuffers::String *>(VT_VERSION);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_BUCKET) &&
				verifier.VerifyString(bucket()) &&
				VerifyOffset(verifier, VT_COLLECTION) &&
				verifier.VerifyString(collection()) &&
				VerifyOffset(verifier, VT_RECORD) &&
				verifier.VerifyString(record()) &&
				VerifyOffset(verifier, VT_VERSION) &&
				verifier.VerifyString(version()) &&
				verifier.EndTable();
	}
	StorageKeyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(StorageKeyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<StorageKey> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StorageKeyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct StorageKeyBuilder {
	typedef StorageKey Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_bucket(flatbuffers::Offset<flatbuffers::String> bucket) {
		fbb_.AddOffset(StorageKey::VT_BUCKET, bucket);
	}
	void add_collection(flatbuffers::Offset<flatbuffers::String> collection) {
		fbb_.AddOffset(StorageKey::VT_COLLECTION, collection);
	}
	void add_record(flatbuffers::Offset<flatbuffers::String> record) {
		fbb_.AddOffset(StorageKey::VT_RECORD, record);
	}
	void add_version(flatbuffers::Offset<flatbuffers::String> version) {
		fbb_.AddOffset(StorageKey::VT_VERSION, version);
	}
	explicit StorageKeyBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<StorageKey> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<StorageKey>(end);
		return o;
	}
};

inline flatbuffers::Offset<StorageKey> CreateStorageKey(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> bucket = 0,
		flatbuffers::Offset<flatbuffers::String> collection = 0,
		flatbuffers::Offset<flatbuffers::String> record = 0,
		flatbuffers::Offset<flatbuffers::String> version = 0) {
	StorageKeyBuilder builder_(_fbb);
	builder_.add_version(version);
	builder_.add_record(record);
	builder_.add_collection(collection);
	builder_.add_bucket(bucket);
	return builder_.Finish();
}

inline flatbuffers::Offset<StorageKey> CreateStorageKeyDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *bucket = nullptr,
		const char *collection = nullptr,
		const char *record = nullptr,
		const char *version = nullptr) {
	auto bucket__ = bucket ? _fbb.CreateString(bucket) : 0;
	auto collection__ = collection ? _fbb.CreateString(collection) : 0;
	auto record__ = record ? _fbb.CreateString(record) : 0;
	auto version__ = version ? _fbb.CreateString(version) : 0;
	return server::TStorageKeys_::CreateStorageKey(
			_fbb,
			bucket__,
			collection__,
			record__,
			version__);
}

flatbuffers::Offset<StorageKey> CreateStorageKey(flatbuffers::FlatBufferBuilder &_fbb, const StorageKeyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

} // namespace TStorageKeys_

struct TStorageRemoveT : public flatbuffers::NativeTable {
	typedef TStorageRemove TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TStorageRemoveT";
	}
	std::vector<std::unique_ptr<server::TStorageRemove_::StorageKeyT>> keys;
	TStorageRemoveT() {
	}
};

struct TStorageRemove FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TStorageRemoveT NativeTableType;
	typedef TStorageRemoveBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TStorageRemove";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_KEYS = 4
	};
	const flatbuffers::Vector<flatbuffers::Offset<server::TStorageRemove_::StorageKey>> *keys() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::TStorageRemove_::StorageKey>> *>(VT_KEYS);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_KEYS) &&
				verifier.VerifyVector(keys()) &&
				verifier.VerifyVectorOfTables(keys()) &&
				verifier.EndTable();
	}
	TStorageRemoveT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TStorageRemoveT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TStorageRemove> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TStorageRemoveT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TStorageRemoveBuilder {
	typedef TStorageRemove Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_keys(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TStorageRemove_::StorageKey>>> keys) {
		fbb_.AddOffset(TStorageRemove::VT_KEYS, keys);
	}
	explicit TStorageRemoveBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TStorageRemove> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TStorageRemove>(end);
		return o;
	}
};

inline flatbuffers::Offset<TStorageRemove> CreateTStorageRemove(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TStorageRemove_::StorageKey>>> keys = 0) {
	TStorageRemoveBuilder builder_(_fbb);
	builder_.add_keys(keys);
	return builder_.Finish();
}

inline flatbuffers::Offset<TStorageRemove> CreateTStorageRemoveDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<server::TStorageRemove_::StorageKey>> *keys = nullptr) {
	auto keys__ = keys ? _fbb.CreateVector<flatbuffers::Offset<server::TStorageRemove_::StorageKey>>(*keys) : 0;
	return server::CreateTStorageRemove(
			_fbb,
			keys__);
}

flatbuffers::Offset<TStorageRemove> CreateTStorageRemove(flatbuffers::FlatBufferBuilder &_fbb, const TStorageRemoveT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace TStorageRemove_ {

struct StorageKeyT : public flatbuffers::NativeTable {
	typedef StorageKey TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TStorageRemove_.StorageKeyT";
	}
	CharString bucket;
	CharString collection;
	CharString record;
	CharString version;
	StorageKeyT() {
	}
};

struct StorageKey FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef StorageKeyT NativeTableType;
	typedef StorageKeyBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TStorageRemove_.StorageKey";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_BUCKET = 4,
		VT_COLLECTION = 6,
		VT_RECORD = 8,
		VT_VERSION = 10
	};
	const flatbuffers::String *bucket() const {
		return GetPointer<const flatbuffers::String *>(VT_BUCKET);
	}
	const flatbuffers::String *collection() const {
		return GetPointer<const flatbuffers::String *>(VT_COLLECTION);
	}
	const flatbuffers::String *record() const {
		return GetPointer<const flatbuffers::String *>(VT_RECORD);
	}
	const flatbuffers::String *version() const {
		return GetPointer<const flatbuffers::String *>(VT_VERSION);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_BUCKET) &&
				verifier.VerifyString(bucket()) &&
				VerifyOffset(verifier, VT_COLLECTION) &&
				verifier.VerifyString(collection()) &&
				VerifyOffset(verifier, VT_RECORD) &&
				verifier.VerifyString(record()) &&
				VerifyOffset(verifier, VT_VERSION) &&
				verifier.VerifyString(version()) &&
				verifier.EndTable();
	}
	StorageKeyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(StorageKeyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<StorageKey> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StorageKeyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct StorageKeyBuilder {
	typedef StorageKey Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_bucket(flatbuffers::Offset<flatbuffers::String> bucket) {
		fbb_.AddOffset(StorageKey::VT_BUCKET, bucket);
	}
	void add_collection(flatbuffers::Offset<flatbuffers::String> collection) {
		fbb_.AddOffset(StorageKey::VT_COLLECTION, collection);
	}
	void add_record(flatbuffers::Offset<flatbuffers::String> record) {
		fbb_.AddOffset(StorageKey::VT_RECORD, record);
	}
	void add_version(flatbuffers::Offset<flatbuffers::String> version) {
		fbb_.AddOffset(StorageKey::VT_VERSION, version);
	}
	explicit StorageKeyBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<StorageKey> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<StorageKey>(end);
		return o;
	}
};

inline flatbuffers::Offset<StorageKey> CreateStorageKey(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> bucket = 0,
		flatbuffers::Offset<flatbuffers::String> collection = 0,
		flatbuffers::Offset<flatbuffers::String> record = 0,
		flatbuffers::Offset<flatbuffers::String> version = 0) {
	StorageKeyBuilder builder_(_fbb);
	builder_.add_version(version);
	builder_.add_record(record);
	builder_.add_collection(collection);
	builder_.add_bucket(bucket);
	return builder_.Finish();
}

inline flatbuffers::Offset<StorageKey> CreateStorageKeyDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *bucket = nullptr,
		const char *collection = nullptr,
		const char *record = nullptr,
		const char *version = nullptr) {
	auto bucket__ = bucket ? _fbb.CreateString(bucket) : 0;
	auto collection__ = collection ? _fbb.CreateString(collection) : 0;
	auto record__ = record ? _fbb.CreateString(record) : 0;
	auto version__ = version ? _fbb.CreateString(version) : 0;
	return server::TStorageRemove_::CreateStorageKey(
			_fbb,
			bucket__,
			collection__,
			record__,
			version__);
}

flatbuffers::Offset<StorageKey> CreateStorageKey(flatbuffers::FlatBufferBuilder &_fbb, const StorageKeyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

} // namespace TStorageRemove_

struct LeaderboardT : public flatbuffers::NativeTable {
	typedef Leaderboard TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.LeaderboardT";
	}
	CharString id;
	bool authoritative;
	int64_t sort;
	int64_t count;
	CharString reset_schedule;
	CharString metadata;
	LeaderboardT() :
			authoritative(false),
			sort(0),
			count(0) {
	}
};

struct Leaderboard FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef LeaderboardT NativeTableType;
	typedef LeaderboardBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.Leaderboard";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_ID = 4,
		VT_AUTHORITATIVE = 6,
		VT_SORT = 8,
		VT_COUNT = 10,
		VT_RESET_SCHEDULE = 12,
		VT_METADATA = 14
	};
	const flatbuffers::String *id() const {
		return GetPointer<const flatbuffers::String *>(VT_ID);
	}
	/// Whether the user can submit records directly via the client or not
	bool authoritative() const {
		return GetField<uint8_t>(VT_AUTHORITATIVE, 0) != 0;
	}
	int64_t sort() const {
		return GetField<int64_t>(VT_SORT, 0);
	}
	int64_t count() const {
		return GetField<int64_t>(VT_COUNT, 0);
	}
	const flatbuffers::String *reset_schedule() const {
		return GetPointer<const flatbuffers::String *>(VT_RESET_SCHEDULE);
	}
	const flatbuffers::String *metadata() const {
		return GetPointer<const flatbuffers::String *>(VT_METADATA);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_ID) &&
				verifier.VerifyString(id()) &&
				VerifyField<uint8_t>(verifier, VT_AUTHORITATIVE) &&
				VerifyField<int64_t>(verifier, VT_SORT) &&
				VerifyField<int64_t>(verifier, VT_COUNT) &&
				VerifyOffset(verifier, VT_RESET_SCHEDULE) &&
				verifier.VerifyString(reset_schedule()) &&
				VerifyOffset(verifier, VT_METADATA) &&
				verifier.VerifyString(metadata()) &&
				verifier.EndTable();
	}
	LeaderboardT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(LeaderboardT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<Leaderboard> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LeaderboardT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct LeaderboardBuilder {
	typedef Leaderboard Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_id(flatbuffers::Offset<flatbuffers::String> id) {
		fbb_.AddOffset(Leaderboard::VT_ID, id);
	}
	void add_authoritative(bool authoritative) {
		fbb_.AddElement<uint8_t>(Leaderboard::VT_AUTHORITATIVE, static_cast<uint8_t>(authoritative), 0);
	}
	void add_sort(int64_t sort) {
		fbb_.AddElement<int64_t>(Leaderboard::VT_SORT, sort, 0);
	}
	void add_count(int64_t count) {
		fbb_.AddElement<int64_t>(Leaderboard::VT_COUNT, count, 0);
	}
	void add_reset_schedule(flatbuffers::Offset<flatbuffers::String> reset_schedule) {
		fbb_.AddOffset(Leaderboard::VT_RESET_SCHEDULE, reset_schedule);
	}
	void add_metadata(flatbuffers::Offset<flatbuffers::String> metadata) {
		fbb_.AddOffset(Leaderboard::VT_METADATA, metadata);
	}
	explicit LeaderboardBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<Leaderboard> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Leaderboard>(end);
		return o;
	}
};

inline flatbuffers::Offset<Leaderboard> CreateLeaderboard(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> id = 0,
		bool authoritative = false,
		int64_t sort = 0,
		int64_t count = 0,
		flatbuffers::Offset<flatbuffers::String> reset_schedule = 0,
		flatbuffers::Offset<flatbuffers::String> metadata = 0) {
	LeaderboardBuilder builder_(_fbb);
	builder_.add_count(count);
	builder_.add_sort(sort);
	builder_.add_metadata(metadata);
	builder_.add_reset_schedule(reset_schedule);
	builder_.add_id(id);
	builder_.add_authoritative(authoritative);
	return builder_.Finish();
}

inline flatbuffers::Offset<Leaderboard> CreateLeaderboardDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *id = nullptr,
		bool authoritative = false,
		int64_t sort = 0,
		int64_t count = 0,
		const char *reset_schedule = nullptr,
		const char *metadata = nullptr) {
	auto id__ = id ? _fbb.CreateString(id) : 0;
	auto reset_schedule__ = reset_schedule ? _fbb.CreateString(reset_schedule) : 0;
	auto metadata__ = metadata ? _fbb.CreateString(metadata) : 0;
	return server::CreateLeaderboard(
			_fbb,
			id__,
			authoritative,
			sort,
			count,
			reset_schedule__,
			metadata__);
}

flatbuffers::Offset<Leaderboard> CreateLeaderboard(flatbuffers::FlatBufferBuilder &_fbb, const LeaderboardT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LeaderboardRecordT : public flatbuffers::NativeTable {
	typedef LeaderboardRecord TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.LeaderboardRecordT";
	}
	CharString leaderboard_id;
	CharString owner_id;
	CharString handle;
	CharString lang;
	CharString location;
	CharString timezone;
	int64_t rank;
	int64_t score;
	int64_t num_score;
	CharString metadata;
	int64_t ranked_at;
	int64_t updated_at;
	int64_t expires_at;
	LeaderboardRecordT() :
			rank(0),
			score(0),
			num_score(0),
			ranked_at(0),
			updated_at(0),
			expires_at(0) {
	}
};

struct LeaderboardRecord FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef LeaderboardRecordT NativeTableType;
	typedef LeaderboardRecordBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.LeaderboardRecord";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_LEADERBOARD_ID = 4,
		VT_OWNER_ID = 6,
		VT_HANDLE = 8,
		VT_LANG = 10,
		VT_LOCATION = 12,
		VT_TIMEZONE = 14,
		VT_RANK = 16,
		VT_SCORE = 18,
		VT_NUM_SCORE = 20,
		VT_METADATA = 22,
		VT_RANKED_AT = 24,
		VT_UPDATED_AT = 26,
		VT_EXPIRES_AT = 28
	};
	const flatbuffers::String *leaderboard_id() const {
		return GetPointer<const flatbuffers::String *>(VT_LEADERBOARD_ID);
	}
	const flatbuffers::String *owner_id() const {
		return GetPointer<const flatbuffers::String *>(VT_OWNER_ID);
	}
	const flatbuffers::String *handle() const {
		return GetPointer<const flatbuffers::String *>(VT_HANDLE);
	}
	/// Language tag corresponding to the BCP 47 spec.
	const flatbuffers::String *lang() const {
		return GetPointer<const flatbuffers::String *>(VT_LANG);
	}
	const flatbuffers::String *location() const {
		return GetPointer<const flatbuffers::String *>(VT_LOCATION);
	}
	const flatbuffers::String *timezone() const {
		return GetPointer<const flatbuffers::String *>(VT_TIMEZONE);
	}
	int64_t rank() const {
		return GetField<int64_t>(VT_RANK, 0);
	}
	int64_t score() const {
		return GetField<int64_t>(VT_SCORE, 0);
	}
	int64_t num_score() const {
		return GetField<int64_t>(VT_NUM_SCORE, 0);
	}
	const flatbuffers::String *metadata() const {
		return GetPointer<const flatbuffers::String *>(VT_METADATA);
	}
	int64_t ranked_at() const {
		return GetField<int64_t>(VT_RANKED_AT, 0);
	}
	int64_t updated_at() const {
		return GetField<int64_t>(VT_UPDATED_AT, 0);
	}
	int64_t expires_at() const {
		return GetField<int64_t>(VT_EXPIRES_AT, 0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_LEADERBOARD_ID) &&
				verifier.VerifyString(leaderboard_id()) &&
				VerifyOffset(verifier, VT_OWNER_ID) &&
				verifier.VerifyString(owner_id()) &&
				VerifyOffset(verifier, VT_HANDLE) &&
				verifier.VerifyString(handle()) &&
				VerifyOffset(verifier, VT_LANG) &&
				verifier.VerifyString(lang()) &&
				VerifyOffset(verifier, VT_LOCATION) &&
				verifier.VerifyString(location()) &&
				VerifyOffset(verifier, VT_TIMEZONE) &&
				verifier.VerifyString(timezone()) &&
				VerifyField<int64_t>(verifier, VT_RANK) &&
				VerifyField<int64_t>(verifier, VT_SCORE) &&
				VerifyField<int64_t>(verifier, VT_NUM_SCORE) &&
				VerifyOffset(verifier, VT_METADATA) &&
				verifier.VerifyString(metadata()) &&
				VerifyField<int64_t>(verifier, VT_RANKED_AT) &&
				VerifyField<int64_t>(verifier, VT_UPDATED_AT) &&
				VerifyField<int64_t>(verifier, VT_EXPIRES_AT) &&
				verifier.EndTable();
	}
	LeaderboardRecordT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(LeaderboardRecordT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<LeaderboardRecord> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LeaderboardRecordT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct LeaderboardRecordBuilder {
	typedef LeaderboardRecord Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_leaderboard_id(flatbuffers::Offset<flatbuffers::String> leaderboard_id) {
		fbb_.AddOffset(LeaderboardRecord::VT_LEADERBOARD_ID, leaderboard_id);
	}
	void add_owner_id(flatbuffers::Offset<flatbuffers::String> owner_id) {
		fbb_.AddOffset(LeaderboardRecord::VT_OWNER_ID, owner_id);
	}
	void add_handle(flatbuffers::Offset<flatbuffers::String> handle) {
		fbb_.AddOffset(LeaderboardRecord::VT_HANDLE, handle);
	}
	void add_lang(flatbuffers::Offset<flatbuffers::String> lang) {
		fbb_.AddOffset(LeaderboardRecord::VT_LANG, lang);
	}
	void add_location(flatbuffers::Offset<flatbuffers::String> location) {
		fbb_.AddOffset(LeaderboardRecord::VT_LOCATION, location);
	}
	void add_timezone(flatbuffers::Offset<flatbuffers::String> timezone) {
		fbb_.AddOffset(LeaderboardRecord::VT_TIMEZONE, timezone);
	}
	void add_rank(int64_t rank) {
		fbb_.AddElement<int64_t>(LeaderboardRecord::VT_RANK, rank, 0);
	}
	void add_score(int64_t score) {
		fbb_.AddElement<int64_t>(LeaderboardRecord::VT_SCORE, score, 0);
	}
	void add_num_score(int64_t num_score) {
		fbb_.AddElement<int64_t>(LeaderboardRecord::VT_NUM_SCORE, num_score, 0);
	}
	void add_metadata(flatbuffers::Offset<flatbuffers::String> metadata) {
		fbb_.AddOffset(LeaderboardRecord::VT_METADATA, metadata);
	}
	void add_ranked_at(int64_t ranked_at) {
		fbb_.AddElement<int64_t>(LeaderboardRecord::VT_RANKED_AT, ranked_at, 0);
	}
	void add_updated_at(int64_t updated_at) {
		fbb_.AddElement<int64_t>(LeaderboardRecord::VT_UPDATED_AT, updated_at, 0);
	}
	void add_expires_at(int64_t expires_at) {
		fbb_.AddElement<int64_t>(LeaderboardRecord::VT_EXPIRES_AT, expires_at, 0);
	}
	explicit LeaderboardRecordBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<LeaderboardRecord> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<LeaderboardRecord>(end);
		return o;
	}
};

inline flatbuffers::Offset<LeaderboardRecord> CreateLeaderboardRecord(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> leaderboard_id = 0,
		flatbuffers::Offset<flatbuffers::String> owner_id = 0,
		flatbuffers::Offset<flatbuffers::String> handle = 0,
		flatbuffers::Offset<flatbuffers::String> lang = 0,
		flatbuffers::Offset<flatbuffers::String> location = 0,
		flatbuffers::Offset<flatbuffers::String> timezone = 0,
		int64_t rank = 0,
		int64_t score = 0,
		int64_t num_score = 0,
		flatbuffers::Offset<flatbuffers::String> metadata = 0,
		int64_t ranked_at = 0,
		int64_t updated_at = 0,
		int64_t expires_at = 0) {
	LeaderboardRecordBuilder builder_(_fbb);
	builder_.add_expires_at(expires_at);
	builder_.add_updated_at(updated_at);
	builder_.add_ranked_at(ranked_at);
	builder_.add_num_score(num_score);
	builder_.add_score(score);
	builder_.add_rank(rank);
	builder_.add_metadata(metadata);
	builder_.add_timezone(timezone);
	builder_.add_location(location);
	builder_.add_lang(lang);
	builder_.add_handle(handle);
	builder_.add_owner_id(owner_id);
	builder_.add_leaderboard_id(leaderboard_id);
	return builder_.Finish();
}

inline flatbuffers::Offset<LeaderboardRecord> CreateLeaderboardRecordDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *leaderboard_id = nullptr,
		const char *owner_id = nullptr,
		const char *handle = nullptr,
		const char *lang = nullptr,
		const char *location = nullptr,
		const char *timezone = nullptr,
		int64_t rank = 0,
		int64_t score = 0,
		int64_t num_score = 0,
		const char *metadata = nullptr,
		int64_t ranked_at = 0,
		int64_t updated_at = 0,
		int64_t expires_at = 0) {
	auto leaderboard_id__ = leaderboard_id ? _fbb.CreateString(leaderboard_id) : 0;
	auto owner_id__ = owner_id ? _fbb.CreateString(owner_id) : 0;
	auto handle__ = handle ? _fbb.CreateString(handle) : 0;
	auto lang__ = lang ? _fbb.CreateString(lang) : 0;
	auto location__ = location ? _fbb.CreateString(location) : 0;
	auto timezone__ = timezone ? _fbb.CreateString(timezone) : 0;
	auto metadata__ = metadata ? _fbb.CreateString(metadata) : 0;
	return server::CreateLeaderboardRecord(
			_fbb,
			leaderboard_id__,
			owner_id__,
			handle__,
			lang__,
			location__,
			timezone__,
			rank,
			score,
			num_score,
			metadata__,
			ranked_at,
			updated_at,
			expires_at);
}

flatbuffers::Offset<LeaderboardRecord> CreateLeaderboardRecord(flatbuffers::FlatBufferBuilder &_fbb, const LeaderboardRecordT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TLeaderboardsListT : public flatbuffers::NativeTable {
	typedef TLeaderboardsList TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TLeaderboardsListT";
	}
	int64_t limit;
	CharString cursor;
	std::vector<CharString> filter_leaderboard_id;
	TLeaderboardsListT() :
			limit(0) {
	}
};

struct TLeaderboardsList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TLeaderboardsListT NativeTableType;
	typedef TLeaderboardsListBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TLeaderboardsList";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_LIMIT = 4,
		VT_CURSOR = 6,
		VT_FILTER_LEADERBOARD_ID = 8
	};
	int64_t limit() const {
		return GetField<int64_t>(VT_LIMIT, 0);
	}
	/// Use TLeaderboards.cursor to paginate through results.
	const flatbuffers::String *cursor() const {
		return GetPointer<const flatbuffers::String *>(VT_CURSOR);
	}
	const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *filter_leaderboard_id() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_FILTER_LEADERBOARD_ID);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyField<int64_t>(verifier, VT_LIMIT) &&
				VerifyOffset(verifier, VT_CURSOR) &&
				verifier.VerifyString(cursor()) &&
				VerifyOffset(verifier, VT_FILTER_LEADERBOARD_ID) &&
				verifier.VerifyVector(filter_leaderboard_id()) &&
				verifier.VerifyVectorOfStrings(filter_leaderboard_id()) &&
				verifier.EndTable();
	}
	TLeaderboardsListT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TLeaderboardsListT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TLeaderboardsList> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TLeaderboardsListT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TLeaderboardsListBuilder {
	typedef TLeaderboardsList Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_limit(int64_t limit) {
		fbb_.AddElement<int64_t>(TLeaderboardsList::VT_LIMIT, limit, 0);
	}
	void add_cursor(flatbuffers::Offset<flatbuffers::String> cursor) {
		fbb_.AddOffset(TLeaderboardsList::VT_CURSOR, cursor);
	}
	void add_filter_leaderboard_id(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> filter_leaderboard_id) {
		fbb_.AddOffset(TLeaderboardsList::VT_FILTER_LEADERBOARD_ID, filter_leaderboard_id);
	}
	explicit TLeaderboardsListBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TLeaderboardsList> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TLeaderboardsList>(end);
		return o;
	}
};

inline flatbuffers::Offset<TLeaderboardsList> CreateTLeaderboardsList(
		flatbuffers::FlatBufferBuilder &_fbb,
		int64_t limit = 0,
		flatbuffers::Offset<flatbuffers::String> cursor = 0,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> filter_leaderboard_id = 0) {
	TLeaderboardsListBuilder builder_(_fbb);
	builder_.add_limit(limit);
	builder_.add_filter_leaderboard_id(filter_leaderboard_id);
	builder_.add_cursor(cursor);
	return builder_.Finish();
}

inline flatbuffers::Offset<TLeaderboardsList> CreateTLeaderboardsListDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		int64_t limit = 0,
		const char *cursor = nullptr,
		const std::vector<flatbuffers::Offset<flatbuffers::String>> *filter_leaderboard_id = nullptr) {
	auto cursor__ = cursor ? _fbb.CreateString(cursor) : 0;
	auto filter_leaderboard_id__ = filter_leaderboard_id ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*filter_leaderboard_id) : 0;
	return server::CreateTLeaderboardsList(
			_fbb,
			limit,
			cursor__,
			filter_leaderboard_id__);
}

flatbuffers::Offset<TLeaderboardsList> CreateTLeaderboardsList(flatbuffers::FlatBufferBuilder &_fbb, const TLeaderboardsListT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TLeaderboardsT : public flatbuffers::NativeTable {
	typedef TLeaderboards TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TLeaderboardsT";
	}
	std::vector<std::unique_ptr<server::LeaderboardT>> leaderboards;
	CharString cursor;
	TLeaderboardsT() {
	}
};

struct TLeaderboards FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TLeaderboardsT NativeTableType;
	typedef TLeaderboardsBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TLeaderboards";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_LEADERBOARDS = 4,
		VT_CURSOR = 6
	};
	const flatbuffers::Vector<flatbuffers::Offset<server::Leaderboard>> *leaderboards() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::Leaderboard>> *>(VT_LEADERBOARDS);
	}
	const flatbuffers::String *cursor() const {
		return GetPointer<const flatbuffers::String *>(VT_CURSOR);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_LEADERBOARDS) &&
				verifier.VerifyVector(leaderboards()) &&
				verifier.VerifyVectorOfTables(leaderboards()) &&
				VerifyOffset(verifier, VT_CURSOR) &&
				verifier.VerifyString(cursor()) &&
				verifier.EndTable();
	}
	TLeaderboardsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TLeaderboardsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TLeaderboards> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TLeaderboardsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TLeaderboardsBuilder {
	typedef TLeaderboards Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_leaderboards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::Leaderboard>>> leaderboards) {
		fbb_.AddOffset(TLeaderboards::VT_LEADERBOARDS, leaderboards);
	}
	void add_cursor(flatbuffers::Offset<flatbuffers::String> cursor) {
		fbb_.AddOffset(TLeaderboards::VT_CURSOR, cursor);
	}
	explicit TLeaderboardsBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TLeaderboards> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TLeaderboards>(end);
		return o;
	}
};

inline flatbuffers::Offset<TLeaderboards> CreateTLeaderboards(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::Leaderboard>>> leaderboards = 0,
		flatbuffers::Offset<flatbuffers::String> cursor = 0) {
	TLeaderboardsBuilder builder_(_fbb);
	builder_.add_cursor(cursor);
	builder_.add_leaderboards(leaderboards);
	return builder_.Finish();
}

inline flatbuffers::Offset<TLeaderboards> CreateTLeaderboardsDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<server::Leaderboard>> *leaderboards = nullptr,
		const char *cursor = nullptr) {
	auto leaderboards__ = leaderboards ? _fbb.CreateVector<flatbuffers::Offset<server::Leaderboard>>(*leaderboards) : 0;
	auto cursor__ = cursor ? _fbb.CreateString(cursor) : 0;
	return server::CreateTLeaderboards(
			_fbb,
			leaderboards__,
			cursor__);
}

flatbuffers::Offset<TLeaderboards> CreateTLeaderboards(flatbuffers::FlatBufferBuilder &_fbb, const TLeaderboardsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TLeaderboardRecordsWriteT : public flatbuffers::NativeTable {
	typedef TLeaderboardRecordsWrite TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TLeaderboardRecordsWriteT";
	}
	std::vector<std::unique_ptr<server::TLeaderboardRecordsWrite_::LeaderboardRecordWriteT>> records;
	TLeaderboardRecordsWriteT() {
	}
};

struct TLeaderboardRecordsWrite FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TLeaderboardRecordsWriteT NativeTableType;
	typedef TLeaderboardRecordsWriteBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TLeaderboardRecordsWrite";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_RECORDS = 4
	};
	const flatbuffers::Vector<flatbuffers::Offset<server::TLeaderboardRecordsWrite_::LeaderboardRecordWrite>> *records() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::TLeaderboardRecordsWrite_::LeaderboardRecordWrite>> *>(VT_RECORDS);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_RECORDS) &&
				verifier.VerifyVector(records()) &&
				verifier.VerifyVectorOfTables(records()) &&
				verifier.EndTable();
	}
	TLeaderboardRecordsWriteT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TLeaderboardRecordsWriteT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TLeaderboardRecordsWrite> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TLeaderboardRecordsWriteT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TLeaderboardRecordsWriteBuilder {
	typedef TLeaderboardRecordsWrite Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_records(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TLeaderboardRecordsWrite_::LeaderboardRecordWrite>>> records) {
		fbb_.AddOffset(TLeaderboardRecordsWrite::VT_RECORDS, records);
	}
	explicit TLeaderboardRecordsWriteBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TLeaderboardRecordsWrite> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TLeaderboardRecordsWrite>(end);
		return o;
	}
};

inline flatbuffers::Offset<TLeaderboardRecordsWrite> CreateTLeaderboardRecordsWrite(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::TLeaderboardRecordsWrite_::LeaderboardRecordWrite>>> records = 0) {
	TLeaderboardRecordsWriteBuilder builder_(_fbb);
	builder_.add_records(records);
	return builder_.Finish();
}

inline flatbuffers::Offset<TLeaderboardRecordsWrite> CreateTLeaderboardRecordsWriteDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<server::TLeaderboardRecordsWrite_::LeaderboardRecordWrite>> *records = nullptr) {
	auto records__ = records ? _fbb.CreateVector<flatbuffers::Offset<server::TLeaderboardRecordsWrite_::LeaderboardRecordWrite>>(*records) : 0;
	return server::CreateTLeaderboardRecordsWrite(
			_fbb,
			records__);
}

flatbuffers::Offset<TLeaderboardRecordsWrite> CreateTLeaderboardRecordsWrite(flatbuffers::FlatBufferBuilder &_fbb, const TLeaderboardRecordsWriteT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace TLeaderboardRecordsWrite_ {

struct LeaderboardRecordWriteT : public flatbuffers::NativeTable {
	typedef LeaderboardRecordWrite TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TLeaderboardRecordsWrite_.LeaderboardRecordWriteT";
	}
	CharString leaderboard_id;
	std::unique_ptr<server::TLeaderboardRecordsWrite_::LeaderboardRecordWrite_::ScoreOperatorT> op;
	CharString location;
	CharString timezone;
	CharString metadata;
	LeaderboardRecordWriteT() {
	}
};

struct LeaderboardRecordWrite FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef LeaderboardRecordWriteT NativeTableType;
	typedef LeaderboardRecordWriteBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TLeaderboardRecordsWrite_.LeaderboardRecordWrite";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_LEADERBOARD_ID = 4,
		VT_OP = 6,
		VT_LOCATION = 8,
		VT_TIMEZONE = 10,
		VT_METADATA = 12
	};
	const flatbuffers::String *leaderboard_id() const {
		return GetPointer<const flatbuffers::String *>(VT_LEADERBOARD_ID);
	}
	const server::TLeaderboardRecordsWrite_::LeaderboardRecordWrite_::ScoreOperator *op() const {
		return GetPointer<const server::TLeaderboardRecordsWrite_::LeaderboardRecordWrite_::ScoreOperator *>(VT_OP);
	}
	const flatbuffers::String *location() const {
		return GetPointer<const flatbuffers::String *>(VT_LOCATION);
	}
	const flatbuffers::String *timezone() const {
		return GetPointer<const flatbuffers::String *>(VT_TIMEZONE);
	}
	const flatbuffers::String *metadata() const {
		return GetPointer<const flatbuffers::String *>(VT_METADATA);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_LEADERBOARD_ID) &&
				verifier.VerifyString(leaderboard_id()) &&
				VerifyOffset(verifier, VT_OP) &&
				verifier.VerifyTable(op()) &&
				VerifyOffset(verifier, VT_LOCATION) &&
				verifier.VerifyString(location()) &&
				VerifyOffset(verifier, VT_TIMEZONE) &&
				verifier.VerifyString(timezone()) &&
				VerifyOffset(verifier, VT_METADATA) &&
				verifier.VerifyString(metadata()) &&
				verifier.EndTable();
	}
	LeaderboardRecordWriteT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(LeaderboardRecordWriteT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<LeaderboardRecordWrite> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LeaderboardRecordWriteT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct LeaderboardRecordWriteBuilder {
	typedef LeaderboardRecordWrite Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_leaderboard_id(flatbuffers::Offset<flatbuffers::String> leaderboard_id) {
		fbb_.AddOffset(LeaderboardRecordWrite::VT_LEADERBOARD_ID, leaderboard_id);
	}
	void add_op(flatbuffers::Offset<server::TLeaderboardRecordsWrite_::LeaderboardRecordWrite_::ScoreOperator> op) {
		fbb_.AddOffset(LeaderboardRecordWrite::VT_OP, op);
	}
	void add_location(flatbuffers::Offset<flatbuffers::String> location) {
		fbb_.AddOffset(LeaderboardRecordWrite::VT_LOCATION, location);
	}
	void add_timezone(flatbuffers::Offset<flatbuffers::String> timezone) {
		fbb_.AddOffset(LeaderboardRecordWrite::VT_TIMEZONE, timezone);
	}
	void add_metadata(flatbuffers::Offset<flatbuffers::String> metadata) {
		fbb_.AddOffset(LeaderboardRecordWrite::VT_METADATA, metadata);
	}
	explicit LeaderboardRecordWriteBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<LeaderboardRecordWrite> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<LeaderboardRecordWrite>(end);
		return o;
	}
};

inline flatbuffers::Offset<LeaderboardRecordWrite> CreateLeaderboardRecordWrite(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> leaderboard_id = 0,
		flatbuffers::Offset<server::TLeaderboardRecordsWrite_::LeaderboardRecordWrite_::ScoreOperator> op = 0,
		flatbuffers::Offset<flatbuffers::String> location = 0,
		flatbuffers::Offset<flatbuffers::String> timezone = 0,
		flatbuffers::Offset<flatbuffers::String> metadata = 0) {
	LeaderboardRecordWriteBuilder builder_(_fbb);
	builder_.add_metadata(metadata);
	builder_.add_timezone(timezone);
	builder_.add_location(location);
	builder_.add_op(op);
	builder_.add_leaderboard_id(leaderboard_id);
	return builder_.Finish();
}

inline flatbuffers::Offset<LeaderboardRecordWrite> CreateLeaderboardRecordWriteDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *leaderboard_id = nullptr,
		flatbuffers::Offset<server::TLeaderboardRecordsWrite_::LeaderboardRecordWrite_::ScoreOperator> op = 0,
		const char *location = nullptr,
		const char *timezone = nullptr,
		const char *metadata = nullptr) {
	auto leaderboard_id__ = leaderboard_id ? _fbb.CreateString(leaderboard_id) : 0;
	auto location__ = location ? _fbb.CreateString(location) : 0;
	auto timezone__ = timezone ? _fbb.CreateString(timezone) : 0;
	auto metadata__ = metadata ? _fbb.CreateString(metadata) : 0;
	return server::TLeaderboardRecordsWrite_::CreateLeaderboardRecordWrite(
			_fbb,
			leaderboard_id__,
			op,
			location__,
			timezone__,
			metadata__);
}

flatbuffers::Offset<LeaderboardRecordWrite> CreateLeaderboardRecordWrite(flatbuffers::FlatBufferBuilder &_fbb, const LeaderboardRecordWriteT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace LeaderboardRecordWrite_ {

struct ScoreOperatorT : public flatbuffers::NativeTable {
	typedef ScoreOperator TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TLeaderboardRecordsWrite_.LeaderboardRecordWrite_.ScoreOperatorT";
	}
	int64_t incr;
	int64_t decr;
	int64_t set;
	int64_t best;
	ScoreOperatorT() :
			incr(0),
			decr(0),
			set(0),
			best(0) {
	}
};

struct ScoreOperator FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef ScoreOperatorT NativeTableType;
	typedef ScoreOperatorBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TLeaderboardRecordsWrite_.LeaderboardRecordWrite_.ScoreOperator";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_INCR = 4,
		VT_DECR = 6,
		VT_SET = 8,
		VT_BEST = 10
	};
	int64_t incr() const {
		return GetField<int64_t>(VT_INCR, 0);
	}
	int64_t decr() const {
		return GetField<int64_t>(VT_DECR, 0);
	}
	int64_t set() const {
		return GetField<int64_t>(VT_SET, 0);
	}
	int64_t best() const {
		return GetField<int64_t>(VT_BEST, 0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyField<int64_t>(verifier, VT_INCR) &&
				VerifyField<int64_t>(verifier, VT_DECR) &&
				VerifyField<int64_t>(verifier, VT_SET) &&
				VerifyField<int64_t>(verifier, VT_BEST) &&
				verifier.EndTable();
	}
	ScoreOperatorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(ScoreOperatorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<ScoreOperator> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScoreOperatorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct ScoreOperatorBuilder {
	typedef ScoreOperator Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_incr(int64_t incr) {
		fbb_.AddElement<int64_t>(ScoreOperator::VT_INCR, incr, 0);
	}
	void add_decr(int64_t decr) {
		fbb_.AddElement<int64_t>(ScoreOperator::VT_DECR, decr, 0);
	}
	void add_set(int64_t set) {
		fbb_.AddElement<int64_t>(ScoreOperator::VT_SET, set, 0);
	}
	void add_best(int64_t best) {
		fbb_.AddElement<int64_t>(ScoreOperator::VT_BEST, best, 0);
	}
	explicit ScoreOperatorBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<ScoreOperator> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<ScoreOperator>(end);
		return o;
	}
};

inline flatbuffers::Offset<ScoreOperator> CreateScoreOperator(
		flatbuffers::FlatBufferBuilder &_fbb,
		int64_t incr = 0,
		int64_t decr = 0,
		int64_t set = 0,
		int64_t best = 0) {
	ScoreOperatorBuilder builder_(_fbb);
	builder_.add_best(best);
	builder_.add_set(set);
	builder_.add_decr(decr);
	builder_.add_incr(incr);
	return builder_.Finish();
}

flatbuffers::Offset<ScoreOperator> CreateScoreOperator(flatbuffers::FlatBufferBuilder &_fbb, const ScoreOperatorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

} // namespace LeaderboardRecordWrite_
} // namespace TLeaderboardRecordsWrite_

struct TLeaderboardRecordsFetchT : public flatbuffers::NativeTable {
	typedef TLeaderboardRecordsFetch TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TLeaderboardRecordsFetchT";
	}
	std::vector<CharString> leaderboard_ids;
	int64_t limit;
	CharString cursor;
	TLeaderboardRecordsFetchT() :
			limit(0) {
	}
};

struct TLeaderboardRecordsFetch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TLeaderboardRecordsFetchT NativeTableType;
	typedef TLeaderboardRecordsFetchBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TLeaderboardRecordsFetch";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_LEADERBOARD_IDS = 4,
		VT_LIMIT = 6,
		VT_CURSOR = 8
	};
	const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *leaderboard_ids() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_LEADERBOARD_IDS);
	}
	int64_t limit() const {
		return GetField<int64_t>(VT_LIMIT, 0);
	}
	/// Use TLeaderboardRecords.cursor to paginate through results.
	const flatbuffers::String *cursor() const {
		return GetPointer<const flatbuffers::String *>(VT_CURSOR);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_LEADERBOARD_IDS) &&
				verifier.VerifyVector(leaderboard_ids()) &&
				verifier.VerifyVectorOfStrings(leaderboard_ids()) &&
				VerifyField<int64_t>(verifier, VT_LIMIT) &&
				VerifyOffset(verifier, VT_CURSOR) &&
				verifier.VerifyString(cursor()) &&
				verifier.EndTable();
	}
	TLeaderboardRecordsFetchT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TLeaderboardRecordsFetchT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TLeaderboardRecordsFetch> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TLeaderboardRecordsFetchT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TLeaderboardRecordsFetchBuilder {
	typedef TLeaderboardRecordsFetch Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_leaderboard_ids(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> leaderboard_ids) {
		fbb_.AddOffset(TLeaderboardRecordsFetch::VT_LEADERBOARD_IDS, leaderboard_ids);
	}
	void add_limit(int64_t limit) {
		fbb_.AddElement<int64_t>(TLeaderboardRecordsFetch::VT_LIMIT, limit, 0);
	}
	void add_cursor(flatbuffers::Offset<flatbuffers::String> cursor) {
		fbb_.AddOffset(TLeaderboardRecordsFetch::VT_CURSOR, cursor);
	}
	explicit TLeaderboardRecordsFetchBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TLeaderboardRecordsFetch> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TLeaderboardRecordsFetch>(end);
		return o;
	}
};

inline flatbuffers::Offset<TLeaderboardRecordsFetch> CreateTLeaderboardRecordsFetch(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> leaderboard_ids = 0,
		int64_t limit = 0,
		flatbuffers::Offset<flatbuffers::String> cursor = 0) {
	TLeaderboardRecordsFetchBuilder builder_(_fbb);
	builder_.add_limit(limit);
	builder_.add_cursor(cursor);
	builder_.add_leaderboard_ids(leaderboard_ids);
	return builder_.Finish();
}

inline flatbuffers::Offset<TLeaderboardRecordsFetch> CreateTLeaderboardRecordsFetchDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<flatbuffers::String>> *leaderboard_ids = nullptr,
		int64_t limit = 0,
		const char *cursor = nullptr) {
	auto leaderboard_ids__ = leaderboard_ids ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*leaderboard_ids) : 0;
	auto cursor__ = cursor ? _fbb.CreateString(cursor) : 0;
	return server::CreateTLeaderboardRecordsFetch(
			_fbb,
			leaderboard_ids__,
			limit,
			cursor__);
}

flatbuffers::Offset<TLeaderboardRecordsFetch> CreateTLeaderboardRecordsFetch(flatbuffers::FlatBufferBuilder &_fbb, const TLeaderboardRecordsFetchT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TLeaderboardRecordsListT : public flatbuffers::NativeTable {
	typedef TLeaderboardRecordsList TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TLeaderboardRecordsListT";
	}
	CharString leaderboard_id;
	std::unique_ptr<server::TLeaderboardRecordsList_::AuthenticateResult6T> filter;
	int64_t limit;
	CharString cursor;
	TLeaderboardRecordsListT() :
			limit(0) {
	}
};

struct TLeaderboardRecordsList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TLeaderboardRecordsListT NativeTableType;
	typedef TLeaderboardRecordsListBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TLeaderboardRecordsList";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_LEADERBOARD_ID = 4,
		VT_FILTER = 6,
		VT_LIMIT = 8,
		VT_CURSOR = 10
	};
	const flatbuffers::String *leaderboard_id() const {
		return GetPointer<const flatbuffers::String *>(VT_LEADERBOARD_ID);
	}
	const server::TLeaderboardRecordsList_::AuthenticateResult6 *filter() const {
		return GetPointer<const server::TLeaderboardRecordsList_::AuthenticateResult6 *>(VT_FILTER);
	}
	int64_t limit() const {
		return GetField<int64_t>(VT_LIMIT, 0);
	}
	const flatbuffers::String *cursor() const {
		return GetPointer<const flatbuffers::String *>(VT_CURSOR);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_LEADERBOARD_ID) &&
				verifier.VerifyString(leaderboard_id()) &&
				VerifyOffset(verifier, VT_FILTER) &&
				verifier.VerifyTable(filter()) &&
				VerifyField<int64_t>(verifier, VT_LIMIT) &&
				VerifyOffset(verifier, VT_CURSOR) &&
				verifier.VerifyString(cursor()) &&
				verifier.EndTable();
	}
	TLeaderboardRecordsListT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TLeaderboardRecordsListT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TLeaderboardRecordsList> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TLeaderboardRecordsListT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TLeaderboardRecordsListBuilder {
	typedef TLeaderboardRecordsList Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_leaderboard_id(flatbuffers::Offset<flatbuffers::String> leaderboard_id) {
		fbb_.AddOffset(TLeaderboardRecordsList::VT_LEADERBOARD_ID, leaderboard_id);
	}
	void add_filter(flatbuffers::Offset<server::TLeaderboardRecordsList_::AuthenticateResult6> filter) {
		fbb_.AddOffset(TLeaderboardRecordsList::VT_FILTER, filter);
	}
	void add_limit(int64_t limit) {
		fbb_.AddElement<int64_t>(TLeaderboardRecordsList::VT_LIMIT, limit, 0);
	}
	void add_cursor(flatbuffers::Offset<flatbuffers::String> cursor) {
		fbb_.AddOffset(TLeaderboardRecordsList::VT_CURSOR, cursor);
	}
	explicit TLeaderboardRecordsListBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TLeaderboardRecordsList> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TLeaderboardRecordsList>(end);
		return o;
	}
};

inline flatbuffers::Offset<TLeaderboardRecordsList> CreateTLeaderboardRecordsList(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> leaderboard_id = 0,
		flatbuffers::Offset<server::TLeaderboardRecordsList_::AuthenticateResult6> filter = 0,
		int64_t limit = 0,
		flatbuffers::Offset<flatbuffers::String> cursor = 0) {
	TLeaderboardRecordsListBuilder builder_(_fbb);
	builder_.add_limit(limit);
	builder_.add_cursor(cursor);
	builder_.add_filter(filter);
	builder_.add_leaderboard_id(leaderboard_id);
	return builder_.Finish();
}

inline flatbuffers::Offset<TLeaderboardRecordsList> CreateTLeaderboardRecordsListDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *leaderboard_id = nullptr,
		flatbuffers::Offset<server::TLeaderboardRecordsList_::AuthenticateResult6> filter = 0,
		int64_t limit = 0,
		const char *cursor = nullptr) {
	auto leaderboard_id__ = leaderboard_id ? _fbb.CreateString(leaderboard_id) : 0;
	auto cursor__ = cursor ? _fbb.CreateString(cursor) : 0;
	return server::CreateTLeaderboardRecordsList(
			_fbb,
			leaderboard_id__,
			filter,
			limit,
			cursor__);
}

flatbuffers::Offset<TLeaderboardRecordsList> CreateTLeaderboardRecordsList(flatbuffers::FlatBufferBuilder &_fbb, const TLeaderboardRecordsListT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace TLeaderboardRecordsList_ {

struct OwnersT : public flatbuffers::NativeTable {
	typedef Owners TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TLeaderboardRecordsList_.OwnersT";
	}
	std::vector<CharString> owner_ids;
	OwnersT() {
	}
};

struct Owners FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef OwnersT NativeTableType;
	typedef OwnersBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TLeaderboardRecordsList_.Owners";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_OWNER_IDS = 4
	};
	const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *owner_ids() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_OWNER_IDS);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_OWNER_IDS) &&
				verifier.VerifyVector(owner_ids()) &&
				verifier.VerifyVectorOfStrings(owner_ids()) &&
				verifier.EndTable();
	}
	OwnersT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(OwnersT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<Owners> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OwnersT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct OwnersBuilder {
	typedef Owners Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_owner_ids(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> owner_ids) {
		fbb_.AddOffset(Owners::VT_OWNER_IDS, owner_ids);
	}
	explicit OwnersBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<Owners> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Owners>(end);
		return o;
	}
};

inline flatbuffers::Offset<Owners> CreateOwners(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> owner_ids = 0) {
	OwnersBuilder builder_(_fbb);
	builder_.add_owner_ids(owner_ids);
	return builder_.Finish();
}

inline flatbuffers::Offset<Owners> CreateOwnersDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<flatbuffers::String>> *owner_ids = nullptr) {
	auto owner_ids__ = owner_ids ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*owner_ids) : 0;
	return server::TLeaderboardRecordsList_::CreateOwners(
			_fbb,
			owner_ids__);
}

flatbuffers::Offset<Owners> CreateOwners(flatbuffers::FlatBufferBuilder &_fbb, const OwnersT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AuthenticateResult6T : public flatbuffers::NativeTable {
	typedef AuthenticateResult6 TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TLeaderboardRecordsList_.AuthenticateResult6T";
	}
	CharString owner_id;
	std::unique_ptr<server::TLeaderboardRecordsList_::OwnersT> owner_ids;
	CharString lang;
	CharString location;
	CharString timezone;
	AuthenticateResult6T() {
	}
};

struct AuthenticateResult6 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef AuthenticateResult6T NativeTableType;
	typedef AuthenticateResult6Builder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TLeaderboardRecordsList_.AuthenticateResult6";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_OWNER_ID = 4,
		VT_OWNER_IDS = 6,
		VT_LANG = 8,
		VT_LOCATION = 10,
		VT_TIMEZONE = 12
	};
	/// Filter records by one user ID. This is the same as a "heystack" lookup
	const flatbuffers::String *owner_id() const {
		return GetPointer<const flatbuffers::String *>(VT_OWNER_ID);
	}
	/// Filter records by user IDs
	const server::TLeaderboardRecordsList_::Owners *owner_ids() const {
		return GetPointer<const server::TLeaderboardRecordsList_::Owners *>(VT_OWNER_IDS);
	}
	const flatbuffers::String *lang() const {
		return GetPointer<const flatbuffers::String *>(VT_LANG);
	}
	const flatbuffers::String *location() const {
		return GetPointer<const flatbuffers::String *>(VT_LOCATION);
	}
	const flatbuffers::String *timezone() const {
		return GetPointer<const flatbuffers::String *>(VT_TIMEZONE);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_OWNER_ID) &&
				verifier.VerifyString(owner_id()) &&
				VerifyOffset(verifier, VT_OWNER_IDS) &&
				verifier.VerifyTable(owner_ids()) &&
				VerifyOffset(verifier, VT_LANG) &&
				verifier.VerifyString(lang()) &&
				VerifyOffset(verifier, VT_LOCATION) &&
				verifier.VerifyString(location()) &&
				VerifyOffset(verifier, VT_TIMEZONE) &&
				verifier.VerifyString(timezone()) &&
				verifier.EndTable();
	}
	AuthenticateResult6T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(AuthenticateResult6T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<AuthenticateResult6> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateResult6T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct AuthenticateResult6Builder {
	typedef AuthenticateResult6 Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_owner_id(flatbuffers::Offset<flatbuffers::String> owner_id) {
		fbb_.AddOffset(AuthenticateResult6::VT_OWNER_ID, owner_id);
	}
	void add_owner_ids(flatbuffers::Offset<server::TLeaderboardRecordsList_::Owners> owner_ids) {
		fbb_.AddOffset(AuthenticateResult6::VT_OWNER_IDS, owner_ids);
	}
	void add_lang(flatbuffers::Offset<flatbuffers::String> lang) {
		fbb_.AddOffset(AuthenticateResult6::VT_LANG, lang);
	}
	void add_location(flatbuffers::Offset<flatbuffers::String> location) {
		fbb_.AddOffset(AuthenticateResult6::VT_LOCATION, location);
	}
	void add_timezone(flatbuffers::Offset<flatbuffers::String> timezone) {
		fbb_.AddOffset(AuthenticateResult6::VT_TIMEZONE, timezone);
	}
	explicit AuthenticateResult6Builder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<AuthenticateResult6> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<AuthenticateResult6>(end);
		return o;
	}
};

inline flatbuffers::Offset<AuthenticateResult6> CreateAuthenticateResult6(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> owner_id = 0,
		flatbuffers::Offset<server::TLeaderboardRecordsList_::Owners> owner_ids = 0,
		flatbuffers::Offset<flatbuffers::String> lang = 0,
		flatbuffers::Offset<flatbuffers::String> location = 0,
		flatbuffers::Offset<flatbuffers::String> timezone = 0) {
	AuthenticateResult6Builder builder_(_fbb);
	builder_.add_timezone(timezone);
	builder_.add_location(location);
	builder_.add_lang(lang);
	builder_.add_owner_ids(owner_ids);
	builder_.add_owner_id(owner_id);
	return builder_.Finish();
}

inline flatbuffers::Offset<AuthenticateResult6> CreateAuthenticateResult6Direct(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *owner_id = nullptr,
		flatbuffers::Offset<server::TLeaderboardRecordsList_::Owners> owner_ids = 0,
		const char *lang = nullptr,
		const char *location = nullptr,
		const char *timezone = nullptr) {
	auto owner_id__ = owner_id ? _fbb.CreateString(owner_id) : 0;
	auto lang__ = lang ? _fbb.CreateString(lang) : 0;
	auto location__ = location ? _fbb.CreateString(location) : 0;
	auto timezone__ = timezone ? _fbb.CreateString(timezone) : 0;
	return server::TLeaderboardRecordsList_::CreateAuthenticateResult6(
			_fbb,
			owner_id__,
			owner_ids,
			lang__,
			location__,
			timezone__);
}

flatbuffers::Offset<AuthenticateResult6> CreateAuthenticateResult6(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateResult6T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

} // namespace TLeaderboardRecordsList_

struct TLeaderboardRecordsT : public flatbuffers::NativeTable {
	typedef TLeaderboardRecords TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TLeaderboardRecordsT";
	}
	std::vector<std::unique_ptr<server::LeaderboardRecordT>> records;
	CharString cursor;
	TLeaderboardRecordsT() {
	}
};

struct TLeaderboardRecords FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TLeaderboardRecordsT NativeTableType;
	typedef TLeaderboardRecordsBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TLeaderboardRecords";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_RECORDS = 4,
		VT_CURSOR = 6
	};
	const flatbuffers::Vector<flatbuffers::Offset<server::LeaderboardRecord>> *records() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::LeaderboardRecord>> *>(VT_RECORDS);
	}
	const flatbuffers::String *cursor() const {
		return GetPointer<const flatbuffers::String *>(VT_CURSOR);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_RECORDS) &&
				verifier.VerifyVector(records()) &&
				verifier.VerifyVectorOfTables(records()) &&
				VerifyOffset(verifier, VT_CURSOR) &&
				verifier.VerifyString(cursor()) &&
				verifier.EndTable();
	}
	TLeaderboardRecordsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TLeaderboardRecordsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TLeaderboardRecords> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TLeaderboardRecordsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TLeaderboardRecordsBuilder {
	typedef TLeaderboardRecords Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_records(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::LeaderboardRecord>>> records) {
		fbb_.AddOffset(TLeaderboardRecords::VT_RECORDS, records);
	}
	void add_cursor(flatbuffers::Offset<flatbuffers::String> cursor) {
		fbb_.AddOffset(TLeaderboardRecords::VT_CURSOR, cursor);
	}
	explicit TLeaderboardRecordsBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TLeaderboardRecords> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TLeaderboardRecords>(end);
		return o;
	}
};

inline flatbuffers::Offset<TLeaderboardRecords> CreateTLeaderboardRecords(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::LeaderboardRecord>>> records = 0,
		flatbuffers::Offset<flatbuffers::String> cursor = 0) {
	TLeaderboardRecordsBuilder builder_(_fbb);
	builder_.add_cursor(cursor);
	builder_.add_records(records);
	return builder_.Finish();
}

inline flatbuffers::Offset<TLeaderboardRecords> CreateTLeaderboardRecordsDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<server::LeaderboardRecord>> *records = nullptr,
		const char *cursor = nullptr) {
	auto records__ = records ? _fbb.CreateVector<flatbuffers::Offset<server::LeaderboardRecord>>(*records) : 0;
	auto cursor__ = cursor ? _fbb.CreateString(cursor) : 0;
	return server::CreateTLeaderboardRecords(
			_fbb,
			records__,
			cursor__);
}

flatbuffers::Offset<TLeaderboardRecords> CreateTLeaderboardRecords(flatbuffers::FlatBufferBuilder &_fbb, const TLeaderboardRecordsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TRpcT : public flatbuffers::NativeTable {
	typedef TRpc TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TRpcT";
	}
	CharString id;
	CharString payload;
	TRpcT() {
	}
};

struct TRpc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TRpcT NativeTableType;
	typedef TRpcBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TRpc";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_ID = 4,
		VT_PAYLOAD = 6
	};
	const flatbuffers::String *id() const {
		return GetPointer<const flatbuffers::String *>(VT_ID);
	}
	const flatbuffers::String *payload() const {
		return GetPointer<const flatbuffers::String *>(VT_PAYLOAD);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_ID) &&
				verifier.VerifyString(id()) &&
				VerifyOffset(verifier, VT_PAYLOAD) &&
				verifier.VerifyString(payload()) &&
				verifier.EndTable();
	}
	TRpcT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TRpcT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TRpc> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TRpcT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TRpcBuilder {
	typedef TRpc Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_id(flatbuffers::Offset<flatbuffers::String> id) {
		fbb_.AddOffset(TRpc::VT_ID, id);
	}
	void add_payload(flatbuffers::Offset<flatbuffers::String> payload) {
		fbb_.AddOffset(TRpc::VT_PAYLOAD, payload);
	}
	explicit TRpcBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TRpc> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TRpc>(end);
		return o;
	}
};

inline flatbuffers::Offset<TRpc> CreateTRpc(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> id = 0,
		flatbuffers::Offset<flatbuffers::String> payload = 0) {
	TRpcBuilder builder_(_fbb);
	builder_.add_payload(payload);
	builder_.add_id(id);
	return builder_.Finish();
}

inline flatbuffers::Offset<TRpc> CreateTRpcDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *id = nullptr,
		const char *payload = nullptr) {
	auto id__ = id ? _fbb.CreateString(id) : 0;
	auto payload__ = payload ? _fbb.CreateString(payload) : 0;
	return server::CreateTRpc(
			_fbb,
			id__,
			payload__);
}

flatbuffers::Offset<TRpc> CreateTRpc(flatbuffers::FlatBufferBuilder &_fbb, const TRpcT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TPurchaseValidationT : public flatbuffers::NativeTable {
	typedef TPurchaseValidation TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TPurchaseValidationT";
	}
	std::unique_ptr<server::TPurchaseValidation_::AuthenticateResult7T> id;
	TPurchaseValidationT() {
	}
};

struct TPurchaseValidation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TPurchaseValidationT NativeTableType;
	typedef TPurchaseValidationBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TPurchaseValidation";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_ID = 4
	};
	const server::TPurchaseValidation_::AuthenticateResult7 *id() const {
		return GetPointer<const server::TPurchaseValidation_::AuthenticateResult7 *>(VT_ID);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_ID) &&
				verifier.VerifyTable(id()) &&
				verifier.EndTable();
	}
	TPurchaseValidationT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TPurchaseValidationT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TPurchaseValidation> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TPurchaseValidationT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TPurchaseValidationBuilder {
	typedef TPurchaseValidation Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_id(flatbuffers::Offset<server::TPurchaseValidation_::AuthenticateResult7> id) {
		fbb_.AddOffset(TPurchaseValidation::VT_ID, id);
	}
	explicit TPurchaseValidationBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TPurchaseValidation> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TPurchaseValidation>(end);
		return o;
	}
};

inline flatbuffers::Offset<TPurchaseValidation> CreateTPurchaseValidation(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<server::TPurchaseValidation_::AuthenticateResult7> id = 0) {
	TPurchaseValidationBuilder builder_(_fbb);
	builder_.add_id(id);
	return builder_.Finish();
}

flatbuffers::Offset<TPurchaseValidation> CreateTPurchaseValidation(flatbuffers::FlatBufferBuilder &_fbb, const TPurchaseValidationT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace TPurchaseValidation_ {

struct ApplePurchaseT : public flatbuffers::NativeTable {
	typedef ApplePurchase TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TPurchaseValidation_.ApplePurchaseT";
	}
	CharString product_id;
	CharString receipt_data;
	ApplePurchaseT() {
	}
};

struct ApplePurchase FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef ApplePurchaseT NativeTableType;
	typedef ApplePurchaseBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TPurchaseValidation_.ApplePurchase";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_PRODUCT_ID = 4,
		VT_RECEIPT_DATA = 6
	};
	const flatbuffers::String *product_id() const {
		return GetPointer<const flatbuffers::String *>(VT_PRODUCT_ID);
	}
	const flatbuffers::String *receipt_data() const {
		return GetPointer<const flatbuffers::String *>(VT_RECEIPT_DATA);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_PRODUCT_ID) &&
				verifier.VerifyString(product_id()) &&
				VerifyOffset(verifier, VT_RECEIPT_DATA) &&
				verifier.VerifyString(receipt_data()) &&
				verifier.EndTable();
	}
	ApplePurchaseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(ApplePurchaseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<ApplePurchase> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ApplePurchaseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct ApplePurchaseBuilder {
	typedef ApplePurchase Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_product_id(flatbuffers::Offset<flatbuffers::String> product_id) {
		fbb_.AddOffset(ApplePurchase::VT_PRODUCT_ID, product_id);
	}
	void add_receipt_data(flatbuffers::Offset<flatbuffers::String> receipt_data) {
		fbb_.AddOffset(ApplePurchase::VT_RECEIPT_DATA, receipt_data);
	}
	explicit ApplePurchaseBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<ApplePurchase> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<ApplePurchase>(end);
		return o;
	}
};

inline flatbuffers::Offset<ApplePurchase> CreateApplePurchase(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> product_id = 0,
		flatbuffers::Offset<flatbuffers::String> receipt_data = 0) {
	ApplePurchaseBuilder builder_(_fbb);
	builder_.add_receipt_data(receipt_data);
	builder_.add_product_id(product_id);
	return builder_.Finish();
}

inline flatbuffers::Offset<ApplePurchase> CreateApplePurchaseDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *product_id = nullptr,
		const char *receipt_data = nullptr) {
	auto product_id__ = product_id ? _fbb.CreateString(product_id) : 0;
	auto receipt_data__ = receipt_data ? _fbb.CreateString(receipt_data) : 0;
	return server::TPurchaseValidation_::CreateApplePurchase(
			_fbb,
			product_id__,
			receipt_data__);
}

flatbuffers::Offset<ApplePurchase> CreateApplePurchase(flatbuffers::FlatBufferBuilder &_fbb, const ApplePurchaseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GooglePurchaseT : public flatbuffers::NativeTable {
	typedef GooglePurchase TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TPurchaseValidation_.GooglePurchaseT";
	}
	CharString product_id;
	CharString product_type;
	CharString purchase_token;
	GooglePurchaseT() {
	}
};

struct GooglePurchase FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef GooglePurchaseT NativeTableType;
	typedef GooglePurchaseBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TPurchaseValidation_.GooglePurchase";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_PRODUCT_ID = 4,
		VT_PRODUCT_TYPE = 6,
		VT_PURCHASE_TOKEN = 8
	};
	const flatbuffers::String *product_id() const {
		return GetPointer<const flatbuffers::String *>(VT_PRODUCT_ID);
	}
	const flatbuffers::String *product_type() const {
		return GetPointer<const flatbuffers::String *>(VT_PRODUCT_TYPE);
	}
	const flatbuffers::String *purchase_token() const {
		return GetPointer<const flatbuffers::String *>(VT_PURCHASE_TOKEN);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_PRODUCT_ID) &&
				verifier.VerifyString(product_id()) &&
				VerifyOffset(verifier, VT_PRODUCT_TYPE) &&
				verifier.VerifyString(product_type()) &&
				VerifyOffset(verifier, VT_PURCHASE_TOKEN) &&
				verifier.VerifyString(purchase_token()) &&
				verifier.EndTable();
	}
	GooglePurchaseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(GooglePurchaseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<GooglePurchase> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GooglePurchaseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct GooglePurchaseBuilder {
	typedef GooglePurchase Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_product_id(flatbuffers::Offset<flatbuffers::String> product_id) {
		fbb_.AddOffset(GooglePurchase::VT_PRODUCT_ID, product_id);
	}
	void add_product_type(flatbuffers::Offset<flatbuffers::String> product_type) {
		fbb_.AddOffset(GooglePurchase::VT_PRODUCT_TYPE, product_type);
	}
	void add_purchase_token(flatbuffers::Offset<flatbuffers::String> purchase_token) {
		fbb_.AddOffset(GooglePurchase::VT_PURCHASE_TOKEN, purchase_token);
	}
	explicit GooglePurchaseBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<GooglePurchase> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<GooglePurchase>(end);
		return o;
	}
};

inline flatbuffers::Offset<GooglePurchase> CreateGooglePurchase(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> product_id = 0,
		flatbuffers::Offset<flatbuffers::String> product_type = 0,
		flatbuffers::Offset<flatbuffers::String> purchase_token = 0) {
	GooglePurchaseBuilder builder_(_fbb);
	builder_.add_purchase_token(purchase_token);
	builder_.add_product_type(product_type);
	builder_.add_product_id(product_id);
	return builder_.Finish();
}

inline flatbuffers::Offset<GooglePurchase> CreateGooglePurchaseDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *product_id = nullptr,
		const char *product_type = nullptr,
		const char *purchase_token = nullptr) {
	auto product_id__ = product_id ? _fbb.CreateString(product_id) : 0;
	auto product_type__ = product_type ? _fbb.CreateString(product_type) : 0;
	auto purchase_token__ = purchase_token ? _fbb.CreateString(purchase_token) : 0;
	return server::TPurchaseValidation_::CreateGooglePurchase(
			_fbb,
			product_id__,
			product_type__,
			purchase_token__);
}

flatbuffers::Offset<GooglePurchase> CreateGooglePurchase(flatbuffers::FlatBufferBuilder &_fbb, const GooglePurchaseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AuthenticateResult7T : public flatbuffers::NativeTable {
	typedef AuthenticateResult7 TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TPurchaseValidation_.AuthenticateResult7T";
	}
	std::unique_ptr<server::TPurchaseValidation_::ApplePurchaseT> apple_purchase;
	std::unique_ptr<server::TPurchaseValidation_::GooglePurchaseT> google_purchase;
	AuthenticateResult7T() {
	}
};

struct AuthenticateResult7 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef AuthenticateResult7T NativeTableType;
	typedef AuthenticateResult7Builder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TPurchaseValidation_.AuthenticateResult7";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_APPLE_PURCHASE = 4,
		VT_GOOGLE_PURCHASE = 6
	};
	const server::TPurchaseValidation_::ApplePurchase *apple_purchase() const {
		return GetPointer<const server::TPurchaseValidation_::ApplePurchase *>(VT_APPLE_PURCHASE);
	}
	const server::TPurchaseValidation_::GooglePurchase *google_purchase() const {
		return GetPointer<const server::TPurchaseValidation_::GooglePurchase *>(VT_GOOGLE_PURCHASE);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_APPLE_PURCHASE) &&
				verifier.VerifyTable(apple_purchase()) &&
				VerifyOffset(verifier, VT_GOOGLE_PURCHASE) &&
				verifier.VerifyTable(google_purchase()) &&
				verifier.EndTable();
	}
	AuthenticateResult7T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(AuthenticateResult7T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<AuthenticateResult7> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateResult7T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct AuthenticateResult7Builder {
	typedef AuthenticateResult7 Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_apple_purchase(flatbuffers::Offset<server::TPurchaseValidation_::ApplePurchase> apple_purchase) {
		fbb_.AddOffset(AuthenticateResult7::VT_APPLE_PURCHASE, apple_purchase);
	}
	void add_google_purchase(flatbuffers::Offset<server::TPurchaseValidation_::GooglePurchase> google_purchase) {
		fbb_.AddOffset(AuthenticateResult7::VT_GOOGLE_PURCHASE, google_purchase);
	}
	explicit AuthenticateResult7Builder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<AuthenticateResult7> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<AuthenticateResult7>(end);
		return o;
	}
};

inline flatbuffers::Offset<AuthenticateResult7> CreateAuthenticateResult7(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<server::TPurchaseValidation_::ApplePurchase> apple_purchase = 0,
		flatbuffers::Offset<server::TPurchaseValidation_::GooglePurchase> google_purchase = 0) {
	AuthenticateResult7Builder builder_(_fbb);
	builder_.add_google_purchase(google_purchase);
	builder_.add_apple_purchase(apple_purchase);
	return builder_.Finish();
}

flatbuffers::Offset<AuthenticateResult7> CreateAuthenticateResult7(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateResult7T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

} // namespace TPurchaseValidation_

struct TPurchaseRecordT : public flatbuffers::NativeTable {
	typedef TPurchaseRecord TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TPurchaseRecordT";
	}
	bool success;
	bool seen_before;
	bool purchase_provider_reachable;
	CharString message;
	CharString data;
	TPurchaseRecordT() :
			success(false),
			seen_before(false),
			purchase_provider_reachable(false) {
	}
};

struct TPurchaseRecord FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TPurchaseRecordT NativeTableType;
	typedef TPurchaseRecordBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TPurchaseRecord";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_SUCCESS = 4,
		VT_SEEN_BEFORE = 6,
		VT_PURCHASE_PROVIDER_REACHABLE = 8,
		VT_MESSAGE = 10,
		VT_DATA = 12
	};
	/// Whether or not the transaction is valid and all the information matches.
	bool success() const {
		return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
	}
	/// If this is a new transaction or if Nakama has a log of it.
	bool seen_before() const {
		return GetField<uint8_t>(VT_SEEN_BEFORE, 0) != 0;
	}
	/// Indicates whether or not Nakama was able to reach the remote purchase service.
	bool purchase_provider_reachable() const {
		return GetField<uint8_t>(VT_PURCHASE_PROVIDER_REACHABLE, 0) != 0;
	}
	/// A string indicating why the purchase verification failed, if appropriate.
	const flatbuffers::String *message() const {
		return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
	}
	/// The complete response Nakama received from the remote service.
	const flatbuffers::String *data() const {
		return GetPointer<const flatbuffers::String *>(VT_DATA);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
				VerifyField<uint8_t>(verifier, VT_SEEN_BEFORE) &&
				VerifyField<uint8_t>(verifier, VT_PURCHASE_PROVIDER_REACHABLE) &&
				VerifyOffset(verifier, VT_MESSAGE) &&
				verifier.VerifyString(message()) &&
				VerifyOffset(verifier, VT_DATA) &&
				verifier.VerifyString(data()) &&
				verifier.EndTable();
	}
	TPurchaseRecordT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TPurchaseRecordT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TPurchaseRecord> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TPurchaseRecordT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TPurchaseRecordBuilder {
	typedef TPurchaseRecord Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_success(bool success) {
		fbb_.AddElement<uint8_t>(TPurchaseRecord::VT_SUCCESS, static_cast<uint8_t>(success), 0);
	}
	void add_seen_before(bool seen_before) {
		fbb_.AddElement<uint8_t>(TPurchaseRecord::VT_SEEN_BEFORE, static_cast<uint8_t>(seen_before), 0);
	}
	void add_purchase_provider_reachable(bool purchase_provider_reachable) {
		fbb_.AddElement<uint8_t>(TPurchaseRecord::VT_PURCHASE_PROVIDER_REACHABLE, static_cast<uint8_t>(purchase_provider_reachable), 0);
	}
	void add_message(flatbuffers::Offset<flatbuffers::String> message) {
		fbb_.AddOffset(TPurchaseRecord::VT_MESSAGE, message);
	}
	void add_data(flatbuffers::Offset<flatbuffers::String> data) {
		fbb_.AddOffset(TPurchaseRecord::VT_DATA, data);
	}
	explicit TPurchaseRecordBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TPurchaseRecord> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TPurchaseRecord>(end);
		return o;
	}
};

inline flatbuffers::Offset<TPurchaseRecord> CreateTPurchaseRecord(
		flatbuffers::FlatBufferBuilder &_fbb,
		bool success = false,
		bool seen_before = false,
		bool purchase_provider_reachable = false,
		flatbuffers::Offset<flatbuffers::String> message = 0,
		flatbuffers::Offset<flatbuffers::String> data = 0) {
	TPurchaseRecordBuilder builder_(_fbb);
	builder_.add_data(data);
	builder_.add_message(message);
	builder_.add_purchase_provider_reachable(purchase_provider_reachable);
	builder_.add_seen_before(seen_before);
	builder_.add_success(success);
	return builder_.Finish();
}

inline flatbuffers::Offset<TPurchaseRecord> CreateTPurchaseRecordDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		bool success = false,
		bool seen_before = false,
		bool purchase_provider_reachable = false,
		const char *message = nullptr,
		const char *data = nullptr) {
	auto message__ = message ? _fbb.CreateString(message) : 0;
	auto data__ = data ? _fbb.CreateString(data) : 0;
	return server::CreateTPurchaseRecord(
			_fbb,
			success,
			seen_before,
			purchase_provider_reachable,
			message__,
			data__);
}

flatbuffers::Offset<TPurchaseRecord> CreateTPurchaseRecord(flatbuffers::FlatBufferBuilder &_fbb, const TPurchaseRecordT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NotificationT : public flatbuffers::NativeTable {
	typedef Notification TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.NotificationT";
	}
	CharString id;
	CharString subject;
	CharString content;
	int64_t code;
	CharString sender_id;
	int64_t created_at;
	int64_t expires_at;
	bool persistent;
	NotificationT() :
			code(0),
			created_at(0),
			expires_at(0),
			persistent(false) {
	}
};

struct Notification FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef NotificationT NativeTableType;
	typedef NotificationBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.Notification";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_ID = 4,
		VT_SUBJECT = 6,
		VT_CONTENT = 8,
		VT_CODE = 10,
		VT_SENDER_ID = 12,
		VT_CREATED_AT = 14,
		VT_EXPIRES_AT = 16,
		VT_PERSISTENT = 18
	};
	const flatbuffers::String *id() const {
		return GetPointer<const flatbuffers::String *>(VT_ID);
	}
	const flatbuffers::String *subject() const {
		return GetPointer<const flatbuffers::String *>(VT_SUBJECT);
	}
	const flatbuffers::String *content() const {
		return GetPointer<const flatbuffers::String *>(VT_CONTENT);
	}
	int64_t code() const {
		return GetField<int64_t>(VT_CODE, 0);
	}
	const flatbuffers::String *sender_id() const {
		return GetPointer<const flatbuffers::String *>(VT_SENDER_ID);
	}
	int64_t created_at() const {
		return GetField<int64_t>(VT_CREATED_AT, 0);
	}
	int64_t expires_at() const {
		return GetField<int64_t>(VT_EXPIRES_AT, 0);
	}
	bool persistent() const {
		return GetField<uint8_t>(VT_PERSISTENT, 0) != 0;
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_ID) &&
				verifier.VerifyString(id()) &&
				VerifyOffset(verifier, VT_SUBJECT) &&
				verifier.VerifyString(subject()) &&
				VerifyOffset(verifier, VT_CONTENT) &&
				verifier.VerifyString(content()) &&
				VerifyField<int64_t>(verifier, VT_CODE) &&
				VerifyOffset(verifier, VT_SENDER_ID) &&
				verifier.VerifyString(sender_id()) &&
				VerifyField<int64_t>(verifier, VT_CREATED_AT) &&
				VerifyField<int64_t>(verifier, VT_EXPIRES_AT) &&
				VerifyField<uint8_t>(verifier, VT_PERSISTENT) &&
				verifier.EndTable();
	}
	NotificationT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(NotificationT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<Notification> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NotificationT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct NotificationBuilder {
	typedef Notification Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_id(flatbuffers::Offset<flatbuffers::String> id) {
		fbb_.AddOffset(Notification::VT_ID, id);
	}
	void add_subject(flatbuffers::Offset<flatbuffers::String> subject) {
		fbb_.AddOffset(Notification::VT_SUBJECT, subject);
	}
	void add_content(flatbuffers::Offset<flatbuffers::String> content) {
		fbb_.AddOffset(Notification::VT_CONTENT, content);
	}
	void add_code(int64_t code) {
		fbb_.AddElement<int64_t>(Notification::VT_CODE, code, 0);
	}
	void add_sender_id(flatbuffers::Offset<flatbuffers::String> sender_id) {
		fbb_.AddOffset(Notification::VT_SENDER_ID, sender_id);
	}
	void add_created_at(int64_t created_at) {
		fbb_.AddElement<int64_t>(Notification::VT_CREATED_AT, created_at, 0);
	}
	void add_expires_at(int64_t expires_at) {
		fbb_.AddElement<int64_t>(Notification::VT_EXPIRES_AT, expires_at, 0);
	}
	void add_persistent(bool persistent) {
		fbb_.AddElement<uint8_t>(Notification::VT_PERSISTENT, static_cast<uint8_t>(persistent), 0);
	}
	explicit NotificationBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<Notification> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Notification>(end);
		return o;
	}
};

inline flatbuffers::Offset<Notification> CreateNotification(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::String> id = 0,
		flatbuffers::Offset<flatbuffers::String> subject = 0,
		flatbuffers::Offset<flatbuffers::String> content = 0,
		int64_t code = 0,
		flatbuffers::Offset<flatbuffers::String> sender_id = 0,
		int64_t created_at = 0,
		int64_t expires_at = 0,
		bool persistent = false) {
	NotificationBuilder builder_(_fbb);
	builder_.add_expires_at(expires_at);
	builder_.add_created_at(created_at);
	builder_.add_code(code);
	builder_.add_sender_id(sender_id);
	builder_.add_content(content);
	builder_.add_subject(subject);
	builder_.add_id(id);
	builder_.add_persistent(persistent);
	return builder_.Finish();
}

inline flatbuffers::Offset<Notification> CreateNotificationDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const char *id = nullptr,
		const char *subject = nullptr,
		const char *content = nullptr,
		int64_t code = 0,
		const char *sender_id = nullptr,
		int64_t created_at = 0,
		int64_t expires_at = 0,
		bool persistent = false) {
	auto id__ = id ? _fbb.CreateString(id) : 0;
	auto subject__ = subject ? _fbb.CreateString(subject) : 0;
	auto content__ = content ? _fbb.CreateString(content) : 0;
	auto sender_id__ = sender_id ? _fbb.CreateString(sender_id) : 0;
	return server::CreateNotification(
			_fbb,
			id__,
			subject__,
			content__,
			code,
			sender_id__,
			created_at,
			expires_at,
			persistent);
}

flatbuffers::Offset<Notification> CreateNotification(flatbuffers::FlatBufferBuilder &_fbb, const NotificationT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NotificationsT : public flatbuffers::NativeTable {
	typedef Notifications TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.NotificationsT";
	}
	std::vector<std::unique_ptr<server::NotificationT>> notifications;
	NotificationsT() {
	}
};

struct Notifications FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef NotificationsT NativeTableType;
	typedef NotificationsBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.Notifications";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_NOTIFICATIONS = 4
	};
	const flatbuffers::Vector<flatbuffers::Offset<server::Notification>> *notifications() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::Notification>> *>(VT_NOTIFICATIONS);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_NOTIFICATIONS) &&
				verifier.VerifyVector(notifications()) &&
				verifier.VerifyVectorOfTables(notifications()) &&
				verifier.EndTable();
	}
	NotificationsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(NotificationsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<Notifications> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NotificationsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct NotificationsBuilder {
	typedef Notifications Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_notifications(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::Notification>>> notifications) {
		fbb_.AddOffset(Notifications::VT_NOTIFICATIONS, notifications);
	}
	explicit NotificationsBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<Notifications> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Notifications>(end);
		return o;
	}
};

inline flatbuffers::Offset<Notifications> CreateNotifications(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::Notification>>> notifications = 0) {
	NotificationsBuilder builder_(_fbb);
	builder_.add_notifications(notifications);
	return builder_.Finish();
}

inline flatbuffers::Offset<Notifications> CreateNotificationsDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<server::Notification>> *notifications = nullptr) {
	auto notifications__ = notifications ? _fbb.CreateVector<flatbuffers::Offset<server::Notification>>(*notifications) : 0;
	return server::CreateNotifications(
			_fbb,
			notifications__);
}

flatbuffers::Offset<Notifications> CreateNotifications(flatbuffers::FlatBufferBuilder &_fbb, const NotificationsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TNotificationsListT : public flatbuffers::NativeTable {
	typedef TNotificationsList TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TNotificationsListT";
	}
	int64_t limit;
	CharString resumable_cursor;
	TNotificationsListT() :
			limit(0) {
	}
};

struct TNotificationsList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TNotificationsListT NativeTableType;
	typedef TNotificationsListBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TNotificationsList";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_LIMIT = 4,
		VT_RESUMABLE_CURSOR = 6
	};
	/// Max number of notifications to list. Between 10 and 100.
	int64_t limit() const {
		return GetField<int64_t>(VT_LIMIT, 0);
	}
	/// Use this cursor to paginate notifications.
	/// Cache this to catch up to new notifications.
	/// The value of this comes from TNotifications.resumable_cursor.
	const flatbuffers::String *resumable_cursor() const {
		return GetPointer<const flatbuffers::String *>(VT_RESUMABLE_CURSOR);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyField<int64_t>(verifier, VT_LIMIT) &&
				VerifyOffset(verifier, VT_RESUMABLE_CURSOR) &&
				verifier.VerifyString(resumable_cursor()) &&
				verifier.EndTable();
	}
	TNotificationsListT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TNotificationsListT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TNotificationsList> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TNotificationsListT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TNotificationsListBuilder {
	typedef TNotificationsList Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_limit(int64_t limit) {
		fbb_.AddElement<int64_t>(TNotificationsList::VT_LIMIT, limit, 0);
	}
	void add_resumable_cursor(flatbuffers::Offset<flatbuffers::String> resumable_cursor) {
		fbb_.AddOffset(TNotificationsList::VT_RESUMABLE_CURSOR, resumable_cursor);
	}
	explicit TNotificationsListBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TNotificationsList> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TNotificationsList>(end);
		return o;
	}
};

inline flatbuffers::Offset<TNotificationsList> CreateTNotificationsList(
		flatbuffers::FlatBufferBuilder &_fbb,
		int64_t limit = 0,
		flatbuffers::Offset<flatbuffers::String> resumable_cursor = 0) {
	TNotificationsListBuilder builder_(_fbb);
	builder_.add_limit(limit);
	builder_.add_resumable_cursor(resumable_cursor);
	return builder_.Finish();
}

inline flatbuffers::Offset<TNotificationsList> CreateTNotificationsListDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		int64_t limit = 0,
		const char *resumable_cursor = nullptr) {
	auto resumable_cursor__ = resumable_cursor ? _fbb.CreateString(resumable_cursor) : 0;
	return server::CreateTNotificationsList(
			_fbb,
			limit,
			resumable_cursor__);
}

flatbuffers::Offset<TNotificationsList> CreateTNotificationsList(flatbuffers::FlatBufferBuilder &_fbb, const TNotificationsListT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TNotificationsT : public flatbuffers::NativeTable {
	typedef TNotifications TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TNotificationsT";
	}
	std::vector<std::unique_ptr<server::NotificationT>> notifications;
	CharString resumable_cursor;
	TNotificationsT() {
	}
};

struct TNotifications FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TNotificationsT NativeTableType;
	typedef TNotificationsBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TNotifications";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_NOTIFICATIONS = 4,
		VT_RESUMABLE_CURSOR = 6
	};
	const flatbuffers::Vector<flatbuffers::Offset<server::Notification>> *notifications() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<server::Notification>> *>(VT_NOTIFICATIONS);
	}
	/// Use this cursor to paginate notifications.
	/// Cache this to catch up to new notifications.
	const flatbuffers::String *resumable_cursor() const {
		return GetPointer<const flatbuffers::String *>(VT_RESUMABLE_CURSOR);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_NOTIFICATIONS) &&
				verifier.VerifyVector(notifications()) &&
				verifier.VerifyVectorOfTables(notifications()) &&
				VerifyOffset(verifier, VT_RESUMABLE_CURSOR) &&
				verifier.VerifyString(resumable_cursor()) &&
				verifier.EndTable();
	}
	TNotificationsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TNotificationsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TNotifications> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TNotificationsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TNotificationsBuilder {
	typedef TNotifications Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_notifications(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::Notification>>> notifications) {
		fbb_.AddOffset(TNotifications::VT_NOTIFICATIONS, notifications);
	}
	void add_resumable_cursor(flatbuffers::Offset<flatbuffers::String> resumable_cursor) {
		fbb_.AddOffset(TNotifications::VT_RESUMABLE_CURSOR, resumable_cursor);
	}
	explicit TNotificationsBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TNotifications> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TNotifications>(end);
		return o;
	}
};

inline flatbuffers::Offset<TNotifications> CreateTNotifications(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<server::Notification>>> notifications = 0,
		flatbuffers::Offset<flatbuffers::String> resumable_cursor = 0) {
	TNotificationsBuilder builder_(_fbb);
	builder_.add_resumable_cursor(resumable_cursor);
	builder_.add_notifications(notifications);
	return builder_.Finish();
}

inline flatbuffers::Offset<TNotifications> CreateTNotificationsDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<server::Notification>> *notifications = nullptr,
		const char *resumable_cursor = nullptr) {
	auto notifications__ = notifications ? _fbb.CreateVector<flatbuffers::Offset<server::Notification>>(*notifications) : 0;
	auto resumable_cursor__ = resumable_cursor ? _fbb.CreateString(resumable_cursor) : 0;
	return server::CreateTNotifications(
			_fbb,
			notifications__,
			resumable_cursor__);
}

flatbuffers::Offset<TNotifications> CreateTNotifications(flatbuffers::FlatBufferBuilder &_fbb, const TNotificationsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TNotificationsRemoveT : public flatbuffers::NativeTable {
	typedef TNotificationsRemove TableType;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TNotificationsRemoveT";
	}
	std::vector<CharString> notification_ids;
	TNotificationsRemoveT() {
	}
};

struct TNotificationsRemove FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef TNotificationsRemoveT NativeTableType;
	typedef TNotificationsRemoveBuilder Builder;
	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "server.TNotificationsRemove";
	}
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_NOTIFICATION_IDS = 4
	};
	const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *notification_ids() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_NOTIFICATION_IDS);
	}
	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
				VerifyOffset(verifier, VT_NOTIFICATION_IDS) &&
				verifier.VerifyVector(notification_ids()) &&
				verifier.VerifyVectorOfStrings(notification_ids()) &&
				verifier.EndTable();
	}
	TNotificationsRemoveT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(TNotificationsRemoveT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static flatbuffers::Offset<TNotificationsRemove> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TNotificationsRemoveT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
	Dictionary UnPackToDict(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
};

struct TNotificationsRemoveBuilder {
	typedef TNotificationsRemove Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_notification_ids(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> notification_ids) {
		fbb_.AddOffset(TNotificationsRemove::VT_NOTIFICATION_IDS, notification_ids);
	}
	explicit TNotificationsRemoveBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
			fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	flatbuffers::Offset<TNotificationsRemove> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TNotificationsRemove>(end);
		return o;
	}
};

inline flatbuffers::Offset<TNotificationsRemove> CreateTNotificationsRemove(
		flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> notification_ids = 0) {
	TNotificationsRemoveBuilder builder_(_fbb);
	builder_.add_notification_ids(notification_ids);
	return builder_.Finish();
}

inline flatbuffers::Offset<TNotificationsRemove> CreateTNotificationsRemoveDirect(
		flatbuffers::FlatBufferBuilder &_fbb,
		const std::vector<flatbuffers::Offset<flatbuffers::String>> *notification_ids = nullptr) {
	auto notification_ids__ = notification_ids ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*notification_ids) : 0;
	return server::CreateTNotificationsRemove(
			_fbb,
			notification_ids__);
}

flatbuffers::Offset<TNotificationsRemove> CreateTNotificationsRemove(flatbuffers::FlatBufferBuilder &_fbb, const TNotificationsRemoveT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline HeartbeatT *Heartbeat::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::HeartbeatT> _o = std::unique_ptr<server::HeartbeatT>(new HeartbeatT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void Heartbeat::UnPackTo(HeartbeatT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = timestamp();
		_o->timestamp = _e;
	}
}

inline flatbuffers::Offset<Heartbeat> Heartbeat::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HeartbeatT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateHeartbeat(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Heartbeat> CreateHeartbeat(flatbuffers::FlatBufferBuilder &_fbb, const HeartbeatT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const HeartbeatT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _timestamp = _o->timestamp;
	return server::CreateHeartbeat(
			_fbb,
			_timestamp);
}

inline Dictionary Heartbeat::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = timestamp();
		_o["timestamp"] = _e;
	}
	return _o;
}

inline ErrorT *Error::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::ErrorT> _o = std::unique_ptr<server::ErrorT>(new ErrorT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void Error::UnPackTo(ErrorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = code();
		_o->code = _e;
	}
	{
		auto _e = message();
		if (_e)
			_o->message = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<Error> Error::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ErrorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateError(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Error> CreateError(flatbuffers::FlatBufferBuilder &_fbb, const ErrorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const ErrorT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _code = _o->code;
	auto _message = _o->message.empty() ? 0 : _fbb.CreateString(_o->message);
	return server::CreateError(
			_fbb,
			_code,
			_message);
}

inline Dictionary Error::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = code();
		_o["code"] = _e;
	}
	{
		auto _e = message();
		if (_e)
			_o["message"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

inline AuthenticateRequestT *AuthenticateRequest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::AuthenticateRequestT> _o = std::unique_ptr<server::AuthenticateRequestT>(new AuthenticateRequestT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void AuthenticateRequest::UnPackTo(AuthenticateRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = collation_id();
		if (_e)
			_o->collation_id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = id();
		if (_e)
			_o->id = std::unique_ptr<server::AuthenticateRequest_::AuthenticateMethodT>(_e->UnPack(_resolver));
	}
}

inline flatbuffers::Offset<AuthenticateRequest> AuthenticateRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateAuthenticateRequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AuthenticateRequest> CreateAuthenticateRequest(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const AuthenticateRequestT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _collation_id = _o->collation_id.empty() ? 0 : _fbb.CreateString(_o->collation_id);
	auto _id = _o->id ? CreateAuthenticateMethod(_fbb, _o->id.get(), _rehasher) : 0;
	return server::CreateAuthenticateRequest(
			_fbb,
			_collation_id,
			_id);
}

inline Dictionary AuthenticateRequest::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = collation_id();
		if (_e)
			_o["collation_id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = id();
		if (_e)
			_o["id"] = _e->UnPackToDict(_resolver);
	}
	return _o;
}

namespace AuthenticateRequest_ {

inline EmailT *Email::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::AuthenticateRequest_::EmailT> _o = std::unique_ptr<server::AuthenticateRequest_::EmailT>(new EmailT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void Email::UnPackTo(EmailT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = email();
		if (_e)
			_o->email = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = password();
		if (_e)
			_o->password = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<Email> Email::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EmailT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateEmail(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Email> CreateEmail(flatbuffers::FlatBufferBuilder &_fbb, const EmailT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const EmailT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _email = _o->email.empty() ? 0 : _fbb.CreateString(_o->email);
	auto _password = _o->password.empty() ? 0 : _fbb.CreateString(_o->password);
	return server::AuthenticateRequest_::CreateEmail(
			_fbb,
			_email,
			_password);
}

inline Dictionary Email::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = email();
		if (_e)
			_o["email"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = password();
		if (_e)
			_o["password"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

inline GameCenterT *GameCenter::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::AuthenticateRequest_::GameCenterT> _o = std::unique_ptr<server::AuthenticateRequest_::GameCenterT>(new GameCenterT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void GameCenter::UnPackTo(GameCenterT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = player_id();
		if (_e)
			_o->player_id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = bundle_id();
		if (_e)
			_o->bundle_id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = timestamp();
		_o->timestamp = _e;
	}
	{
		auto _e = salt();
		if (_e)
			_o->salt = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = signature();
		if (_e)
			_o->signature = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = public_key_url();
		if (_e)
			_o->public_key_url = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<GameCenter> GameCenter::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GameCenterT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateGameCenter(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GameCenter> CreateGameCenter(flatbuffers::FlatBufferBuilder &_fbb, const GameCenterT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const GameCenterT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _player_id = _o->player_id.empty() ? 0 : _fbb.CreateString(_o->player_id);
	auto _bundle_id = _o->bundle_id.empty() ? 0 : _fbb.CreateString(_o->bundle_id);
	auto _timestamp = _o->timestamp;
	auto _salt = _o->salt.empty() ? 0 : _fbb.CreateString(_o->salt);
	auto _signature = _o->signature.empty() ? 0 : _fbb.CreateString(_o->signature);
	auto _public_key_url = _o->public_key_url.empty() ? 0 : _fbb.CreateString(_o->public_key_url);
	return server::AuthenticateRequest_::CreateGameCenter(
			_fbb,
			_player_id,
			_bundle_id,
			_timestamp,
			_salt,
			_signature,
			_public_key_url);
}

inline Dictionary GameCenter::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = player_id();
		if (_e)
			_o["player_id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = bundle_id();
		if (_e)
			_o["bundle_id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = timestamp();
		_o["timestamp"] = _e;
	}
	{
		auto _e = salt();
		if (_e)
			_o["salt"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = signature();
		if (_e)
			_o["signature"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = public_key_url();
		if (_e)
			_o["public_key_url"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

inline AuthenticateMethodT *AuthenticateMethod::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::AuthenticateRequest_::AuthenticateMethodT> _o = std::unique_ptr<server::AuthenticateRequest_::AuthenticateMethodT>(new AuthenticateMethodT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void AuthenticateMethod::UnPackTo(AuthenticateMethodT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = email();
		if (_e)
			_o->email = std::unique_ptr<server::AuthenticateRequest_::EmailT>(_e->UnPack(_resolver));
	}
	{
		auto _e = facebook();
		if (_e)
			_o->facebook = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = google();
		if (_e)
			_o->google = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = game_center();
		if (_e)
			_o->game_center = std::unique_ptr<server::AuthenticateRequest_::GameCenterT>(_e->UnPack(_resolver));
	}
	{
		auto _e = steam();
		if (_e)
			_o->steam = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = device();
		if (_e)
			_o->device = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = custom();
		if (_e)
			_o->custom = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<AuthenticateMethod> AuthenticateMethod::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateMethodT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateAuthenticateMethod(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AuthenticateMethod> CreateAuthenticateMethod(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateMethodT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const AuthenticateMethodT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _email = _o->email ? CreateEmail(_fbb, _o->email.get(), _rehasher) : 0;
	auto _facebook = _o->facebook.empty() ? 0 : _fbb.CreateString(_o->facebook);
	auto _google = _o->google.empty() ? 0 : _fbb.CreateString(_o->google);
	auto _game_center = _o->game_center ? CreateGameCenter(_fbb, _o->game_center.get(), _rehasher) : 0;
	auto _steam = _o->steam.empty() ? 0 : _fbb.CreateString(_o->steam);
	auto _device = _o->device.empty() ? 0 : _fbb.CreateString(_o->device);
	auto _custom = _o->custom.empty() ? 0 : _fbb.CreateString(_o->custom);
	return server::AuthenticateRequest_::CreateAuthenticateMethod(
			_fbb,
			_email,
			_facebook,
			_google,
			_game_center,
			_steam,
			_device,
			_custom);
}

inline Dictionary AuthenticateMethod::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = email();
		if (_e)
			_o["email"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = facebook();
		if (_e)
			_o["facebook"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = google();
		if (_e)
			_o["google"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = game_center();
		if (_e)
			_o["game_center"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = steam();
		if (_e)
			_o["steam"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = device();
		if (_e)
			_o["device"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = custom();
		if (_e)
			_o["custom"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

} // namespace AuthenticateRequest_

inline AuthenticateResponseT *AuthenticateResponse::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::AuthenticateResponseT> _o = std::unique_ptr<server::AuthenticateResponseT>(new AuthenticateResponseT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void AuthenticateResponse::UnPackTo(AuthenticateResponseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = collation_id();
		if (_e)
			_o->collation_id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = id();
		if (_e)
			_o->id = std::unique_ptr<server::AuthenticateResponse_::AuthenticateResultT>(_e->UnPack(_resolver));
	}
}

inline flatbuffers::Offset<AuthenticateResponse> AuthenticateResponse::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateAuthenticateResponse(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AuthenticateResponse> CreateAuthenticateResponse(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const AuthenticateResponseT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _collation_id = _o->collation_id.empty() ? 0 : _fbb.CreateString(_o->collation_id);
	auto _id = _o->id ? CreateAuthenticateResult(_fbb, _o->id.get(), _rehasher) : 0;
	return server::CreateAuthenticateResponse(
			_fbb,
			_collation_id,
			_id);
}

inline Dictionary AuthenticateResponse::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = collation_id();
		if (_e)
			_o["collation_id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = id();
		if (_e)
			_o["id"] = _e->UnPackToDict(_resolver);
	}
	return _o;
}

namespace AuthenticateResponse_ {

inline SessionT *Session::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::AuthenticateResponse_::SessionT> _o = std::unique_ptr<server::AuthenticateResponse_::SessionT>(new SessionT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void Session::UnPackTo(SessionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = token();
		if (_e)
			_o->token = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = udp_token();
		if (_e)
			_o->udp_token = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<Session> Session::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SessionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateSession(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Session> CreateSession(flatbuffers::FlatBufferBuilder &_fbb, const SessionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const SessionT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _token = _o->token.empty() ? 0 : _fbb.CreateString(_o->token);
	auto _udp_token = _o->udp_token.empty() ? 0 : _fbb.CreateString(_o->udp_token);
	return server::AuthenticateResponse_::CreateSession(
			_fbb,
			_token,
			_udp_token);
}

inline Dictionary Session::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = token();
		if (_e)
			_o["token"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = udp_token();
		if (_e)
			_o["udp_token"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

inline ErrorT *Error::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::AuthenticateResponse_::ErrorT> _o = std::unique_ptr<server::AuthenticateResponse_::ErrorT>(new ErrorT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void Error::UnPackTo(ErrorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = code();
		_o->code = _e;
	}
	{
		auto _e = message();
		if (_e)
			_o->message = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = request();
		if (_e)
			_o->request = std::unique_ptr<server::AuthenticateRequestT>(_e->UnPack(_resolver));
	}
}

inline flatbuffers::Offset<Error> Error::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ErrorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateError(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Error> CreateError(flatbuffers::FlatBufferBuilder &_fbb, const ErrorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const ErrorT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _code = _o->code;
	auto _message = _o->message.empty() ? 0 : _fbb.CreateString(_o->message);
	auto _request = _o->request ? CreateAuthenticateRequest(_fbb, _o->request.get(), _rehasher) : 0;
	return server::AuthenticateResponse_::CreateError(
			_fbb,
			_code,
			_message,
			_request);
}

inline Dictionary Error::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = code();
		_o["code"] = _e;
	}
	{
		auto _e = message();
		if (_e)
			_o["message"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = request();
		if (_e)
			_o["request"] = _e->UnPackToDict(_resolver);
	}
	return _o;
}

inline AuthenticateResultT *AuthenticateResult::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::AuthenticateResponse_::AuthenticateResultT> _o = std::unique_ptr<server::AuthenticateResponse_::AuthenticateResultT>(new AuthenticateResultT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void AuthenticateResult::UnPackTo(AuthenticateResultT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = session();
		if (_e)
			_o->session = std::unique_ptr<server::AuthenticateResponse_::SessionT>(_e->UnPack(_resolver));
	}
	{
		auto _e = error();
		if (_e)
			_o->error = std::unique_ptr<server::AuthenticateResponse_::ErrorT>(_e->UnPack(_resolver));
	}
}

inline flatbuffers::Offset<AuthenticateResult> AuthenticateResult::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateResultT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateAuthenticateResult(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AuthenticateResult> CreateAuthenticateResult(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateResultT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const AuthenticateResultT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _session = _o->session ? CreateSession(_fbb, _o->session.get(), _rehasher) : 0;
	auto _error = _o->error ? CreateError(_fbb, _o->error.get(), _rehasher) : 0;
	return server::AuthenticateResponse_::CreateAuthenticateResult(
			_fbb,
			_session,
			_error);
}

inline Dictionary AuthenticateResult::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = session();
		if (_e)
			_o["session"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = error();
		if (_e)
			_o["error"] = _e->UnPackToDict(_resolver);
	}
	return _o;
}

} // namespace AuthenticateResponse_

inline EnvelopeT *Envelope::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::EnvelopeT> _o = std::unique_ptr<server::EnvelopeT>(new EnvelopeT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void Envelope::UnPackTo(EnvelopeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = collation_id();
		if (_e)
			_o->collation_id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = payload();
		if (_e)
			_o->payload = std::unique_ptr<server::Envelope_::EnvelopeContentT>(_e->UnPack(_resolver));
	}
}

inline flatbuffers::Offset<Envelope> Envelope::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EnvelopeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateEnvelope(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Envelope> CreateEnvelope(flatbuffers::FlatBufferBuilder &_fbb, const EnvelopeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const EnvelopeT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _collation_id = _o->collation_id.empty() ? 0 : _fbb.CreateString(_o->collation_id);
	auto _payload = _o->payload ? CreateEnvelopeContent(_fbb, _o->payload.get(), _rehasher) : 0;
	return server::CreateEnvelope(
			_fbb,
			_collation_id,
			_payload);
}

inline Dictionary Envelope::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = collation_id();
		if (_e)
			_o["collation_id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = payload();
		if (_e)
			_o["payload"] = _e->UnPackToDict(_resolver);
	}
	return _o;
}

namespace Envelope_ {

inline EnvelopeContentT *EnvelopeContent::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::Envelope_::EnvelopeContentT> _o = std::unique_ptr<server::Envelope_::EnvelopeContentT>(new EnvelopeContentT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void EnvelopeContent::UnPackTo(EnvelopeContentT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = error();
		if (_e)
			_o->error = std::unique_ptr<server::ErrorT>(_e->UnPack(_resolver));
	}
	{
		auto _e = heartbeat();
		if (_e)
			_o->heartbeat = std::unique_ptr<server::HeartbeatT>(_e->UnPack(_resolver));
	}
	{
		auto _e = logout();
		if (_e)
			_o->logout = std::unique_ptr<server::LogoutT>(_e->UnPack(_resolver));
	}
	{
		auto _e = link();
		if (_e)
			_o->link = std::unique_ptr<server::TLinkT>(_e->UnPack(_resolver));
	}
	{
		auto _e = unlink();
		if (_e)
			_o->unlink = std::unique_ptr<server::TUnlinkT>(_e->UnPack(_resolver));
	}
	{
		auto _e = self_fetch();
		if (_e)
			_o->self_fetch = std::unique_ptr<server::TSelfFetchT>(_e->UnPack(_resolver));
	}
	{
		auto _e = self_update();
		if (_e)
			_o->self_update = std::unique_ptr<server::TSelfUpdateT>(_e->UnPack(_resolver));
	}
	{
		auto _e = users_fetch();
		if (_e)
			_o->users_fetch = std::unique_ptr<server::TUsersFetchT>(_e->UnPack(_resolver));
	}
	{
		auto _e = self();
		if (_e)
			_o->self = std::unique_ptr<server::TSelfT>(_e->UnPack(_resolver));
	}
	{
		auto _e = users();
		if (_e)
			_o->users = std::unique_ptr<server::TUsersT>(_e->UnPack(_resolver));
	}
	{
		auto _e = friends_add();
		if (_e)
			_o->friends_add = std::unique_ptr<server::TFriendsAddT>(_e->UnPack(_resolver));
	}
	{
		auto _e = friends_remove();
		if (_e)
			_o->friends_remove = std::unique_ptr<server::TFriendsRemoveT>(_e->UnPack(_resolver));
	}
	{
		auto _e = friends_block();
		if (_e)
			_o->friends_block = std::unique_ptr<server::TFriendsBlockT>(_e->UnPack(_resolver));
	}
	{
		auto _e = friends_list();
		if (_e)
			_o->friends_list = std::unique_ptr<server::TFriendsListT>(_e->UnPack(_resolver));
	}
	{
		auto _e = friends();
		if (_e)
			_o->friends = std::unique_ptr<server::TFriendsT>(_e->UnPack(_resolver));
	}
	{
		auto _e = groups_create();
		if (_e)
			_o->groups_create = std::unique_ptr<server::TGroupsCreateT>(_e->UnPack(_resolver));
	}
	{
		auto _e = groups_update();
		if (_e)
			_o->groups_update = std::unique_ptr<server::TGroupsUpdateT>(_e->UnPack(_resolver));
	}
	{
		auto _e = groups_remove();
		if (_e)
			_o->groups_remove = std::unique_ptr<server::TGroupsRemoveT>(_e->UnPack(_resolver));
	}
	{
		auto _e = groups_fetch();
		if (_e)
			_o->groups_fetch = std::unique_ptr<server::TGroupsFetchT>(_e->UnPack(_resolver));
	}
	{
		auto _e = groups_list();
		if (_e)
			_o->groups_list = std::unique_ptr<server::TGroupsListT>(_e->UnPack(_resolver));
	}
	{
		auto _e = groups_self_list();
		if (_e)
			_o->groups_self_list = std::unique_ptr<server::TGroupsSelfListT>(_e->UnPack(_resolver));
	}
	{
		auto _e = group_users_list();
		if (_e)
			_o->group_users_list = std::unique_ptr<server::TGroupUsersListT>(_e->UnPack(_resolver));
	}
	{
		auto _e = groups_join();
		if (_e)
			_o->groups_join = std::unique_ptr<server::TGroupsJoinT>(_e->UnPack(_resolver));
	}
	{
		auto _e = groups_leave();
		if (_e)
			_o->groups_leave = std::unique_ptr<server::TGroupsLeaveT>(_e->UnPack(_resolver));
	}
	{
		auto _e = group_users_add();
		if (_e)
			_o->group_users_add = std::unique_ptr<server::TGroupUsersAddT>(_e->UnPack(_resolver));
	}
	{
		auto _e = group_users_kick();
		if (_e)
			_o->group_users_kick = std::unique_ptr<server::TGroupUsersKickT>(_e->UnPack(_resolver));
	}
	{
		auto _e = group_users_promote();
		if (_e)
			_o->group_users_promote = std::unique_ptr<server::TGroupUsersPromoteT>(_e->UnPack(_resolver));
	}
	{
		auto _e = groups();
		if (_e)
			_o->groups = std::unique_ptr<server::TGroupsT>(_e->UnPack(_resolver));
	}
	{
		auto _e = groups_self();
		if (_e)
			_o->groups_self = std::unique_ptr<server::TGroupsSelfT>(_e->UnPack(_resolver));
	}
	{
		auto _e = group_users();
		if (_e)
			_o->group_users = std::unique_ptr<server::TGroupUsersT>(_e->UnPack(_resolver));
	}
	{
		auto _e = topics_join();
		if (_e)
			_o->topics_join = std::unique_ptr<server::TTopicsJoinT>(_e->UnPack(_resolver));
	}
	{
		auto _e = topics_leave();
		if (_e)
			_o->topics_leave = std::unique_ptr<server::TTopicsLeaveT>(_e->UnPack(_resolver));
	}
	{
		auto _e = topic_message_send();
		if (_e)
			_o->topic_message_send = std::unique_ptr<server::TTopicMessageSendT>(_e->UnPack(_resolver));
	}
	{
		auto _e = topic_messages_list();
		if (_e)
			_o->topic_messages_list = std::unique_ptr<server::TTopicMessagesListT>(_e->UnPack(_resolver));
	}
	{
		auto _e = topics();
		if (_e)
			_o->topics = std::unique_ptr<server::TTopicsT>(_e->UnPack(_resolver));
	}
	{
		auto _e = topic_message_ack();
		if (_e)
			_o->topic_message_ack = std::unique_ptr<server::TTopicMessageAckT>(_e->UnPack(_resolver));
	}
	{
		auto _e = topic_message();
		if (_e)
			_o->topic_message = std::unique_ptr<server::TopicMessageT>(_e->UnPack(_resolver));
	}
	{
		auto _e = topic_messages();
		if (_e)
			_o->topic_messages = std::unique_ptr<server::TTopicMessagesT>(_e->UnPack(_resolver));
	}
	{
		auto _e = topic_presence();
		if (_e)
			_o->topic_presence = std::unique_ptr<server::TopicPresenceT>(_e->UnPack(_resolver));
	}
	{
		auto _e = match_create();
		if (_e)
			_o->match_create = std::unique_ptr<server::TMatchCreateT>(_e->UnPack(_resolver));
	}
	{
		auto _e = matches_join();
		if (_e)
			_o->matches_join = std::unique_ptr<server::TMatchesJoinT>(_e->UnPack(_resolver));
	}
	{
		auto _e = matches_leave();
		if (_e)
			_o->matches_leave = std::unique_ptr<server::TMatchesLeaveT>(_e->UnPack(_resolver));
	}
	{
		auto _e = match_data_send();
		if (_e)
			_o->match_data_send = std::unique_ptr<server::MatchDataSendT>(_e->UnPack(_resolver));
	}
	{
		auto _e = match();
		if (_e)
			_o->match = std::unique_ptr<server::TMatchT>(_e->UnPack(_resolver));
	}
	{
		auto _e = matches();
		if (_e)
			_o->matches = std::unique_ptr<server::TMatchesT>(_e->UnPack(_resolver));
	}
	{
		auto _e = match_data();
		if (_e)
			_o->match_data = std::unique_ptr<server::MatchDataT>(_e->UnPack(_resolver));
	}
	{
		auto _e = match_presence();
		if (_e)
			_o->match_presence = std::unique_ptr<server::MatchPresenceT>(_e->UnPack(_resolver));
	}
	{
		auto _e = storage_list();
		if (_e)
			_o->storage_list = std::unique_ptr<server::TStorageListT>(_e->UnPack(_resolver));
	}
	{
		auto _e = storage_fetch();
		if (_e)
			_o->storage_fetch = std::unique_ptr<server::TStorageFetchT>(_e->UnPack(_resolver));
	}
	{
		auto _e = storage_write();
		if (_e)
			_o->storage_write = std::unique_ptr<server::TStorageWriteT>(_e->UnPack(_resolver));
	}
	{
		auto _e = storage_update();
		if (_e)
			_o->storage_update = std::unique_ptr<server::TStorageUpdateT>(_e->UnPack(_resolver));
	}
	{
		auto _e = storage_remove();
		if (_e)
			_o->storage_remove = std::unique_ptr<server::TStorageRemoveT>(_e->UnPack(_resolver));
	}
	{
		auto _e = storage_data();
		if (_e)
			_o->storage_data = std::unique_ptr<server::TStorageDataT>(_e->UnPack(_resolver));
	}
	{
		auto _e = storage_keys();
		if (_e)
			_o->storage_keys = std::unique_ptr<server::TStorageKeysT>(_e->UnPack(_resolver));
	}
	{
		auto _e = leaderboards_list();
		if (_e)
			_o->leaderboards_list = std::unique_ptr<server::TLeaderboardsListT>(_e->UnPack(_resolver));
	}
	{
		auto _e = leaderboard_records_write();
		if (_e)
			_o->leaderboard_records_write = std::unique_ptr<server::TLeaderboardRecordsWriteT>(_e->UnPack(_resolver));
	}
	{
		auto _e = leaderboard_records_fetch();
		if (_e)
			_o->leaderboard_records_fetch = std::unique_ptr<server::TLeaderboardRecordsFetchT>(_e->UnPack(_resolver));
	}
	{
		auto _e = leaderboard_records_list();
		if (_e)
			_o->leaderboard_records_list = std::unique_ptr<server::TLeaderboardRecordsListT>(_e->UnPack(_resolver));
	}
	{
		auto _e = leaderboards();
		if (_e)
			_o->leaderboards = std::unique_ptr<server::TLeaderboardsT>(_e->UnPack(_resolver));
	}
	{
		auto _e = leaderboard_records();
		if (_e)
			_o->leaderboard_records = std::unique_ptr<server::TLeaderboardRecordsT>(_e->UnPack(_resolver));
	}
	{
		auto _e = matchmake_add();
		if (_e)
			_o->matchmake_add = std::unique_ptr<server::TMatchmakeAddT>(_e->UnPack(_resolver));
	}
	{
		auto _e = matchmake_remove();
		if (_e)
			_o->matchmake_remove = std::unique_ptr<server::TMatchmakeRemoveT>(_e->UnPack(_resolver));
	}
	{
		auto _e = matchmake_ticket();
		if (_e)
			_o->matchmake_ticket = std::unique_ptr<server::TMatchmakeTicketT>(_e->UnPack(_resolver));
	}
	{
		auto _e = matchmake_matched();
		if (_e)
			_o->matchmake_matched = std::unique_ptr<server::MatchmakeMatchedT>(_e->UnPack(_resolver));
	}
	{
		auto _e = rpc();
		if (_e)
			_o->rpc = std::unique_ptr<server::TRpcT>(_e->UnPack(_resolver));
	}
	{
		auto _e = purchase();
		if (_e)
			_o->purchase = std::unique_ptr<server::TPurchaseValidationT>(_e->UnPack(_resolver));
	}
	{
		auto _e = purchase_record();
		if (_e)
			_o->purchase_record = std::unique_ptr<server::TPurchaseRecordT>(_e->UnPack(_resolver));
	}
	{
		auto _e = notifications_list();
		if (_e)
			_o->notifications_list = std::unique_ptr<server::TNotificationsListT>(_e->UnPack(_resolver));
	}
	{
		auto _e = notifications_remove();
		if (_e)
			_o->notifications_remove = std::unique_ptr<server::TNotificationsRemoveT>(_e->UnPack(_resolver));
	}
	{
		auto _e = notifications();
		if (_e)
			_o->notifications = std::unique_ptr<server::TNotificationsT>(_e->UnPack(_resolver));
	}
	{
		auto _e = live_notifications();
		if (_e)
			_o->live_notifications = std::unique_ptr<server::NotificationsT>(_e->UnPack(_resolver));
	}
}

inline flatbuffers::Offset<EnvelopeContent> EnvelopeContent::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EnvelopeContentT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateEnvelopeContent(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EnvelopeContent> CreateEnvelopeContent(flatbuffers::FlatBufferBuilder &_fbb, const EnvelopeContentT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const EnvelopeContentT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _error = _o->error ? CreateError(_fbb, _o->error.get(), _rehasher) : 0;
	auto _heartbeat = _o->heartbeat ? CreateHeartbeat(_fbb, _o->heartbeat.get(), _rehasher) : 0;
	auto _logout = _o->logout ? CreateLogout(_fbb, _o->logout.get(), _rehasher) : 0;
	auto _link = _o->link ? CreateTLink(_fbb, _o->link.get(), _rehasher) : 0;
	auto _unlink = _o->unlink ? CreateTUnlink(_fbb, _o->unlink.get(), _rehasher) : 0;
	auto _self_fetch = _o->self_fetch ? CreateTSelfFetch(_fbb, _o->self_fetch.get(), _rehasher) : 0;
	auto _self_update = _o->self_update ? CreateTSelfUpdate(_fbb, _o->self_update.get(), _rehasher) : 0;
	auto _users_fetch = _o->users_fetch ? CreateTUsersFetch(_fbb, _o->users_fetch.get(), _rehasher) : 0;
	auto _self = _o->self ? CreateTSelf(_fbb, _o->self.get(), _rehasher) : 0;
	auto _users = _o->users ? CreateTUsers(_fbb, _o->users.get(), _rehasher) : 0;
	auto _friends_add = _o->friends_add ? CreateTFriendsAdd(_fbb, _o->friends_add.get(), _rehasher) : 0;
	auto _friends_remove = _o->friends_remove ? CreateTFriendsRemove(_fbb, _o->friends_remove.get(), _rehasher) : 0;
	auto _friends_block = _o->friends_block ? CreateTFriendsBlock(_fbb, _o->friends_block.get(), _rehasher) : 0;
	auto _friends_list = _o->friends_list ? CreateTFriendsList(_fbb, _o->friends_list.get(), _rehasher) : 0;
	auto _friends = _o->friends ? CreateTFriends(_fbb, _o->friends.get(), _rehasher) : 0;
	auto _groups_create = _o->groups_create ? CreateTGroupsCreate(_fbb, _o->groups_create.get(), _rehasher) : 0;
	auto _groups_update = _o->groups_update ? CreateTGroupsUpdate(_fbb, _o->groups_update.get(), _rehasher) : 0;
	auto _groups_remove = _o->groups_remove ? CreateTGroupsRemove(_fbb, _o->groups_remove.get(), _rehasher) : 0;
	auto _groups_fetch = _o->groups_fetch ? CreateTGroupsFetch(_fbb, _o->groups_fetch.get(), _rehasher) : 0;
	auto _groups_list = _o->groups_list ? CreateTGroupsList(_fbb, _o->groups_list.get(), _rehasher) : 0;
	auto _groups_self_list = _o->groups_self_list ? CreateTGroupsSelfList(_fbb, _o->groups_self_list.get(), _rehasher) : 0;
	auto _group_users_list = _o->group_users_list ? CreateTGroupUsersList(_fbb, _o->group_users_list.get(), _rehasher) : 0;
	auto _groups_join = _o->groups_join ? CreateTGroupsJoin(_fbb, _o->groups_join.get(), _rehasher) : 0;
	auto _groups_leave = _o->groups_leave ? CreateTGroupsLeave(_fbb, _o->groups_leave.get(), _rehasher) : 0;
	auto _group_users_add = _o->group_users_add ? CreateTGroupUsersAdd(_fbb, _o->group_users_add.get(), _rehasher) : 0;
	auto _group_users_kick = _o->group_users_kick ? CreateTGroupUsersKick(_fbb, _o->group_users_kick.get(), _rehasher) : 0;
	auto _group_users_promote = _o->group_users_promote ? CreateTGroupUsersPromote(_fbb, _o->group_users_promote.get(), _rehasher) : 0;
	auto _groups = _o->groups ? CreateTGroups(_fbb, _o->groups.get(), _rehasher) : 0;
	auto _groups_self = _o->groups_self ? CreateTGroupsSelf(_fbb, _o->groups_self.get(), _rehasher) : 0;
	auto _group_users = _o->group_users ? CreateTGroupUsers(_fbb, _o->group_users.get(), _rehasher) : 0;
	auto _topics_join = _o->topics_join ? CreateTTopicsJoin(_fbb, _o->topics_join.get(), _rehasher) : 0;
	auto _topics_leave = _o->topics_leave ? CreateTTopicsLeave(_fbb, _o->topics_leave.get(), _rehasher) : 0;
	auto _topic_message_send = _o->topic_message_send ? CreateTTopicMessageSend(_fbb, _o->topic_message_send.get(), _rehasher) : 0;
	auto _topic_messages_list = _o->topic_messages_list ? CreateTTopicMessagesList(_fbb, _o->topic_messages_list.get(), _rehasher) : 0;
	auto _topics = _o->topics ? CreateTTopics(_fbb, _o->topics.get(), _rehasher) : 0;
	auto _topic_message_ack = _o->topic_message_ack ? CreateTTopicMessageAck(_fbb, _o->topic_message_ack.get(), _rehasher) : 0;
	auto _topic_message = _o->topic_message ? CreateTopicMessage(_fbb, _o->topic_message.get(), _rehasher) : 0;
	auto _topic_messages = _o->topic_messages ? CreateTTopicMessages(_fbb, _o->topic_messages.get(), _rehasher) : 0;
	auto _topic_presence = _o->topic_presence ? CreateTopicPresence(_fbb, _o->topic_presence.get(), _rehasher) : 0;
	auto _match_create = _o->match_create ? CreateTMatchCreate(_fbb, _o->match_create.get(), _rehasher) : 0;
	auto _matches_join = _o->matches_join ? CreateTMatchesJoin(_fbb, _o->matches_join.get(), _rehasher) : 0;
	auto _matches_leave = _o->matches_leave ? CreateTMatchesLeave(_fbb, _o->matches_leave.get(), _rehasher) : 0;
	auto _match_data_send = _o->match_data_send ? CreateMatchDataSend(_fbb, _o->match_data_send.get(), _rehasher) : 0;
	auto _match = _o->match ? CreateTMatch(_fbb, _o->match.get(), _rehasher) : 0;
	auto _matches = _o->matches ? CreateTMatches(_fbb, _o->matches.get(), _rehasher) : 0;
	auto _match_data = _o->match_data ? CreateMatchData(_fbb, _o->match_data.get(), _rehasher) : 0;
	auto _match_presence = _o->match_presence ? CreateMatchPresence(_fbb, _o->match_presence.get(), _rehasher) : 0;
	auto _storage_list = _o->storage_list ? CreateTStorageList(_fbb, _o->storage_list.get(), _rehasher) : 0;
	auto _storage_fetch = _o->storage_fetch ? CreateTStorageFetch(_fbb, _o->storage_fetch.get(), _rehasher) : 0;
	auto _storage_write = _o->storage_write ? CreateTStorageWrite(_fbb, _o->storage_write.get(), _rehasher) : 0;
	auto _storage_update = _o->storage_update ? CreateTStorageUpdate(_fbb, _o->storage_update.get(), _rehasher) : 0;
	auto _storage_remove = _o->storage_remove ? CreateTStorageRemove(_fbb, _o->storage_remove.get(), _rehasher) : 0;
	auto _storage_data = _o->storage_data ? CreateTStorageData(_fbb, _o->storage_data.get(), _rehasher) : 0;
	auto _storage_keys = _o->storage_keys ? CreateTStorageKeys(_fbb, _o->storage_keys.get(), _rehasher) : 0;
	auto _leaderboards_list = _o->leaderboards_list ? CreateTLeaderboardsList(_fbb, _o->leaderboards_list.get(), _rehasher) : 0;
	auto _leaderboard_records_write = _o->leaderboard_records_write ? CreateTLeaderboardRecordsWrite(_fbb, _o->leaderboard_records_write.get(), _rehasher) : 0;
	auto _leaderboard_records_fetch = _o->leaderboard_records_fetch ? CreateTLeaderboardRecordsFetch(_fbb, _o->leaderboard_records_fetch.get(), _rehasher) : 0;
	auto _leaderboard_records_list = _o->leaderboard_records_list ? CreateTLeaderboardRecordsList(_fbb, _o->leaderboard_records_list.get(), _rehasher) : 0;
	auto _leaderboards = _o->leaderboards ? CreateTLeaderboards(_fbb, _o->leaderboards.get(), _rehasher) : 0;
	auto _leaderboard_records = _o->leaderboard_records ? CreateTLeaderboardRecords(_fbb, _o->leaderboard_records.get(), _rehasher) : 0;
	auto _matchmake_add = _o->matchmake_add ? CreateTMatchmakeAdd(_fbb, _o->matchmake_add.get(), _rehasher) : 0;
	auto _matchmake_remove = _o->matchmake_remove ? CreateTMatchmakeRemove(_fbb, _o->matchmake_remove.get(), _rehasher) : 0;
	auto _matchmake_ticket = _o->matchmake_ticket ? CreateTMatchmakeTicket(_fbb, _o->matchmake_ticket.get(), _rehasher) : 0;
	auto _matchmake_matched = _o->matchmake_matched ? CreateMatchmakeMatched(_fbb, _o->matchmake_matched.get(), _rehasher) : 0;
	auto _rpc = _o->rpc ? CreateTRpc(_fbb, _o->rpc.get(), _rehasher) : 0;
	auto _purchase = _o->purchase ? CreateTPurchaseValidation(_fbb, _o->purchase.get(), _rehasher) : 0;
	auto _purchase_record = _o->purchase_record ? CreateTPurchaseRecord(_fbb, _o->purchase_record.get(), _rehasher) : 0;
	auto _notifications_list = _o->notifications_list ? CreateTNotificationsList(_fbb, _o->notifications_list.get(), _rehasher) : 0;
	auto _notifications_remove = _o->notifications_remove ? CreateTNotificationsRemove(_fbb, _o->notifications_remove.get(), _rehasher) : 0;
	auto _notifications = _o->notifications ? CreateTNotifications(_fbb, _o->notifications.get(), _rehasher) : 0;
	auto _live_notifications = _o->live_notifications ? CreateNotifications(_fbb, _o->live_notifications.get(), _rehasher) : 0;
	return server::Envelope_::CreateEnvelopeContent(
			_fbb,
			_error,
			_heartbeat,
			_logout,
			_link,
			_unlink,
			_self_fetch,
			_self_update,
			_users_fetch,
			_self,
			_users,
			_friends_add,
			_friends_remove,
			_friends_block,
			_friends_list,
			_friends,
			_groups_create,
			_groups_update,
			_groups_remove,
			_groups_fetch,
			_groups_list,
			_groups_self_list,
			_group_users_list,
			_groups_join,
			_groups_leave,
			_group_users_add,
			_group_users_kick,
			_group_users_promote,
			_groups,
			_groups_self,
			_group_users,
			_topics_join,
			_topics_leave,
			_topic_message_send,
			_topic_messages_list,
			_topics,
			_topic_message_ack,
			_topic_message,
			_topic_messages,
			_topic_presence,
			_match_create,
			_matches_join,
			_matches_leave,
			_match_data_send,
			_match,
			_matches,
			_match_data,
			_match_presence,
			_storage_list,
			_storage_fetch,
			_storage_write,
			_storage_update,
			_storage_remove,
			_storage_data,
			_storage_keys,
			_leaderboards_list,
			_leaderboard_records_write,
			_leaderboard_records_fetch,
			_leaderboard_records_list,
			_leaderboards,
			_leaderboard_records,
			_matchmake_add,
			_matchmake_remove,
			_matchmake_ticket,
			_matchmake_matched,
			_rpc,
			_purchase,
			_purchase_record,
			_notifications_list,
			_notifications_remove,
			_notifications,
			_live_notifications);
}

inline Dictionary EnvelopeContent::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = error();
		if (_e)
			_o["error"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = heartbeat();
		if (_e)
			_o["heartbeat"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = logout();
		if (_e)
			_o["logout"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = link();
		if (_e)
			_o["link"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = unlink();
		if (_e)
			_o["unlink"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = self_fetch();
		if (_e)
			_o["self_fetch"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = self_update();
		if (_e)
			_o["self_update"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = users_fetch();
		if (_e)
			_o["users_fetch"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = self();
		if (_e)
			_o["self"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = users();
		if (_e)
			_o["users"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = friends_add();
		if (_e)
			_o["friends_add"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = friends_remove();
		if (_e)
			_o["friends_remove"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = friends_block();
		if (_e)
			_o["friends_block"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = friends_list();
		if (_e)
			_o["friends_list"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = friends();
		if (_e)
			_o["friends"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = groups_create();
		if (_e)
			_o["groups_create"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = groups_update();
		if (_e)
			_o["groups_update"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = groups_remove();
		if (_e)
			_o["groups_remove"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = groups_fetch();
		if (_e)
			_o["groups_fetch"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = groups_list();
		if (_e)
			_o["groups_list"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = groups_self_list();
		if (_e)
			_o["groups_self_list"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = group_users_list();
		if (_e)
			_o["group_users_list"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = groups_join();
		if (_e)
			_o["groups_join"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = groups_leave();
		if (_e)
			_o["groups_leave"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = group_users_add();
		if (_e)
			_o["group_users_add"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = group_users_kick();
		if (_e)
			_o["group_users_kick"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = group_users_promote();
		if (_e)
			_o["group_users_promote"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = groups();
		if (_e)
			_o["groups"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = groups_self();
		if (_e)
			_o["groups_self"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = group_users();
		if (_e)
			_o["group_users"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = topics_join();
		if (_e)
			_o["topics_join"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = topics_leave();
		if (_e)
			_o["topics_leave"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = topic_message_send();
		if (_e)
			_o["topic_message_send"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = topic_messages_list();
		if (_e)
			_o["topic_messages_list"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = topics();
		if (_e)
			_o["topics"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = topic_message_ack();
		if (_e)
			_o["topic_message_ack"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = topic_message();
		if (_e)
			_o["topic_message"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = topic_messages();
		if (_e)
			_o["topic_messages"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = topic_presence();
		if (_e)
			_o["topic_presence"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = match_create();
		if (_e)
			_o["match_create"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = matches_join();
		if (_e)
			_o["matches_join"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = matches_leave();
		if (_e)
			_o["matches_leave"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = match_data_send();
		if (_e)
			_o["match_data_send"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = match();
		if (_e)
			_o["match"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = matches();
		if (_e)
			_o["matches"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = match_data();
		if (_e)
			_o["match_data"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = match_presence();
		if (_e)
			_o["match_presence"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = storage_list();
		if (_e)
			_o["storage_list"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = storage_fetch();
		if (_e)
			_o["storage_fetch"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = storage_write();
		if (_e)
			_o["storage_write"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = storage_update();
		if (_e)
			_o["storage_update"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = storage_remove();
		if (_e)
			_o["storage_remove"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = storage_data();
		if (_e)
			_o["storage_data"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = storage_keys();
		if (_e)
			_o["storage_keys"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = leaderboards_list();
		if (_e)
			_o["leaderboards_list"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = leaderboard_records_write();
		if (_e)
			_o["leaderboard_records_write"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = leaderboard_records_fetch();
		if (_e)
			_o["leaderboard_records_fetch"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = leaderboard_records_list();
		if (_e)
			_o["leaderboard_records_list"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = leaderboards();
		if (_e)
			_o["leaderboards"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = leaderboard_records();
		if (_e)
			_o["leaderboard_records"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = matchmake_add();
		if (_e)
			_o["matchmake_add"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = matchmake_remove();
		if (_e)
			_o["matchmake_remove"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = matchmake_ticket();
		if (_e)
			_o["matchmake_ticket"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = matchmake_matched();
		if (_e)
			_o["matchmake_matched"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = rpc();
		if (_e)
			_o["rpc"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = purchase();
		if (_e)
			_o["purchase"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = purchase_record();
		if (_e)
			_o["purchase_record"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = notifications_list();
		if (_e)
			_o["notifications_list"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = notifications_remove();
		if (_e)
			_o["notifications_remove"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = notifications();
		if (_e)
			_o["notifications"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = live_notifications();
		if (_e)
			_o["live_notifications"] = _e->UnPackToDict(_resolver);
	}
	return _o;
}

} // namespace Envelope_

inline LogoutT *Logout::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::LogoutT> _o = std::unique_ptr<server::LogoutT>(new LogoutT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void Logout::UnPackTo(LogoutT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
}

inline flatbuffers::Offset<Logout> Logout::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogoutT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateLogout(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Logout> CreateLogout(flatbuffers::FlatBufferBuilder &_fbb, const LogoutT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const LogoutT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	return server::CreateLogout(
			_fbb);
}

inline Dictionary Logout::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	return _o;
}

inline TLinkT *TLink::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TLinkT> _o = std::unique_ptr<server::TLinkT>(new TLinkT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TLink::UnPackTo(TLinkT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = id();
		if (_e)
			_o->id = std::unique_ptr<server::TLink_::Anonymous3T>(_e->UnPack(_resolver));
	}
}

inline flatbuffers::Offset<TLink> TLink::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TLinkT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTLink(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TLink> CreateTLink(flatbuffers::FlatBufferBuilder &_fbb, const TLinkT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TLinkT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _id = _o->id ? CreateAnonymous3(_fbb, _o->id.get(), _rehasher) : 0;
	return server::CreateTLink(
			_fbb,
			_id);
}

inline Dictionary TLink::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = id();
		if (_e)
			_o["id"] = _e->UnPackToDict(_resolver);
	}
	return _o;
}

namespace TLink_ {

inline Anonymous3T *Anonymous3::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TLink_::Anonymous3T> _o = std::unique_ptr<server::TLink_::Anonymous3T>(new Anonymous3T());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void Anonymous3::UnPackTo(Anonymous3T *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = email();
		if (_e)
			_o->email = std::unique_ptr<server::AuthenticateRequest_::EmailT>(_e->UnPack(_resolver));
	}
	{
		auto _e = facebook();
		if (_e)
			_o->facebook = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = google();
		if (_e)
			_o->google = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = game_center();
		if (_e)
			_o->game_center = std::unique_ptr<server::AuthenticateRequest_::GameCenterT>(_e->UnPack(_resolver));
	}
	{
		auto _e = steam();
		if (_e)
			_o->steam = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = device();
		if (_e)
			_o->device = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = custom();
		if (_e)
			_o->custom = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<Anonymous3> Anonymous3::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Anonymous3T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateAnonymous3(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Anonymous3> CreateAnonymous3(flatbuffers::FlatBufferBuilder &_fbb, const Anonymous3T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const Anonymous3T *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _email = _o->email ? CreateEmail(_fbb, _o->email.get(), _rehasher) : 0;
	auto _facebook = _o->facebook.empty() ? 0 : _fbb.CreateString(_o->facebook);
	auto _google = _o->google.empty() ? 0 : _fbb.CreateString(_o->google);
	auto _game_center = _o->game_center ? CreateGameCenter(_fbb, _o->game_center.get(), _rehasher) : 0;
	auto _steam = _o->steam.empty() ? 0 : _fbb.CreateString(_o->steam);
	auto _device = _o->device.empty() ? 0 : _fbb.CreateString(_o->device);
	auto _custom = _o->custom.empty() ? 0 : _fbb.CreateString(_o->custom);
	return server::TLink_::CreateAnonymous3(
			_fbb,
			_email,
			_facebook,
			_google,
			_game_center,
			_steam,
			_device,
			_custom);
}

inline Dictionary Anonymous3::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = email();
		if (_e)
			_o["email"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = facebook();
		if (_e)
			_o["facebook"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = google();
		if (_e)
			_o["google"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = game_center();
		if (_e)
			_o["game_center"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = steam();
		if (_e)
			_o["steam"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = device();
		if (_e)
			_o["device"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = custom();
		if (_e)
			_o["custom"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

} // namespace TLink_

inline TUnlinkT *TUnlink::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TUnlinkT> _o = std::unique_ptr<server::TUnlinkT>(new TUnlinkT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TUnlink::UnPackTo(TUnlinkT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = id();
		if (_e)
			_o->id = std::unique_ptr<server::TUnlink_::Anonymous4T>(_e->UnPack(_resolver));
	}
}

inline flatbuffers::Offset<TUnlink> TUnlink::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TUnlinkT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTUnlink(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TUnlink> CreateTUnlink(flatbuffers::FlatBufferBuilder &_fbb, const TUnlinkT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TUnlinkT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _id = _o->id ? CreateAnonymous4(_fbb, _o->id.get(), _rehasher) : 0;
	return server::CreateTUnlink(
			_fbb,
			_id);
}

inline Dictionary TUnlink::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = id();
		if (_e)
			_o["id"] = _e->UnPackToDict(_resolver);
	}
	return _o;
}

namespace TUnlink_ {

inline Anonymous4T *Anonymous4::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TUnlink_::Anonymous4T> _o = std::unique_ptr<server::TUnlink_::Anonymous4T>(new Anonymous4T());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void Anonymous4::UnPackTo(Anonymous4T *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = email();
		if (_e)
			_o->email = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = facebook();
		if (_e)
			_o->facebook = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = google();
		if (_e)
			_o->google = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = game_center();
		if (_e)
			_o->game_center = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = steam();
		if (_e)
			_o->steam = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = device();
		if (_e)
			_o->device = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = custom();
		if (_e)
			_o->custom = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<Anonymous4> Anonymous4::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Anonymous4T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateAnonymous4(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Anonymous4> CreateAnonymous4(flatbuffers::FlatBufferBuilder &_fbb, const Anonymous4T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const Anonymous4T *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _email = _o->email.empty() ? 0 : _fbb.CreateString(_o->email);
	auto _facebook = _o->facebook.empty() ? 0 : _fbb.CreateString(_o->facebook);
	auto _google = _o->google.empty() ? 0 : _fbb.CreateString(_o->google);
	auto _game_center = _o->game_center.empty() ? 0 : _fbb.CreateString(_o->game_center);
	auto _steam = _o->steam.empty() ? 0 : _fbb.CreateString(_o->steam);
	auto _device = _o->device.empty() ? 0 : _fbb.CreateString(_o->device);
	auto _custom = _o->custom.empty() ? 0 : _fbb.CreateString(_o->custom);
	return server::TUnlink_::CreateAnonymous4(
			_fbb,
			_email,
			_facebook,
			_google,
			_game_center,
			_steam,
			_device,
			_custom);
}

inline Dictionary Anonymous4::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = email();
		if (_e)
			_o["email"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = facebook();
		if (_e)
			_o["facebook"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = google();
		if (_e)
			_o["google"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = game_center();
		if (_e)
			_o["game_center"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = steam();
		if (_e)
			_o["steam"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = device();
		if (_e)
			_o["device"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = custom();
		if (_e)
			_o["custom"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

} // namespace TUnlink_

inline UserT *User::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::UserT> _o = std::unique_ptr<server::UserT>(new UserT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void User::UnPackTo(UserT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = id();
		if (_e)
			_o->id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = handle();
		if (_e)
			_o->handle = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = fullname();
		if (_e)
			_o->fullname = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = avatar_url();
		if (_e)
			_o->avatar_url = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = lang();
		if (_e)
			_o->lang = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = location();
		if (_e)
			_o->location = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = timezone();
		if (_e)
			_o->timezone = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = metadata();
		if (_e)
			_o->metadata = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = created_at();
		_o->created_at = _e;
	}
	{
		auto _e = updated_at();
		_o->updated_at = _e;
	}
	{
		auto _e = last_online_at();
		_o->last_online_at = _e;
	}
}

inline flatbuffers::Offset<User> User::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UserT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateUser(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<User> CreateUser(flatbuffers::FlatBufferBuilder &_fbb, const UserT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const UserT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
	auto _handle = _o->handle.empty() ? 0 : _fbb.CreateString(_o->handle);
	auto _fullname = _o->fullname.empty() ? 0 : _fbb.CreateString(_o->fullname);
	auto _avatar_url = _o->avatar_url.empty() ? 0 : _fbb.CreateString(_o->avatar_url);
	auto _lang = _o->lang.empty() ? 0 : _fbb.CreateString(_o->lang);
	auto _location = _o->location.empty() ? 0 : _fbb.CreateString(_o->location);
	auto _timezone = _o->timezone.empty() ? 0 : _fbb.CreateString(_o->timezone);
	auto _metadata = _o->metadata.empty() ? 0 : _fbb.CreateString(_o->metadata);
	auto _created_at = _o->created_at;
	auto _updated_at = _o->updated_at;
	auto _last_online_at = _o->last_online_at;
	return server::CreateUser(
			_fbb,
			_id,
			_handle,
			_fullname,
			_avatar_url,
			_lang,
			_location,
			_timezone,
			_metadata,
			_created_at,
			_updated_at,
			_last_online_at);
}

inline Dictionary User::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = id();
		if (_e)
			_o["id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = handle();
		if (_e)
			_o["handle"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = fullname();
		if (_e)
			_o["fullname"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = avatar_url();
		if (_e)
			_o["avatar_url"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = lang();
		if (_e)
			_o["lang"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = location();
		if (_e)
			_o["location"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = timezone();
		if (_e)
			_o["timezone"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = metadata();
		if (_e)
			_o["metadata"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = created_at();
		_o["created_at"] = _e;
	}
	{
		auto _e = updated_at();
		_o["updated_at"] = _e;
	}
	{
		auto _e = last_online_at();
		_o["last_online_at"] = _e;
	}
	return _o;
}

inline SelfT *Self::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::SelfT> _o = std::unique_ptr<server::SelfT>(new SelfT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void Self::UnPackTo(SelfT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = user();
		if (_e)
			_o->user = std::unique_ptr<server::UserT>(_e->UnPack(_resolver));
	}
	{
		auto _e = verified();
		_o->verified = _e;
	}
	{
		auto _e = email();
		if (_e)
			_o->email = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = device_ids();
		if (_e) {
			_o->device_ids.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->device_ids[_i] = CharString(_e->Get(_i)->c_str(), _e->Get(_i)->size());
			}
		}
	}
	{
		auto _e = facebook_id();
		if (_e)
			_o->facebook_id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = google_id();
		if (_e)
			_o->google_id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = gamecenter_id();
		if (_e)
			_o->gamecenter_id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = steam_id();
		if (_e)
			_o->steam_id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = custom_id();
		if (_e)
			_o->custom_id = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<Self> Self::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelfT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateSelf(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Self> CreateSelf(flatbuffers::FlatBufferBuilder &_fbb, const SelfT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const SelfT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _user = _o->user ? CreateUser(_fbb, _o->user.get(), _rehasher) : 0;
	auto _verified = _o->verified;
	auto _email = _o->email.empty() ? 0 : _fbb.CreateString(_o->email);
	auto _device_ids = _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(
			_o->device_ids.size(), [](size_t i, _VectorArgs *__va) { return __va->__fbb->CreateString(__va->__o->device_ids[i]); }, &_va);
	auto _facebook_id = _o->facebook_id.empty() ? 0 : _fbb.CreateString(_o->facebook_id);
	auto _google_id = _o->google_id.empty() ? 0 : _fbb.CreateString(_o->google_id);
	auto _gamecenter_id = _o->gamecenter_id.empty() ? 0 : _fbb.CreateString(_o->gamecenter_id);
	auto _steam_id = _o->steam_id.empty() ? 0 : _fbb.CreateString(_o->steam_id);
	auto _custom_id = _o->custom_id.empty() ? 0 : _fbb.CreateString(_o->custom_id);
	return server::CreateSelf(
			_fbb,
			_user,
			_verified,
			_email,
			_device_ids,
			_facebook_id,
			_google_id,
			_gamecenter_id,
			_steam_id,
			_custom_id);
}

inline Dictionary Self::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = user();
		if (_e)
			_o["user"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = verified();
		_o["verified"] = _e;
	}
	{
		auto _e = email();
		if (_e)
			_o["email"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = device_ids();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = CharString(_e->Get(_i)->c_str(), _e->Get(_i)->size());
			}
			_o["device_ids"] = _a;
		}
	}
	{
		auto _e = facebook_id();
		if (_e)
			_o["facebook_id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = google_id();
		if (_e)
			_o["google_id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = gamecenter_id();
		if (_e)
			_o["gamecenter_id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = steam_id();
		if (_e)
			_o["steam_id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = custom_id();
		if (_e)
			_o["custom_id"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

inline TSelfFetchT *TSelfFetch::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TSelfFetchT> _o = std::unique_ptr<server::TSelfFetchT>(new TSelfFetchT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TSelfFetch::UnPackTo(TSelfFetchT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
}

inline flatbuffers::Offset<TSelfFetch> TSelfFetch::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TSelfFetchT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTSelfFetch(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TSelfFetch> CreateTSelfFetch(flatbuffers::FlatBufferBuilder &_fbb, const TSelfFetchT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TSelfFetchT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	return server::CreateTSelfFetch(
			_fbb);
}

inline Dictionary TSelfFetch::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	return _o;
}

inline TSelfT *TSelf::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TSelfT> _o = std::unique_ptr<server::TSelfT>(new TSelfT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TSelf::UnPackTo(TSelfT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = self();
		if (_e)
			_o->self = std::unique_ptr<server::SelfT>(_e->UnPack(_resolver));
	}
}

inline flatbuffers::Offset<TSelf> TSelf::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TSelfT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTSelf(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TSelf> CreateTSelf(flatbuffers::FlatBufferBuilder &_fbb, const TSelfT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TSelfT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _self = _o->self ? CreateSelf(_fbb, _o->self.get(), _rehasher) : 0;
	return server::CreateTSelf(
			_fbb,
			_self);
}

inline Dictionary TSelf::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = self();
		if (_e)
			_o["self"] = _e->UnPackToDict(_resolver);
	}
	return _o;
}

inline TSelfUpdateT *TSelfUpdate::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TSelfUpdateT> _o = std::unique_ptr<server::TSelfUpdateT>(new TSelfUpdateT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TSelfUpdate::UnPackTo(TSelfUpdateT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = handle();
		if (_e)
			_o->handle = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = fullname();
		if (_e)
			_o->fullname = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = timezone();
		if (_e)
			_o->timezone = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = location();
		if (_e)
			_o->location = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = lang();
		if (_e)
			_o->lang = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = metadata();
		if (_e)
			_o->metadata = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = avatar_url();
		if (_e)
			_o->avatar_url = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<TSelfUpdate> TSelfUpdate::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TSelfUpdateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTSelfUpdate(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TSelfUpdate> CreateTSelfUpdate(flatbuffers::FlatBufferBuilder &_fbb, const TSelfUpdateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TSelfUpdateT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _handle = _o->handle.empty() ? 0 : _fbb.CreateString(_o->handle);
	auto _fullname = _o->fullname.empty() ? 0 : _fbb.CreateString(_o->fullname);
	auto _timezone = _o->timezone.empty() ? 0 : _fbb.CreateString(_o->timezone);
	auto _location = _o->location.empty() ? 0 : _fbb.CreateString(_o->location);
	auto _lang = _o->lang.empty() ? 0 : _fbb.CreateString(_o->lang);
	auto _metadata = _o->metadata.empty() ? 0 : _fbb.CreateString(_o->metadata);
	auto _avatar_url = _o->avatar_url.empty() ? 0 : _fbb.CreateString(_o->avatar_url);
	return server::CreateTSelfUpdate(
			_fbb,
			_handle,
			_fullname,
			_timezone,
			_location,
			_lang,
			_metadata,
			_avatar_url);
}

inline Dictionary TSelfUpdate::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = handle();
		if (_e)
			_o["handle"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = fullname();
		if (_e)
			_o["fullname"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = timezone();
		if (_e)
			_o["timezone"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = location();
		if (_e)
			_o["location"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = lang();
		if (_e)
			_o["lang"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = metadata();
		if (_e)
			_o["metadata"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = avatar_url();
		if (_e)
			_o["avatar_url"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

inline TUsersFetchT *TUsersFetch::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TUsersFetchT> _o = std::unique_ptr<server::TUsersFetchT>(new TUsersFetchT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TUsersFetch::UnPackTo(TUsersFetchT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = users();
		if (_e) {
			_o->users.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->users[_i] = std::unique_ptr<server::TUsersFetch_::UsersFetchT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
}

inline flatbuffers::Offset<TUsersFetch> TUsersFetch::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TUsersFetchT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTUsersFetch(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TUsersFetch> CreateTUsersFetch(flatbuffers::FlatBufferBuilder &_fbb, const TUsersFetchT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TUsersFetchT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _users = _fbb.CreateVector<flatbuffers::Offset<server::TUsersFetch_::UsersFetch>>(
			_o->users.size(), [](size_t i, _VectorArgs *__va) { return CreateUsersFetch(*__va->__fbb, __va->__o->users[i].get(), __va->__rehasher); }, &_va);
	return server::CreateTUsersFetch(
			_fbb,
			_users);
}

inline Dictionary TUsersFetch::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = users();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["users"] = _a;
		}
	}
	return _o;
}

namespace TUsersFetch_ {

inline UsersFetchT *UsersFetch::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TUsersFetch_::UsersFetchT> _o = std::unique_ptr<server::TUsersFetch_::UsersFetchT>(new UsersFetchT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void UsersFetch::UnPackTo(UsersFetchT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = id();
		if (_e)
			_o->id = std::unique_ptr<server::TUsersFetch_::UsersFetch_::Anonymous5T>(_e->UnPack(_resolver));
	}
}

inline flatbuffers::Offset<UsersFetch> UsersFetch::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UsersFetchT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateUsersFetch(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UsersFetch> CreateUsersFetch(flatbuffers::FlatBufferBuilder &_fbb, const UsersFetchT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const UsersFetchT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _id = _o->id ? CreateAnonymous5(_fbb, _o->id.get(), _rehasher) : 0;
	return server::TUsersFetch_::CreateUsersFetch(
			_fbb,
			_id);
}

inline Dictionary UsersFetch::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = id();
		if (_e)
			_o["id"] = _e->UnPackToDict(_resolver);
	}
	return _o;
}

namespace UsersFetch_ {

inline Anonymous5T *Anonymous5::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TUsersFetch_::UsersFetch_::Anonymous5T> _o = std::unique_ptr<server::TUsersFetch_::UsersFetch_::Anonymous5T>(new Anonymous5T());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void Anonymous5::UnPackTo(Anonymous5T *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = user_id();
		if (_e)
			_o->user_id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = handle();
		if (_e)
			_o->handle = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<Anonymous5> Anonymous5::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Anonymous5T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateAnonymous5(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Anonymous5> CreateAnonymous5(flatbuffers::FlatBufferBuilder &_fbb, const Anonymous5T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const Anonymous5T *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _user_id = _o->user_id.empty() ? 0 : _fbb.CreateString(_o->user_id);
	auto _handle = _o->handle.empty() ? 0 : _fbb.CreateString(_o->handle);
	return server::TUsersFetch_::UsersFetch_::CreateAnonymous5(
			_fbb,
			_user_id,
			_handle);
}

inline Dictionary Anonymous5::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = user_id();
		if (_e)
			_o["user_id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = handle();
		if (_e)
			_o["handle"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

} // namespace UsersFetch_
} // namespace TUsersFetch_

inline TUsersT *TUsers::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TUsersT> _o = std::unique_ptr<server::TUsersT>(new TUsersT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TUsers::UnPackTo(TUsersT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = users();
		if (_e) {
			_o->users.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->users[_i] = std::unique_ptr<server::UserT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
}

inline flatbuffers::Offset<TUsers> TUsers::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TUsersT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTUsers(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TUsers> CreateTUsers(flatbuffers::FlatBufferBuilder &_fbb, const TUsersT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TUsersT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _users = _fbb.CreateVector<flatbuffers::Offset<server::User>>(
			_o->users.size(), [](size_t i, _VectorArgs *__va) { return CreateUser(*__va->__fbb, __va->__o->users[i].get(), __va->__rehasher); }, &_va);
	return server::CreateTUsers(
			_fbb,
			_users);
}

inline Dictionary TUsers::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = users();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["users"] = _a;
		}
	}
	return _o;
}

inline FriendT *Friend::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::FriendT> _o = std::unique_ptr<server::FriendT>(new FriendT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void Friend::UnPackTo(FriendT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = user();
		if (_e)
			_o->user = std::unique_ptr<server::UserT>(_e->UnPack(_resolver));
	}
	{
		auto _e = state();
		_o->state = _e;
	}
}

inline flatbuffers::Offset<Friend> Friend::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FriendT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateFriend(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Friend> CreateFriend(flatbuffers::FlatBufferBuilder &_fbb, const FriendT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const FriendT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _user = _o->user ? CreateUser(_fbb, _o->user.get(), _rehasher) : 0;
	auto _state = _o->state;
	return server::CreateFriend(
			_fbb,
			_user,
			_state);
}

inline Dictionary Friend::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = user();
		if (_e)
			_o["user"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = state();
		_o["state"] = _e;
	}
	return _o;
}

inline TFriendsAddT *TFriendsAdd::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TFriendsAddT> _o = std::unique_ptr<server::TFriendsAddT>(new TFriendsAddT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TFriendsAdd::UnPackTo(TFriendsAddT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = friends();
		if (_e) {
			_o->friends.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->friends[_i] = std::unique_ptr<server::TFriendsAdd_::FriendsAddT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
}

inline flatbuffers::Offset<TFriendsAdd> TFriendsAdd::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TFriendsAddT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTFriendsAdd(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TFriendsAdd> CreateTFriendsAdd(flatbuffers::FlatBufferBuilder &_fbb, const TFriendsAddT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TFriendsAddT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _friends = _fbb.CreateVector<flatbuffers::Offset<server::TFriendsAdd_::FriendsAdd>>(
			_o->friends.size(), [](size_t i, _VectorArgs *__va) { return CreateFriendsAdd(*__va->__fbb, __va->__o->friends[i].get(), __va->__rehasher); }, &_va);
	return server::CreateTFriendsAdd(
			_fbb,
			_friends);
}

inline Dictionary TFriendsAdd::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = friends();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["friends"] = _a;
		}
	}
	return _o;
}

namespace TFriendsAdd_ {

inline FriendsAddT *FriendsAdd::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TFriendsAdd_::FriendsAddT> _o = std::unique_ptr<server::TFriendsAdd_::FriendsAddT>(new FriendsAddT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void FriendsAdd::UnPackTo(FriendsAddT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = id();
		if (_e)
			_o->id = std::unique_ptr<server::TFriendsAdd_::FriendsAdd_::Anonymous6T>(_e->UnPack(_resolver));
	}
}

inline flatbuffers::Offset<FriendsAdd> FriendsAdd::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FriendsAddT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateFriendsAdd(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FriendsAdd> CreateFriendsAdd(flatbuffers::FlatBufferBuilder &_fbb, const FriendsAddT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const FriendsAddT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _id = _o->id ? CreateAnonymous6(_fbb, _o->id.get(), _rehasher) : 0;
	return server::TFriendsAdd_::CreateFriendsAdd(
			_fbb,
			_id);
}

inline Dictionary FriendsAdd::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = id();
		if (_e)
			_o["id"] = _e->UnPackToDict(_resolver);
	}
	return _o;
}

namespace FriendsAdd_ {

inline Anonymous6T *Anonymous6::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TFriendsAdd_::FriendsAdd_::Anonymous6T> _o = std::unique_ptr<server::TFriendsAdd_::FriendsAdd_::Anonymous6T>(new Anonymous6T());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void Anonymous6::UnPackTo(Anonymous6T *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = user_id();
		if (_e)
			_o->user_id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = handle();
		if (_e)
			_o->handle = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<Anonymous6> Anonymous6::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Anonymous6T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateAnonymous6(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Anonymous6> CreateAnonymous6(flatbuffers::FlatBufferBuilder &_fbb, const Anonymous6T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const Anonymous6T *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _user_id = _o->user_id.empty() ? 0 : _fbb.CreateString(_o->user_id);
	auto _handle = _o->handle.empty() ? 0 : _fbb.CreateString(_o->handle);
	return server::TFriendsAdd_::FriendsAdd_::CreateAnonymous6(
			_fbb,
			_user_id,
			_handle);
}

inline Dictionary Anonymous6::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = user_id();
		if (_e)
			_o["user_id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = handle();
		if (_e)
			_o["handle"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

} // namespace FriendsAdd_
} // namespace TFriendsAdd_

inline TFriendsRemoveT *TFriendsRemove::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TFriendsRemoveT> _o = std::unique_ptr<server::TFriendsRemoveT>(new TFriendsRemoveT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TFriendsRemove::UnPackTo(TFriendsRemoveT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = user_ids();
		if (_e) {
			_o->user_ids.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->user_ids[_i] = CharString(_e->Get(_i)->c_str(), _e->Get(_i)->size());
			}
		}
	}
}

inline flatbuffers::Offset<TFriendsRemove> TFriendsRemove::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TFriendsRemoveT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTFriendsRemove(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TFriendsRemove> CreateTFriendsRemove(flatbuffers::FlatBufferBuilder &_fbb, const TFriendsRemoveT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TFriendsRemoveT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _user_ids = _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(
			_o->user_ids.size(), [](size_t i, _VectorArgs *__va) { return __va->__fbb->CreateString(__va->__o->user_ids[i]); }, &_va);
	return server::CreateTFriendsRemove(
			_fbb,
			_user_ids);
}

inline Dictionary TFriendsRemove::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = user_ids();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = CharString(_e->Get(_i)->c_str(), _e->Get(_i)->size());
			}
			_o["user_ids"] = _a;
		}
	}
	return _o;
}

inline TFriendsBlockT *TFriendsBlock::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TFriendsBlockT> _o = std::unique_ptr<server::TFriendsBlockT>(new TFriendsBlockT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TFriendsBlock::UnPackTo(TFriendsBlockT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = user_ids();
		if (_e) {
			_o->user_ids.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->user_ids[_i] = CharString(_e->Get(_i)->c_str(), _e->Get(_i)->size());
			}
		}
	}
}

inline flatbuffers::Offset<TFriendsBlock> TFriendsBlock::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TFriendsBlockT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTFriendsBlock(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TFriendsBlock> CreateTFriendsBlock(flatbuffers::FlatBufferBuilder &_fbb, const TFriendsBlockT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TFriendsBlockT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _user_ids = _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(
			_o->user_ids.size(), [](size_t i, _VectorArgs *__va) { return __va->__fbb->CreateString(__va->__o->user_ids[i]); }, &_va);
	return server::CreateTFriendsBlock(
			_fbb,
			_user_ids);
}

inline Dictionary TFriendsBlock::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = user_ids();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = CharString(_e->Get(_i)->c_str(), _e->Get(_i)->size());
			}
			_o["user_ids"] = _a;
		}
	}
	return _o;
}

inline TFriendsListT *TFriendsList::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TFriendsListT> _o = std::unique_ptr<server::TFriendsListT>(new TFriendsListT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TFriendsList::UnPackTo(TFriendsListT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
}

inline flatbuffers::Offset<TFriendsList> TFriendsList::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TFriendsListT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTFriendsList(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TFriendsList> CreateTFriendsList(flatbuffers::FlatBufferBuilder &_fbb, const TFriendsListT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TFriendsListT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	return server::CreateTFriendsList(
			_fbb);
}

inline Dictionary TFriendsList::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	return _o;
}

inline TFriendsT *TFriends::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TFriendsT> _o = std::unique_ptr<server::TFriendsT>(new TFriendsT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TFriends::UnPackTo(TFriendsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = friends();
		if (_e) {
			_o->friends.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->friends[_i] = std::unique_ptr<server::FriendT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
}

inline flatbuffers::Offset<TFriends> TFriends::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TFriendsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTFriends(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TFriends> CreateTFriends(flatbuffers::FlatBufferBuilder &_fbb, const TFriendsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TFriendsT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _friends = _fbb.CreateVector<flatbuffers::Offset<server::Friend>>(
			_o->friends.size(), [](size_t i, _VectorArgs *__va) { return CreateFriend(*__va->__fbb, __va->__o->friends[i].get(), __va->__rehasher); }, &_va);
	return server::CreateTFriends(
			_fbb,
			_friends);
}

inline Dictionary TFriends::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = friends();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["friends"] = _a;
		}
	}
	return _o;
}

inline GroupT *Group::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::GroupT> _o = std::unique_ptr<server::GroupT>(new GroupT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void Group::UnPackTo(GroupT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = id();
		if (_e)
			_o->id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = private_();
		_o->private_ = _e;
	}
	{
		auto _e = creator_id();
		if (_e)
			_o->creator_id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = name();
		if (_e)
			_o->name = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = description();
		if (_e)
			_o->description = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = avatar_url();
		if (_e)
			_o->avatar_url = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = lang();
		if (_e)
			_o->lang = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = utc_offset_ms();
		_o->utc_offset_ms = _e;
	}
	{
		auto _e = metadata();
		if (_e)
			_o->metadata = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = count();
		_o->count = _e;
	}
	{
		auto _e = created_at();
		_o->created_at = _e;
	}
	{
		auto _e = updated_at();
		_o->updated_at = _e;
	}
}

inline flatbuffers::Offset<Group> Group::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GroupT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateGroup(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Group> CreateGroup(flatbuffers::FlatBufferBuilder &_fbb, const GroupT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const GroupT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
	auto _private_ = _o->private_;
	auto _creator_id = _o->creator_id.empty() ? 0 : _fbb.CreateString(_o->creator_id);
	auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
	auto _description = _o->description.empty() ? 0 : _fbb.CreateString(_o->description);
	auto _avatar_url = _o->avatar_url.empty() ? 0 : _fbb.CreateString(_o->avatar_url);
	auto _lang = _o->lang.empty() ? 0 : _fbb.CreateString(_o->lang);
	auto _utc_offset_ms = _o->utc_offset_ms;
	auto _metadata = _o->metadata.empty() ? 0 : _fbb.CreateString(_o->metadata);
	auto _count = _o->count;
	auto _created_at = _o->created_at;
	auto _updated_at = _o->updated_at;
	return server::CreateGroup(
			_fbb,
			_id,
			_private_,
			_creator_id,
			_name,
			_description,
			_avatar_url,
			_lang,
			_utc_offset_ms,
			_metadata,
			_count,
			_created_at,
			_updated_at);
}

inline Dictionary Group::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = id();
		if (_e)
			_o["id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = private_();
		_o["private_"] = _e;
	}
	{
		auto _e = creator_id();
		if (_e)
			_o["creator_id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = name();
		if (_e)
			_o["name"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = description();
		if (_e)
			_o["description"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = avatar_url();
		if (_e)
			_o["avatar_url"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = lang();
		if (_e)
			_o["lang"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = utc_offset_ms();
		_o["utc_offset_ms"] = _e;
	}
	{
		auto _e = metadata();
		if (_e)
			_o["metadata"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = count();
		_o["count"] = _e;
	}
	{
		auto _e = created_at();
		_o["created_at"] = _e;
	}
	{
		auto _e = updated_at();
		_o["updated_at"] = _e;
	}
	return _o;
}

inline TGroupsCreateT *TGroupsCreate::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TGroupsCreateT> _o = std::unique_ptr<server::TGroupsCreateT>(new TGroupsCreateT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TGroupsCreate::UnPackTo(TGroupsCreateT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = groups();
		if (_e) {
			_o->groups.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->groups[_i] = std::unique_ptr<server::TGroupsCreate_::GroupCreateT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
}

inline flatbuffers::Offset<TGroupsCreate> TGroupsCreate::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TGroupsCreateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTGroupsCreate(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TGroupsCreate> CreateTGroupsCreate(flatbuffers::FlatBufferBuilder &_fbb, const TGroupsCreateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TGroupsCreateT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _groups = _fbb.CreateVector<flatbuffers::Offset<server::TGroupsCreate_::GroupCreate>>(
			_o->groups.size(), [](size_t i, _VectorArgs *__va) { return CreateGroupCreate(*__va->__fbb, __va->__o->groups[i].get(), __va->__rehasher); }, &_va);
	return server::CreateTGroupsCreate(
			_fbb,
			_groups);
}

inline Dictionary TGroupsCreate::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = groups();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["groups"] = _a;
		}
	}
	return _o;
}

namespace TGroupsCreate_ {

inline GroupCreateT *GroupCreate::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TGroupsCreate_::GroupCreateT> _o = std::unique_ptr<server::TGroupsCreate_::GroupCreateT>(new GroupCreateT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void GroupCreate::UnPackTo(GroupCreateT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = name();
		if (_e)
			_o->name = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = description();
		if (_e)
			_o->description = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = avatar_url();
		if (_e)
			_o->avatar_url = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = lang();
		if (_e)
			_o->lang = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = metadata();
		if (_e)
			_o->metadata = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = private_();
		_o->private_ = _e;
	}
}

inline flatbuffers::Offset<GroupCreate> GroupCreate::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GroupCreateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateGroupCreate(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GroupCreate> CreateGroupCreate(flatbuffers::FlatBufferBuilder &_fbb, const GroupCreateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const GroupCreateT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
	auto _description = _o->description.empty() ? 0 : _fbb.CreateString(_o->description);
	auto _avatar_url = _o->avatar_url.empty() ? 0 : _fbb.CreateString(_o->avatar_url);
	auto _lang = _o->lang.empty() ? 0 : _fbb.CreateString(_o->lang);
	auto _metadata = _o->metadata.empty() ? 0 : _fbb.CreateString(_o->metadata);
	auto _private_ = _o->private_;
	return server::TGroupsCreate_::CreateGroupCreate(
			_fbb,
			_name,
			_description,
			_avatar_url,
			_lang,
			_metadata,
			_private_);
}

inline Dictionary GroupCreate::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = name();
		if (_e)
			_o["name"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = description();
		if (_e)
			_o["description"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = avatar_url();
		if (_e)
			_o["avatar_url"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = lang();
		if (_e)
			_o["lang"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = metadata();
		if (_e)
			_o["metadata"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = private_();
		_o["private_"] = _e;
	}
	return _o;
}

} // namespace TGroupsCreate_

inline TGroupsUpdateT *TGroupsUpdate::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TGroupsUpdateT> _o = std::unique_ptr<server::TGroupsUpdateT>(new TGroupsUpdateT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TGroupsUpdate::UnPackTo(TGroupsUpdateT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = groups();
		if (_e) {
			_o->groups.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->groups[_i] = std::unique_ptr<server::TGroupsUpdate_::GroupUpdateT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
}

inline flatbuffers::Offset<TGroupsUpdate> TGroupsUpdate::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TGroupsUpdateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTGroupsUpdate(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TGroupsUpdate> CreateTGroupsUpdate(flatbuffers::FlatBufferBuilder &_fbb, const TGroupsUpdateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TGroupsUpdateT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _groups = _fbb.CreateVector<flatbuffers::Offset<server::TGroupsUpdate_::GroupUpdate>>(
			_o->groups.size(), [](size_t i, _VectorArgs *__va) { return CreateGroupUpdate(*__va->__fbb, __va->__o->groups[i].get(), __va->__rehasher); }, &_va);
	return server::CreateTGroupsUpdate(
			_fbb,
			_groups);
}

inline Dictionary TGroupsUpdate::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = groups();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["groups"] = _a;
		}
	}
	return _o;
}

namespace TGroupsUpdate_ {

inline GroupUpdateT *GroupUpdate::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TGroupsUpdate_::GroupUpdateT> _o = std::unique_ptr<server::TGroupsUpdate_::GroupUpdateT>(new GroupUpdateT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void GroupUpdate::UnPackTo(GroupUpdateT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = group_id();
		if (_e)
			_o->group_id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = private_();
		_o->private_ = _e;
	}
	{
		auto _e = name();
		if (_e)
			_o->name = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = description();
		if (_e)
			_o->description = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = avatar_url();
		if (_e)
			_o->avatar_url = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = lang();
		if (_e)
			_o->lang = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = metadata();
		if (_e)
			_o->metadata = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<GroupUpdate> GroupUpdate::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GroupUpdateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateGroupUpdate(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GroupUpdate> CreateGroupUpdate(flatbuffers::FlatBufferBuilder &_fbb, const GroupUpdateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const GroupUpdateT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _group_id = _o->group_id.empty() ? 0 : _fbb.CreateString(_o->group_id);
	auto _private_ = _o->private_;
	auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
	auto _description = _o->description.empty() ? 0 : _fbb.CreateString(_o->description);
	auto _avatar_url = _o->avatar_url.empty() ? 0 : _fbb.CreateString(_o->avatar_url);
	auto _lang = _o->lang.empty() ? 0 : _fbb.CreateString(_o->lang);
	auto _metadata = _o->metadata.empty() ? 0 : _fbb.CreateString(_o->metadata);
	return server::TGroupsUpdate_::CreateGroupUpdate(
			_fbb,
			_group_id,
			_private_,
			_name,
			_description,
			_avatar_url,
			_lang,
			_metadata);
}

inline Dictionary GroupUpdate::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = group_id();
		if (_e)
			_o["group_id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = private_();
		_o["private_"] = _e;
	}
	{
		auto _e = name();
		if (_e)
			_o["name"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = description();
		if (_e)
			_o["description"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = avatar_url();
		if (_e)
			_o["avatar_url"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = lang();
		if (_e)
			_o["lang"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = metadata();
		if (_e)
			_o["metadata"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

} // namespace TGroupsUpdate_

inline TGroupsRemoveT *TGroupsRemove::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TGroupsRemoveT> _o = std::unique_ptr<server::TGroupsRemoveT>(new TGroupsRemoveT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TGroupsRemove::UnPackTo(TGroupsRemoveT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = group_ids();
		if (_e) {
			_o->group_ids.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->group_ids[_i] = CharString(_e->Get(_i)->c_str(), _e->Get(_i)->size());
			}
		}
	}
}

inline flatbuffers::Offset<TGroupsRemove> TGroupsRemove::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TGroupsRemoveT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTGroupsRemove(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TGroupsRemove> CreateTGroupsRemove(flatbuffers::FlatBufferBuilder &_fbb, const TGroupsRemoveT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TGroupsRemoveT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _group_ids = _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(
			_o->group_ids.size(), [](size_t i, _VectorArgs *__va) { return __va->__fbb->CreateString(__va->__o->group_ids[i]); }, &_va);
	return server::CreateTGroupsRemove(
			_fbb,
			_group_ids);
}

inline Dictionary TGroupsRemove::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = group_ids();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = CharString(_e->Get(_i)->c_str(), _e->Get(_i)->size());
			}
			_o["group_ids"] = _a;
		}
	}
	return _o;
}

inline TGroupsSelfListT *TGroupsSelfList::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TGroupsSelfListT> _o = std::unique_ptr<server::TGroupsSelfListT>(new TGroupsSelfListT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TGroupsSelfList::UnPackTo(TGroupsSelfListT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
}

inline flatbuffers::Offset<TGroupsSelfList> TGroupsSelfList::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TGroupsSelfListT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTGroupsSelfList(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TGroupsSelfList> CreateTGroupsSelfList(flatbuffers::FlatBufferBuilder &_fbb, const TGroupsSelfListT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TGroupsSelfListT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	return server::CreateTGroupsSelfList(
			_fbb);
}

inline Dictionary TGroupsSelfList::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	return _o;
}

inline TGroupsFetchT *TGroupsFetch::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TGroupsFetchT> _o = std::unique_ptr<server::TGroupsFetchT>(new TGroupsFetchT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TGroupsFetch::UnPackTo(TGroupsFetchT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = groups();
		if (_e) {
			_o->groups.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->groups[_i] = std::unique_ptr<server::TGroupsFetch_::GroupFetchT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
}

inline flatbuffers::Offset<TGroupsFetch> TGroupsFetch::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TGroupsFetchT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTGroupsFetch(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TGroupsFetch> CreateTGroupsFetch(flatbuffers::FlatBufferBuilder &_fbb, const TGroupsFetchT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TGroupsFetchT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _groups = _fbb.CreateVector<flatbuffers::Offset<server::TGroupsFetch_::GroupFetch>>(
			_o->groups.size(), [](size_t i, _VectorArgs *__va) { return CreateGroupFetch(*__va->__fbb, __va->__o->groups[i].get(), __va->__rehasher); }, &_va);
	return server::CreateTGroupsFetch(
			_fbb,
			_groups);
}

inline Dictionary TGroupsFetch::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = groups();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["groups"] = _a;
		}
	}
	return _o;
}

namespace TGroupsFetch_ {

inline GroupFetchT *GroupFetch::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TGroupsFetch_::GroupFetchT> _o = std::unique_ptr<server::TGroupsFetch_::GroupFetchT>(new GroupFetchT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void GroupFetch::UnPackTo(GroupFetchT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = id();
		if (_e)
			_o->id = std::unique_ptr<server::TGroupsFetch_::GroupFetch_::Anonymous7T>(_e->UnPack(_resolver));
	}
}

inline flatbuffers::Offset<GroupFetch> GroupFetch::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GroupFetchT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateGroupFetch(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GroupFetch> CreateGroupFetch(flatbuffers::FlatBufferBuilder &_fbb, const GroupFetchT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const GroupFetchT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _id = _o->id ? CreateAnonymous7(_fbb, _o->id.get(), _rehasher) : 0;
	return server::TGroupsFetch_::CreateGroupFetch(
			_fbb,
			_id);
}

inline Dictionary GroupFetch::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = id();
		if (_e)
			_o["id"] = _e->UnPackToDict(_resolver);
	}
	return _o;
}

namespace GroupFetch_ {

inline Anonymous7T *Anonymous7::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TGroupsFetch_::GroupFetch_::Anonymous7T> _o = std::unique_ptr<server::TGroupsFetch_::GroupFetch_::Anonymous7T>(new Anonymous7T());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void Anonymous7::UnPackTo(Anonymous7T *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = group_id();
		if (_e)
			_o->group_id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = name();
		if (_e)
			_o->name = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<Anonymous7> Anonymous7::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Anonymous7T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateAnonymous7(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Anonymous7> CreateAnonymous7(flatbuffers::FlatBufferBuilder &_fbb, const Anonymous7T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const Anonymous7T *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _group_id = _o->group_id.empty() ? 0 : _fbb.CreateString(_o->group_id);
	auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
	return server::TGroupsFetch_::GroupFetch_::CreateAnonymous7(
			_fbb,
			_group_id,
			_name);
}

inline Dictionary Anonymous7::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = group_id();
		if (_e)
			_o["group_id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = name();
		if (_e)
			_o["name"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

} // namespace GroupFetch_
} // namespace TGroupsFetch_

inline TGroupsListT *TGroupsList::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TGroupsListT> _o = std::unique_ptr<server::TGroupsListT>(new TGroupsListT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TGroupsList::UnPackTo(TGroupsListT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = page_limit();
		_o->page_limit = _e;
	}
	{
		auto _e = order_by_asc();
		_o->order_by_asc = _e;
	}
	{
		auto _e = filter();
		if (_e)
			_o->filter = std::unique_ptr<server::TGroupsList_::Anonymous8T>(_e->UnPack(_resolver));
	}
	{
		auto _e = cursor();
		if (_e)
			_o->cursor = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<TGroupsList> TGroupsList::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TGroupsListT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTGroupsList(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TGroupsList> CreateTGroupsList(flatbuffers::FlatBufferBuilder &_fbb, const TGroupsListT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TGroupsListT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _page_limit = _o->page_limit;
	auto _order_by_asc = _o->order_by_asc;
	auto _filter = _o->filter ? CreateAnonymous8(_fbb, _o->filter.get(), _rehasher) : 0;
	auto _cursor = _o->cursor.empty() ? 0 : _fbb.CreateString(_o->cursor);
	return server::CreateTGroupsList(
			_fbb,
			_page_limit,
			_order_by_asc,
			_filter,
			_cursor);
}

inline Dictionary TGroupsList::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = page_limit();
		_o["page_limit"] = _e;
	}
	{
		auto _e = order_by_asc();
		_o["order_by_asc"] = _e;
	}
	{
		auto _e = filter();
		if (_e)
			_o["filter"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = cursor();
		if (_e)
			_o["cursor"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

namespace TGroupsList_ {

inline Anonymous8T *Anonymous8::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TGroupsList_::Anonymous8T> _o = std::unique_ptr<server::TGroupsList_::Anonymous8T>(new Anonymous8T());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void Anonymous8::UnPackTo(Anonymous8T *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = lang();
		if (_e)
			_o->lang = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = created_at();
		_o->created_at = _e;
	}
	{
		auto _e = count();
		_o->count = _e;
	}
}

inline flatbuffers::Offset<Anonymous8> Anonymous8::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Anonymous8T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateAnonymous8(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Anonymous8> CreateAnonymous8(flatbuffers::FlatBufferBuilder &_fbb, const Anonymous8T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const Anonymous8T *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _lang = _o->lang.empty() ? 0 : _fbb.CreateString(_o->lang);
	auto _created_at = _o->created_at;
	auto _count = _o->count;
	return server::TGroupsList_::CreateAnonymous8(
			_fbb,
			_lang,
			_created_at,
			_count);
}

inline Dictionary Anonymous8::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = lang();
		if (_e)
			_o["lang"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = created_at();
		_o["created_at"] = _e;
	}
	{
		auto _e = count();
		_o["count"] = _e;
	}
	return _o;
}

} // namespace TGroupsList_

inline TGroupsT *TGroups::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TGroupsT> _o = std::unique_ptr<server::TGroupsT>(new TGroupsT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TGroups::UnPackTo(TGroupsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = groups();
		if (_e) {
			_o->groups.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->groups[_i] = std::unique_ptr<server::GroupT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
	{
		auto _e = cursor();
		if (_e)
			_o->cursor = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<TGroups> TGroups::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TGroupsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTGroups(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TGroups> CreateTGroups(flatbuffers::FlatBufferBuilder &_fbb, const TGroupsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TGroupsT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _groups = _fbb.CreateVector<flatbuffers::Offset<server::Group>>(
			_o->groups.size(), [](size_t i, _VectorArgs *__va) { return CreateGroup(*__va->__fbb, __va->__o->groups[i].get(), __va->__rehasher); }, &_va);
	auto _cursor = _o->cursor.empty() ? 0 : _fbb.CreateString(_o->cursor);
	return server::CreateTGroups(
			_fbb,
			_groups,
			_cursor);
}

inline Dictionary TGroups::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = groups();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["groups"] = _a;
		}
	}
	{
		auto _e = cursor();
		if (_e)
			_o["cursor"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

inline TGroupsSelfT *TGroupsSelf::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TGroupsSelfT> _o = std::unique_ptr<server::TGroupsSelfT>(new TGroupsSelfT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TGroupsSelf::UnPackTo(TGroupsSelfT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = groups_self();
		if (_e) {
			_o->groups_self.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->groups_self[_i] = std::unique_ptr<server::TGroupsSelf_::GroupSelfT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
}

inline flatbuffers::Offset<TGroupsSelf> TGroupsSelf::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TGroupsSelfT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTGroupsSelf(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TGroupsSelf> CreateTGroupsSelf(flatbuffers::FlatBufferBuilder &_fbb, const TGroupsSelfT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TGroupsSelfT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _groups_self = _fbb.CreateVector<flatbuffers::Offset<server::TGroupsSelf_::GroupSelf>>(
			_o->groups_self.size(), [](size_t i, _VectorArgs *__va) { return CreateGroupSelf(*__va->__fbb, __va->__o->groups_self[i].get(), __va->__rehasher); }, &_va);
	return server::CreateTGroupsSelf(
			_fbb,
			_groups_self);
}

inline Dictionary TGroupsSelf::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = groups_self();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["groups_self"] = _a;
		}
	}
	return _o;
}

namespace TGroupsSelf_ {

inline GroupSelfT *GroupSelf::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TGroupsSelf_::GroupSelfT> _o = std::unique_ptr<server::TGroupsSelf_::GroupSelfT>(new GroupSelfT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void GroupSelf::UnPackTo(GroupSelfT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = group();
		if (_e)
			_o->group = std::unique_ptr<server::GroupT>(_e->UnPack(_resolver));
	}
	{
		auto _e = state();
		_o->state = _e;
	}
}

inline flatbuffers::Offset<GroupSelf> GroupSelf::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GroupSelfT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateGroupSelf(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GroupSelf> CreateGroupSelf(flatbuffers::FlatBufferBuilder &_fbb, const GroupSelfT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const GroupSelfT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _group = _o->group ? CreateGroup(_fbb, _o->group.get(), _rehasher) : 0;
	auto _state = _o->state;
	return server::TGroupsSelf_::CreateGroupSelf(
			_fbb,
			_group,
			_state);
}

inline Dictionary GroupSelf::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = group();
		if (_e)
			_o["group"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = state();
		_o["state"] = _e;
	}
	return _o;
}

} // namespace TGroupsSelf_

inline GroupUserT *GroupUser::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::GroupUserT> _o = std::unique_ptr<server::GroupUserT>(new GroupUserT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void GroupUser::UnPackTo(GroupUserT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = user();
		if (_e)
			_o->user = std::unique_ptr<server::UserT>(_e->UnPack(_resolver));
	}
	{
		auto _e = state();
		_o->state = _e;
	}
}

inline flatbuffers::Offset<GroupUser> GroupUser::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GroupUserT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateGroupUser(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GroupUser> CreateGroupUser(flatbuffers::FlatBufferBuilder &_fbb, const GroupUserT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const GroupUserT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _user = _o->user ? CreateUser(_fbb, _o->user.get(), _rehasher) : 0;
	auto _state = _o->state;
	return server::CreateGroupUser(
			_fbb,
			_user,
			_state);
}

inline Dictionary GroupUser::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = user();
		if (_e)
			_o["user"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = state();
		_o["state"] = _e;
	}
	return _o;
}

inline TGroupUsersListT *TGroupUsersList::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TGroupUsersListT> _o = std::unique_ptr<server::TGroupUsersListT>(new TGroupUsersListT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TGroupUsersList::UnPackTo(TGroupUsersListT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = group_id();
		if (_e)
			_o->group_id = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<TGroupUsersList> TGroupUsersList::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TGroupUsersListT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTGroupUsersList(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TGroupUsersList> CreateTGroupUsersList(flatbuffers::FlatBufferBuilder &_fbb, const TGroupUsersListT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TGroupUsersListT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _group_id = _o->group_id.empty() ? 0 : _fbb.CreateString(_o->group_id);
	return server::CreateTGroupUsersList(
			_fbb,
			_group_id);
}

inline Dictionary TGroupUsersList::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = group_id();
		if (_e)
			_o["group_id"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

inline TGroupUsersT *TGroupUsers::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TGroupUsersT> _o = std::unique_ptr<server::TGroupUsersT>(new TGroupUsersT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TGroupUsers::UnPackTo(TGroupUsersT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = users();
		if (_e) {
			_o->users.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->users[_i] = std::unique_ptr<server::GroupUserT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
}

inline flatbuffers::Offset<TGroupUsers> TGroupUsers::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TGroupUsersT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTGroupUsers(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TGroupUsers> CreateTGroupUsers(flatbuffers::FlatBufferBuilder &_fbb, const TGroupUsersT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TGroupUsersT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _users = _fbb.CreateVector<flatbuffers::Offset<server::GroupUser>>(
			_o->users.size(), [](size_t i, _VectorArgs *__va) { return CreateGroupUser(*__va->__fbb, __va->__o->users[i].get(), __va->__rehasher); }, &_va);
	return server::CreateTGroupUsers(
			_fbb,
			_users);
}

inline Dictionary TGroupUsers::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = users();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["users"] = _a;
		}
	}
	return _o;
}

inline TGroupsJoinT *TGroupsJoin::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TGroupsJoinT> _o = std::unique_ptr<server::TGroupsJoinT>(new TGroupsJoinT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TGroupsJoin::UnPackTo(TGroupsJoinT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = group_ids();
		if (_e) {
			_o->group_ids.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->group_ids[_i] = CharString(_e->Get(_i)->c_str(), _e->Get(_i)->size());
			}
		}
	}
}

inline flatbuffers::Offset<TGroupsJoin> TGroupsJoin::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TGroupsJoinT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTGroupsJoin(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TGroupsJoin> CreateTGroupsJoin(flatbuffers::FlatBufferBuilder &_fbb, const TGroupsJoinT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TGroupsJoinT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _group_ids = _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(
			_o->group_ids.size(), [](size_t i, _VectorArgs *__va) { return __va->__fbb->CreateString(__va->__o->group_ids[i]); }, &_va);
	return server::CreateTGroupsJoin(
			_fbb,
			_group_ids);
}

inline Dictionary TGroupsJoin::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = group_ids();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = CharString(_e->Get(_i)->c_str(), _e->Get(_i)->size());
			}
			_o["group_ids"] = _a;
		}
	}
	return _o;
}

inline TGroupsLeaveT *TGroupsLeave::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TGroupsLeaveT> _o = std::unique_ptr<server::TGroupsLeaveT>(new TGroupsLeaveT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TGroupsLeave::UnPackTo(TGroupsLeaveT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = group_ids();
		if (_e) {
			_o->group_ids.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->group_ids[_i] = CharString(_e->Get(_i)->c_str(), _e->Get(_i)->size());
			}
		}
	}
}

inline flatbuffers::Offset<TGroupsLeave> TGroupsLeave::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TGroupsLeaveT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTGroupsLeave(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TGroupsLeave> CreateTGroupsLeave(flatbuffers::FlatBufferBuilder &_fbb, const TGroupsLeaveT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TGroupsLeaveT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _group_ids = _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(
			_o->group_ids.size(), [](size_t i, _VectorArgs *__va) { return __va->__fbb->CreateString(__va->__o->group_ids[i]); }, &_va);
	return server::CreateTGroupsLeave(
			_fbb,
			_group_ids);
}

inline Dictionary TGroupsLeave::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = group_ids();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = CharString(_e->Get(_i)->c_str(), _e->Get(_i)->size());
			}
			_o["group_ids"] = _a;
		}
	}
	return _o;
}

inline TGroupUsersAddT *TGroupUsersAdd::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TGroupUsersAddT> _o = std::unique_ptr<server::TGroupUsersAddT>(new TGroupUsersAddT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TGroupUsersAdd::UnPackTo(TGroupUsersAddT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = group_users();
		if (_e) {
			_o->group_users.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->group_users[_i] = std::unique_ptr<server::TGroupUsersAdd_::GroupUserAddT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
}

inline flatbuffers::Offset<TGroupUsersAdd> TGroupUsersAdd::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TGroupUsersAddT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTGroupUsersAdd(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TGroupUsersAdd> CreateTGroupUsersAdd(flatbuffers::FlatBufferBuilder &_fbb, const TGroupUsersAddT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TGroupUsersAddT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _group_users = _fbb.CreateVector<flatbuffers::Offset<server::TGroupUsersAdd_::GroupUserAdd>>(
			_o->group_users.size(), [](size_t i, _VectorArgs *__va) { return CreateGroupUserAdd(*__va->__fbb, __va->__o->group_users[i].get(), __va->__rehasher); }, &_va);
	return server::CreateTGroupUsersAdd(
			_fbb,
			_group_users);
}

inline Dictionary TGroupUsersAdd::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = group_users();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["group_users"] = _a;
		}
	}
	return _o;
}

namespace TGroupUsersAdd_ {

inline GroupUserAddT *GroupUserAdd::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TGroupUsersAdd_::GroupUserAddT> _o = std::unique_ptr<server::TGroupUsersAdd_::GroupUserAddT>(new GroupUserAddT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void GroupUserAdd::UnPackTo(GroupUserAddT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = group_id();
		if (_e)
			_o->group_id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = user_id();
		if (_e)
			_o->user_id = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<GroupUserAdd> GroupUserAdd::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GroupUserAddT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateGroupUserAdd(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GroupUserAdd> CreateGroupUserAdd(flatbuffers::FlatBufferBuilder &_fbb, const GroupUserAddT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const GroupUserAddT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _group_id = _o->group_id.empty() ? 0 : _fbb.CreateString(_o->group_id);
	auto _user_id = _o->user_id.empty() ? 0 : _fbb.CreateString(_o->user_id);
	return server::TGroupUsersAdd_::CreateGroupUserAdd(
			_fbb,
			_group_id,
			_user_id);
}

inline Dictionary GroupUserAdd::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = group_id();
		if (_e)
			_o["group_id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = user_id();
		if (_e)
			_o["user_id"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

} // namespace TGroupUsersAdd_

inline TGroupUsersKickT *TGroupUsersKick::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TGroupUsersKickT> _o = std::unique_ptr<server::TGroupUsersKickT>(new TGroupUsersKickT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TGroupUsersKick::UnPackTo(TGroupUsersKickT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = group_users();
		if (_e) {
			_o->group_users.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->group_users[_i] = std::unique_ptr<server::TGroupUsersKick_::GroupUserKickT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
}

inline flatbuffers::Offset<TGroupUsersKick> TGroupUsersKick::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TGroupUsersKickT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTGroupUsersKick(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TGroupUsersKick> CreateTGroupUsersKick(flatbuffers::FlatBufferBuilder &_fbb, const TGroupUsersKickT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TGroupUsersKickT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _group_users = _fbb.CreateVector<flatbuffers::Offset<server::TGroupUsersKick_::GroupUserKick>>(
			_o->group_users.size(), [](size_t i, _VectorArgs *__va) { return CreateGroupUserKick(*__va->__fbb, __va->__o->group_users[i].get(), __va->__rehasher); }, &_va);
	return server::CreateTGroupUsersKick(
			_fbb,
			_group_users);
}

inline Dictionary TGroupUsersKick::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = group_users();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["group_users"] = _a;
		}
	}
	return _o;
}

namespace TGroupUsersKick_ {

inline GroupUserKickT *GroupUserKick::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TGroupUsersKick_::GroupUserKickT> _o = std::unique_ptr<server::TGroupUsersKick_::GroupUserKickT>(new GroupUserKickT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void GroupUserKick::UnPackTo(GroupUserKickT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = group_id();
		if (_e)
			_o->group_id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = user_id();
		if (_e)
			_o->user_id = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<GroupUserKick> GroupUserKick::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GroupUserKickT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateGroupUserKick(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GroupUserKick> CreateGroupUserKick(flatbuffers::FlatBufferBuilder &_fbb, const GroupUserKickT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const GroupUserKickT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _group_id = _o->group_id.empty() ? 0 : _fbb.CreateString(_o->group_id);
	auto _user_id = _o->user_id.empty() ? 0 : _fbb.CreateString(_o->user_id);
	return server::TGroupUsersKick_::CreateGroupUserKick(
			_fbb,
			_group_id,
			_user_id);
}

inline Dictionary GroupUserKick::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = group_id();
		if (_e)
			_o["group_id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = user_id();
		if (_e)
			_o["user_id"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

} // namespace TGroupUsersKick_

inline TGroupUsersPromoteT *TGroupUsersPromote::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TGroupUsersPromoteT> _o = std::unique_ptr<server::TGroupUsersPromoteT>(new TGroupUsersPromoteT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TGroupUsersPromote::UnPackTo(TGroupUsersPromoteT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = group_users();
		if (_e) {
			_o->group_users.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->group_users[_i] = std::unique_ptr<server::TGroupUsersPromote_::GroupUserPromoteT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
}

inline flatbuffers::Offset<TGroupUsersPromote> TGroupUsersPromote::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TGroupUsersPromoteT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTGroupUsersPromote(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TGroupUsersPromote> CreateTGroupUsersPromote(flatbuffers::FlatBufferBuilder &_fbb, const TGroupUsersPromoteT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TGroupUsersPromoteT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _group_users = _fbb.CreateVector<flatbuffers::Offset<server::TGroupUsersPromote_::GroupUserPromote>>(
			_o->group_users.size(), [](size_t i, _VectorArgs *__va) { return CreateGroupUserPromote(*__va->__fbb, __va->__o->group_users[i].get(), __va->__rehasher); }, &_va);
	return server::CreateTGroupUsersPromote(
			_fbb,
			_group_users);
}

inline Dictionary TGroupUsersPromote::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = group_users();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["group_users"] = _a;
		}
	}
	return _o;
}

namespace TGroupUsersPromote_ {

inline GroupUserPromoteT *GroupUserPromote::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TGroupUsersPromote_::GroupUserPromoteT> _o = std::unique_ptr<server::TGroupUsersPromote_::GroupUserPromoteT>(new GroupUserPromoteT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void GroupUserPromote::UnPackTo(GroupUserPromoteT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = group_id();
		if (_e)
			_o->group_id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = user_id();
		if (_e)
			_o->user_id = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<GroupUserPromote> GroupUserPromote::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GroupUserPromoteT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateGroupUserPromote(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GroupUserPromote> CreateGroupUserPromote(flatbuffers::FlatBufferBuilder &_fbb, const GroupUserPromoteT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const GroupUserPromoteT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _group_id = _o->group_id.empty() ? 0 : _fbb.CreateString(_o->group_id);
	auto _user_id = _o->user_id.empty() ? 0 : _fbb.CreateString(_o->user_id);
	return server::TGroupUsersPromote_::CreateGroupUserPromote(
			_fbb,
			_group_id,
			_user_id);
}

inline Dictionary GroupUserPromote::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = group_id();
		if (_e)
			_o["group_id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = user_id();
		if (_e)
			_o["user_id"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

} // namespace TGroupUsersPromote_

inline TopicIdT *TopicId::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TopicIdT> _o = std::unique_ptr<server::TopicIdT>(new TopicIdT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TopicId::UnPackTo(TopicIdT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = id();
		if (_e)
			_o->id = std::unique_ptr<server::TopicId_::TopicTypeT>(_e->UnPack(_resolver));
	}
}

inline flatbuffers::Offset<TopicId> TopicId::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TopicIdT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTopicId(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TopicId> CreateTopicId(flatbuffers::FlatBufferBuilder &_fbb, const TopicIdT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TopicIdT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _id = _o->id ? CreateTopicType(_fbb, _o->id.get(), _rehasher) : 0;
	return server::CreateTopicId(
			_fbb,
			_id);
}

inline Dictionary TopicId::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = id();
		if (_e)
			_o["id"] = _e->UnPackToDict(_resolver);
	}
	return _o;
}

namespace TopicId_ {

inline TopicTypeT *TopicType::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TopicId_::TopicTypeT> _o = std::unique_ptr<server::TopicId_::TopicTypeT>(new TopicTypeT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TopicType::UnPackTo(TopicTypeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = dm();
		if (_e)
			_o->dm = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = room();
		if (_e)
			_o->room = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = group_id();
		if (_e)
			_o->group_id = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<TopicType> TopicType::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TopicTypeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTopicType(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TopicType> CreateTopicType(flatbuffers::FlatBufferBuilder &_fbb, const TopicTypeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TopicTypeT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _dm = _o->dm.empty() ? 0 : _fbb.CreateString(_o->dm);
	auto _room = _o->room.empty() ? 0 : _fbb.CreateString(_o->room);
	auto _group_id = _o->group_id.empty() ? 0 : _fbb.CreateString(_o->group_id);
	return server::TopicId_::CreateTopicType(
			_fbb,
			_dm,
			_room,
			_group_id);
}

inline Dictionary TopicType::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = dm();
		if (_e)
			_o["dm"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = room();
		if (_e)
			_o["room"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = group_id();
		if (_e)
			_o["group_id"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

} // namespace TopicId_

inline UserPresenceT *UserPresence::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::UserPresenceT> _o = std::unique_ptr<server::UserPresenceT>(new UserPresenceT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void UserPresence::UnPackTo(UserPresenceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = user_id();
		if (_e)
			_o->user_id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = session_id();
		if (_e)
			_o->session_id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = handle();
		if (_e)
			_o->handle = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<UserPresence> UserPresence::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UserPresenceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateUserPresence(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UserPresence> CreateUserPresence(flatbuffers::FlatBufferBuilder &_fbb, const UserPresenceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const UserPresenceT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _user_id = _o->user_id.empty() ? 0 : _fbb.CreateString(_o->user_id);
	auto _session_id = _o->session_id.empty() ? 0 : _fbb.CreateString(_o->session_id);
	auto _handle = _o->handle.empty() ? 0 : _fbb.CreateString(_o->handle);
	return server::CreateUserPresence(
			_fbb,
			_user_id,
			_session_id,
			_handle);
}

inline Dictionary UserPresence::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = user_id();
		if (_e)
			_o["user_id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = session_id();
		if (_e)
			_o["session_id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = handle();
		if (_e)
			_o["handle"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

inline TTopicsJoinT *TTopicsJoin::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TTopicsJoinT> _o = std::unique_ptr<server::TTopicsJoinT>(new TTopicsJoinT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TTopicsJoin::UnPackTo(TTopicsJoinT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = joins();
		if (_e) {
			_o->joins.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->joins[_i] = std::unique_ptr<server::TTopicsJoin_::TopicJoinT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
}

inline flatbuffers::Offset<TTopicsJoin> TTopicsJoin::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TTopicsJoinT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTTopicsJoin(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TTopicsJoin> CreateTTopicsJoin(flatbuffers::FlatBufferBuilder &_fbb, const TTopicsJoinT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TTopicsJoinT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _joins = _fbb.CreateVector<flatbuffers::Offset<server::TTopicsJoin_::TopicJoin>>(
			_o->joins.size(), [](size_t i, _VectorArgs *__va) { return CreateTopicJoin(*__va->__fbb, __va->__o->joins[i].get(), __va->__rehasher); }, &_va);
	return server::CreateTTopicsJoin(
			_fbb,
			_joins);
}

inline Dictionary TTopicsJoin::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = joins();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["joins"] = _a;
		}
	}
	return _o;
}

namespace TTopicsJoin_ {

inline TopicJoinT *TopicJoin::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TTopicsJoin_::TopicJoinT> _o = std::unique_ptr<server::TTopicsJoin_::TopicJoinT>(new TopicJoinT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TopicJoin::UnPackTo(TopicJoinT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = id();
		if (_e)
			_o->id = std::unique_ptr<server::TTopicsJoin_::TopicJoin_::AuthenticateResult0T>(_e->UnPack(_resolver));
	}
}

inline flatbuffers::Offset<TopicJoin> TopicJoin::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TopicJoinT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTopicJoin(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TopicJoin> CreateTopicJoin(flatbuffers::FlatBufferBuilder &_fbb, const TopicJoinT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TopicJoinT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _id = _o->id ? CreateAuthenticateResult0(_fbb, _o->id.get(), _rehasher) : 0;
	return server::TTopicsJoin_::CreateTopicJoin(
			_fbb,
			_id);
}

inline Dictionary TopicJoin::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = id();
		if (_e)
			_o["id"] = _e->UnPackToDict(_resolver);
	}
	return _o;
}

namespace TopicJoin_ {

inline AuthenticateResult0T *AuthenticateResult0::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TTopicsJoin_::TopicJoin_::AuthenticateResult0T> _o = std::unique_ptr<server::TTopicsJoin_::TopicJoin_::AuthenticateResult0T>(new AuthenticateResult0T());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void AuthenticateResult0::UnPackTo(AuthenticateResult0T *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = user_id();
		if (_e)
			_o->user_id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = room();
		if (_e)
			_o->room = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = group_id();
		if (_e)
			_o->group_id = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<AuthenticateResult0> AuthenticateResult0::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateResult0T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateAuthenticateResult0(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AuthenticateResult0> CreateAuthenticateResult0(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateResult0T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const AuthenticateResult0T *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _user_id = _o->user_id.empty() ? 0 : _fbb.CreateString(_o->user_id);
	auto _room = _o->room.empty() ? 0 : _fbb.CreateString(_o->room);
	auto _group_id = _o->group_id.empty() ? 0 : _fbb.CreateString(_o->group_id);
	return server::TTopicsJoin_::TopicJoin_::CreateAuthenticateResult0(
			_fbb,
			_user_id,
			_room,
			_group_id);
}

inline Dictionary AuthenticateResult0::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = user_id();
		if (_e)
			_o["user_id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = room();
		if (_e)
			_o["room"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = group_id();
		if (_e)
			_o["group_id"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

} // namespace TopicJoin_
} // namespace TTopicsJoin_

inline TTopicsT *TTopics::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TTopicsT> _o = std::unique_ptr<server::TTopicsT>(new TTopicsT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TTopics::UnPackTo(TTopicsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = topics();
		if (_e) {
			_o->topics.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->topics[_i] = std::unique_ptr<server::TTopics_::TopicT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
}

inline flatbuffers::Offset<TTopics> TTopics::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TTopicsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTTopics(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TTopics> CreateTTopics(flatbuffers::FlatBufferBuilder &_fbb, const TTopicsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TTopicsT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _topics = _fbb.CreateVector<flatbuffers::Offset<server::TTopics_::Topic>>(
			_o->topics.size(), [](size_t i, _VectorArgs *__va) { return CreateTopic(*__va->__fbb, __va->__o->topics[i].get(), __va->__rehasher); }, &_va);
	return server::CreateTTopics(
			_fbb,
			_topics);
}

inline Dictionary TTopics::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = topics();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["topics"] = _a;
		}
	}
	return _o;
}

namespace TTopics_ {

inline TopicT *Topic::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TTopics_::TopicT> _o = std::unique_ptr<server::TTopics_::TopicT>(new TopicT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void Topic::UnPackTo(TopicT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = topic();
		if (_e)
			_o->topic = std::unique_ptr<server::TopicIdT>(_e->UnPack(_resolver));
	}
	{
		auto _e = presences();
		if (_e) {
			_o->presences.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->presences[_i] = std::unique_ptr<server::UserPresenceT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
	{
		auto _e = self();
		if (_e)
			_o->self = std::unique_ptr<server::UserPresenceT>(_e->UnPack(_resolver));
	}
}

inline flatbuffers::Offset<Topic> Topic::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TopicT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTopic(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Topic> CreateTopic(flatbuffers::FlatBufferBuilder &_fbb, const TopicT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TopicT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _topic = _o->topic ? CreateTopicId(_fbb, _o->topic.get(), _rehasher) : 0;
	auto _presences = _fbb.CreateVector<flatbuffers::Offset<server::UserPresence>>(
			_o->presences.size(), [](size_t i, _VectorArgs *__va) { return CreateUserPresence(*__va->__fbb, __va->__o->presences[i].get(), __va->__rehasher); }, &_va);
	auto _self = _o->self ? CreateUserPresence(_fbb, _o->self.get(), _rehasher) : 0;
	return server::TTopics_::CreateTopic(
			_fbb,
			_topic,
			_presences,
			_self);
}

inline Dictionary Topic::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = topic();
		if (_e)
			_o["topic"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = presences();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["presences"] = _a;
		}
	}
	{
		auto _e = self();
		if (_e)
			_o["self"] = _e->UnPackToDict(_resolver);
	}
	return _o;
}

} // namespace TTopics_

inline TTopicsLeaveT *TTopicsLeave::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TTopicsLeaveT> _o = std::unique_ptr<server::TTopicsLeaveT>(new TTopicsLeaveT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TTopicsLeave::UnPackTo(TTopicsLeaveT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = topics();
		if (_e) {
			_o->topics.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->topics[_i] = std::unique_ptr<server::TopicIdT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
}

inline flatbuffers::Offset<TTopicsLeave> TTopicsLeave::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TTopicsLeaveT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTTopicsLeave(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TTopicsLeave> CreateTTopicsLeave(flatbuffers::FlatBufferBuilder &_fbb, const TTopicsLeaveT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TTopicsLeaveT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _topics = _fbb.CreateVector<flatbuffers::Offset<server::TopicId>>(
			_o->topics.size(), [](size_t i, _VectorArgs *__va) { return CreateTopicId(*__va->__fbb, __va->__o->topics[i].get(), __va->__rehasher); }, &_va);
	return server::CreateTTopicsLeave(
			_fbb,
			_topics);
}

inline Dictionary TTopicsLeave::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = topics();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["topics"] = _a;
		}
	}
	return _o;
}

inline TTopicMessageSendT *TTopicMessageSend::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TTopicMessageSendT> _o = std::unique_ptr<server::TTopicMessageSendT>(new TTopicMessageSendT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TTopicMessageSend::UnPackTo(TTopicMessageSendT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = topic();
		if (_e)
			_o->topic = std::unique_ptr<server::TopicIdT>(_e->UnPack(_resolver));
	}
	{
		auto _e = data();
		if (_e)
			_o->data = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<TTopicMessageSend> TTopicMessageSend::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TTopicMessageSendT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTTopicMessageSend(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TTopicMessageSend> CreateTTopicMessageSend(flatbuffers::FlatBufferBuilder &_fbb, const TTopicMessageSendT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TTopicMessageSendT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _topic = _o->topic ? CreateTopicId(_fbb, _o->topic.get(), _rehasher) : 0;
	auto _data = _o->data.empty() ? 0 : _fbb.CreateString(_o->data);
	return server::CreateTTopicMessageSend(
			_fbb,
			_topic,
			_data);
}

inline Dictionary TTopicMessageSend::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = topic();
		if (_e)
			_o["topic"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = data();
		if (_e)
			_o["data"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

inline TTopicMessageAckT *TTopicMessageAck::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TTopicMessageAckT> _o = std::unique_ptr<server::TTopicMessageAckT>(new TTopicMessageAckT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TTopicMessageAck::UnPackTo(TTopicMessageAckT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = message_id();
		if (_e)
			_o->message_id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = created_at();
		_o->created_at = _e;
	}
	{
		auto _e = expires_at();
		_o->expires_at = _e;
	}
	{
		auto _e = handle();
		if (_e)
			_o->handle = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<TTopicMessageAck> TTopicMessageAck::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TTopicMessageAckT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTTopicMessageAck(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TTopicMessageAck> CreateTTopicMessageAck(flatbuffers::FlatBufferBuilder &_fbb, const TTopicMessageAckT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TTopicMessageAckT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _message_id = _o->message_id.empty() ? 0 : _fbb.CreateString(_o->message_id);
	auto _created_at = _o->created_at;
	auto _expires_at = _o->expires_at;
	auto _handle = _o->handle.empty() ? 0 : _fbb.CreateString(_o->handle);
	return server::CreateTTopicMessageAck(
			_fbb,
			_message_id,
			_created_at,
			_expires_at,
			_handle);
}

inline Dictionary TTopicMessageAck::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = message_id();
		if (_e)
			_o["message_id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = created_at();
		_o["created_at"] = _e;
	}
	{
		auto _e = expires_at();
		_o["expires_at"] = _e;
	}
	{
		auto _e = handle();
		if (_e)
			_o["handle"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

inline TopicMessageT *TopicMessage::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TopicMessageT> _o = std::unique_ptr<server::TopicMessageT>(new TopicMessageT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TopicMessage::UnPackTo(TopicMessageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = topic();
		if (_e)
			_o->topic = std::unique_ptr<server::TopicIdT>(_e->UnPack(_resolver));
	}
	{
		auto _e = user_id();
		if (_e)
			_o->user_id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = message_id();
		if (_e)
			_o->message_id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = created_at();
		_o->created_at = _e;
	}
	{
		auto _e = expires_at();
		_o->expires_at = _e;
	}
	{
		auto _e = handle();
		if (_e)
			_o->handle = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = type();
		_o->type = _e;
	}
	{
		auto _e = data();
		if (_e)
			_o->data = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<TopicMessage> TopicMessage::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TopicMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTopicMessage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TopicMessage> CreateTopicMessage(flatbuffers::FlatBufferBuilder &_fbb, const TopicMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TopicMessageT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _topic = _o->topic ? CreateTopicId(_fbb, _o->topic.get(), _rehasher) : 0;
	auto _user_id = _o->user_id.empty() ? 0 : _fbb.CreateString(_o->user_id);
	auto _message_id = _o->message_id.empty() ? 0 : _fbb.CreateString(_o->message_id);
	auto _created_at = _o->created_at;
	auto _expires_at = _o->expires_at;
	auto _handle = _o->handle.empty() ? 0 : _fbb.CreateString(_o->handle);
	auto _type = _o->type;
	auto _data = _o->data.empty() ? 0 : _fbb.CreateString(_o->data);
	return server::CreateTopicMessage(
			_fbb,
			_topic,
			_user_id,
			_message_id,
			_created_at,
			_expires_at,
			_handle,
			_type,
			_data);
}

inline Dictionary TopicMessage::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = topic();
		if (_e)
			_o["topic"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = user_id();
		if (_e)
			_o["user_id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = message_id();
		if (_e)
			_o["message_id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = created_at();
		_o["created_at"] = _e;
	}
	{
		auto _e = expires_at();
		_o["expires_at"] = _e;
	}
	{
		auto _e = handle();
		if (_e)
			_o["handle"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = type();
		_o["type"] = _e;
	}
	{
		auto _e = data();
		if (_e)
			_o["data"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

inline TTopicMessagesListT *TTopicMessagesList::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TTopicMessagesListT> _o = std::unique_ptr<server::TTopicMessagesListT>(new TTopicMessagesListT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TTopicMessagesList::UnPackTo(TTopicMessagesListT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = id();
		if (_e)
			_o->id = std::unique_ptr<server::TTopicMessagesList_::AuthenticateResult1T>(_e->UnPack(_resolver));
	}
	{
		auto _e = cursor();
		if (_e)
			_o->cursor = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = forward();
		_o->forward = _e;
	}
	{
		auto _e = limit();
		_o->limit = _e;
	}
}

inline flatbuffers::Offset<TTopicMessagesList> TTopicMessagesList::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TTopicMessagesListT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTTopicMessagesList(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TTopicMessagesList> CreateTTopicMessagesList(flatbuffers::FlatBufferBuilder &_fbb, const TTopicMessagesListT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TTopicMessagesListT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _id = _o->id ? CreateAuthenticateResult1(_fbb, _o->id.get(), _rehasher) : 0;
	auto _cursor = _o->cursor.empty() ? 0 : _fbb.CreateString(_o->cursor);
	auto _forward = _o->forward;
	auto _limit = _o->limit;
	return server::CreateTTopicMessagesList(
			_fbb,
			_id,
			_cursor,
			_forward,
			_limit);
}

inline Dictionary TTopicMessagesList::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = id();
		if (_e)
			_o["id"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = cursor();
		if (_e)
			_o["cursor"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = forward();
		_o["forward"] = _e;
	}
	{
		auto _e = limit();
		_o["limit"] = _e;
	}
	return _o;
}

namespace TTopicMessagesList_ {

inline AuthenticateResult1T *AuthenticateResult1::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TTopicMessagesList_::AuthenticateResult1T> _o = std::unique_ptr<server::TTopicMessagesList_::AuthenticateResult1T>(new AuthenticateResult1T());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void AuthenticateResult1::UnPackTo(AuthenticateResult1T *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = user_id();
		if (_e)
			_o->user_id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = room();
		if (_e)
			_o->room = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = group_id();
		if (_e)
			_o->group_id = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<AuthenticateResult1> AuthenticateResult1::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateResult1T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateAuthenticateResult1(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AuthenticateResult1> CreateAuthenticateResult1(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateResult1T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const AuthenticateResult1T *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _user_id = _o->user_id.empty() ? 0 : _fbb.CreateString(_o->user_id);
	auto _room = _o->room.empty() ? 0 : _fbb.CreateString(_o->room);
	auto _group_id = _o->group_id.empty() ? 0 : _fbb.CreateString(_o->group_id);
	return server::TTopicMessagesList_::CreateAuthenticateResult1(
			_fbb,
			_user_id,
			_room,
			_group_id);
}

inline Dictionary AuthenticateResult1::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = user_id();
		if (_e)
			_o["user_id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = room();
		if (_e)
			_o["room"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = group_id();
		if (_e)
			_o["group_id"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

} // namespace TTopicMessagesList_

inline TTopicMessagesT *TTopicMessages::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TTopicMessagesT> _o = std::unique_ptr<server::TTopicMessagesT>(new TTopicMessagesT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TTopicMessages::UnPackTo(TTopicMessagesT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = messages();
		if (_e) {
			_o->messages.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->messages[_i] = std::unique_ptr<server::TopicMessageT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
	{
		auto _e = cursor();
		if (_e)
			_o->cursor = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<TTopicMessages> TTopicMessages::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TTopicMessagesT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTTopicMessages(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TTopicMessages> CreateTTopicMessages(flatbuffers::FlatBufferBuilder &_fbb, const TTopicMessagesT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TTopicMessagesT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _messages = _fbb.CreateVector<flatbuffers::Offset<server::TopicMessage>>(
			_o->messages.size(), [](size_t i, _VectorArgs *__va) { return CreateTopicMessage(*__va->__fbb, __va->__o->messages[i].get(), __va->__rehasher); }, &_va);
	auto _cursor = _o->cursor.empty() ? 0 : _fbb.CreateString(_o->cursor);
	return server::CreateTTopicMessages(
			_fbb,
			_messages,
			_cursor);
}

inline Dictionary TTopicMessages::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = messages();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["messages"] = _a;
		}
	}
	{
		auto _e = cursor();
		if (_e)
			_o["cursor"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

inline TopicPresenceT *TopicPresence::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TopicPresenceT> _o = std::unique_ptr<server::TopicPresenceT>(new TopicPresenceT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TopicPresence::UnPackTo(TopicPresenceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = topic();
		if (_e)
			_o->topic = std::unique_ptr<server::TopicIdT>(_e->UnPack(_resolver));
	}
	{
		auto _e = joins();
		if (_e) {
			_o->joins.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->joins[_i] = std::unique_ptr<server::UserPresenceT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
	{
		auto _e = leaves();
		if (_e) {
			_o->leaves.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->leaves[_i] = std::unique_ptr<server::UserPresenceT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
}

inline flatbuffers::Offset<TopicPresence> TopicPresence::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TopicPresenceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTopicPresence(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TopicPresence> CreateTopicPresence(flatbuffers::FlatBufferBuilder &_fbb, const TopicPresenceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TopicPresenceT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _topic = _o->topic ? CreateTopicId(_fbb, _o->topic.get(), _rehasher) : 0;
	auto _joins = _fbb.CreateVector<flatbuffers::Offset<server::UserPresence>>(
			_o->joins.size(), [](size_t i, _VectorArgs *__va) { return CreateUserPresence(*__va->__fbb, __va->__o->joins[i].get(), __va->__rehasher); }, &_va);
	auto _leaves = _fbb.CreateVector<flatbuffers::Offset<server::UserPresence>>(
			_o->leaves.size(), [](size_t i, _VectorArgs *__va) { return CreateUserPresence(*__va->__fbb, __va->__o->leaves[i].get(), __va->__rehasher); }, &_va);
	return server::CreateTopicPresence(
			_fbb,
			_topic,
			_joins,
			_leaves);
}

inline Dictionary TopicPresence::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = topic();
		if (_e)
			_o["topic"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = joins();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["joins"] = _a;
		}
	}
	{
		auto _e = leaves();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["leaves"] = _a;
		}
	}
	return _o;
}

inline PropertyPairT *PropertyPair::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::PropertyPairT> _o = std::unique_ptr<server::PropertyPairT>(new PropertyPairT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void PropertyPair::UnPackTo(PropertyPairT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = key();
		if (_e)
			_o->key = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = value();
		if (_e)
			_o->value = std::unique_ptr<server::PropertyPair_::AuthenticateResult2T>(_e->UnPack(_resolver));
	}
}

inline flatbuffers::Offset<PropertyPair> PropertyPair::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PropertyPairT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreatePropertyPair(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PropertyPair> CreatePropertyPair(flatbuffers::FlatBufferBuilder &_fbb, const PropertyPairT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const PropertyPairT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _key = _o->key.empty() ? 0 : _fbb.CreateString(_o->key);
	auto _value = _o->value ? CreateAuthenticateResult2(_fbb, _o->value.get(), _rehasher) : 0;
	return server::CreatePropertyPair(
			_fbb,
			_key,
			_value);
}

inline Dictionary PropertyPair::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = key();
		if (_e)
			_o["key"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = value();
		if (_e)
			_o["value"] = _e->UnPackToDict(_resolver);
	}
	return _o;
}

namespace PropertyPair_ {

inline StringSetT *StringSet::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::PropertyPair_::StringSetT> _o = std::unique_ptr<server::PropertyPair_::StringSetT>(new StringSetT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void StringSet::UnPackTo(StringSetT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = values();
		if (_e) {
			_o->values.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->values[_i] = CharString(_e->Get(_i)->c_str(), _e->Get(_i)->size());
			}
		}
	}
}

inline flatbuffers::Offset<StringSet> StringSet::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StringSetT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateStringSet(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StringSet> CreateStringSet(flatbuffers::FlatBufferBuilder &_fbb, const StringSetT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const StringSetT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _values = _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(
			_o->values.size(), [](size_t i, _VectorArgs *__va) { return __va->__fbb->CreateString(__va->__o->values[i]); }, &_va);
	return server::PropertyPair_::CreateStringSet(
			_fbb,
			_values);
}

inline Dictionary StringSet::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = values();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = CharString(_e->Get(_i)->c_str(), _e->Get(_i)->size());
			}
			_o["values"] = _a;
		}
	}
	return _o;
}

inline AuthenticateResult2T *AuthenticateResult2::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::PropertyPair_::AuthenticateResult2T> _o = std::unique_ptr<server::PropertyPair_::AuthenticateResult2T>(new AuthenticateResult2T());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void AuthenticateResult2::UnPackTo(AuthenticateResult2T *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = string_set();
		if (_e)
			_o->string_set = std::unique_ptr<server::PropertyPair_::StringSetT>(_e->UnPack(_resolver));
	}
	{
		auto _e = bool_value();
		_o->bool_value = _e;
	}
	{
		auto _e = int_value();
		_o->int_value = _e;
	}
}

inline flatbuffers::Offset<AuthenticateResult2> AuthenticateResult2::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateResult2T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateAuthenticateResult2(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AuthenticateResult2> CreateAuthenticateResult2(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateResult2T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const AuthenticateResult2T *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _string_set = _o->string_set ? CreateStringSet(_fbb, _o->string_set.get(), _rehasher) : 0;
	auto _bool_value = _o->bool_value;
	auto _int_value = _o->int_value;
	return server::PropertyPair_::CreateAuthenticateResult2(
			_fbb,
			_string_set,
			_bool_value,
			_int_value);
}

inline Dictionary AuthenticateResult2::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = string_set();
		if (_e)
			_o["string_set"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = bool_value();
		_o["bool_value"] = _e;
	}
	{
		auto _e = int_value();
		_o["int_value"] = _e;
	}
	return _o;
}

} // namespace PropertyPair_

inline MatchmakeFilterT *MatchmakeFilter::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::MatchmakeFilterT> _o = std::unique_ptr<server::MatchmakeFilterT>(new MatchmakeFilterT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void MatchmakeFilter::UnPackTo(MatchmakeFilterT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = name();
		if (_e)
			_o->name = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = value();
		if (_e)
			_o->value = std::unique_ptr<server::MatchmakeFilter_::AuthenticateResult3T>(_e->UnPack(_resolver));
	}
}

inline flatbuffers::Offset<MatchmakeFilter> MatchmakeFilter::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatchmakeFilterT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateMatchmakeFilter(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MatchmakeFilter> CreateMatchmakeFilter(flatbuffers::FlatBufferBuilder &_fbb, const MatchmakeFilterT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const MatchmakeFilterT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
	auto _value = _o->value ? CreateAuthenticateResult3(_fbb, _o->value.get(), _rehasher) : 0;
	return server::CreateMatchmakeFilter(
			_fbb,
			_name,
			_value);
}

inline Dictionary MatchmakeFilter::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = name();
		if (_e)
			_o["name"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = value();
		if (_e)
			_o["value"] = _e->UnPackToDict(_resolver);
	}
	return _o;
}

namespace MatchmakeFilter_ {

inline TermFilterT *TermFilter::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::MatchmakeFilter_::TermFilterT> _o = std::unique_ptr<server::MatchmakeFilter_::TermFilterT>(new TermFilterT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TermFilter::UnPackTo(TermFilterT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = terms();
		if (_e) {
			_o->terms.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->terms[_i] = CharString(_e->Get(_i)->c_str(), _e->Get(_i)->size());
			}
		}
	}
	{
		auto _e = match_all_terms();
		_o->match_all_terms = _e;
	}
}

inline flatbuffers::Offset<TermFilter> TermFilter::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TermFilterT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTermFilter(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TermFilter> CreateTermFilter(flatbuffers::FlatBufferBuilder &_fbb, const TermFilterT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TermFilterT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _terms = _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(
			_o->terms.size(), [](size_t i, _VectorArgs *__va) { return __va->__fbb->CreateString(__va->__o->terms[i]); }, &_va);
	auto _match_all_terms = _o->match_all_terms;
	return server::MatchmakeFilter_::CreateTermFilter(
			_fbb,
			_terms,
			_match_all_terms);
}

inline Dictionary TermFilter::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = terms();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = CharString(_e->Get(_i)->c_str(), _e->Get(_i)->size());
			}
			_o["terms"] = _a;
		}
	}
	{
		auto _e = match_all_terms();
		_o["match_all_terms"] = _e;
	}
	return _o;
}

inline RangeFilterT *RangeFilter::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::MatchmakeFilter_::RangeFilterT> _o = std::unique_ptr<server::MatchmakeFilter_::RangeFilterT>(new RangeFilterT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void RangeFilter::UnPackTo(RangeFilterT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = lower_bound();
		_o->lower_bound = _e;
	}
	{
		auto _e = upper_bound();
		_o->upper_bound = _e;
	}
}

inline flatbuffers::Offset<RangeFilter> RangeFilter::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RangeFilterT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateRangeFilter(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RangeFilter> CreateRangeFilter(flatbuffers::FlatBufferBuilder &_fbb, const RangeFilterT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const RangeFilterT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _lower_bound = _o->lower_bound;
	auto _upper_bound = _o->upper_bound;
	return server::MatchmakeFilter_::CreateRangeFilter(
			_fbb,
			_lower_bound,
			_upper_bound);
}

inline Dictionary RangeFilter::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = lower_bound();
		_o["lower_bound"] = _e;
	}
	{
		auto _e = upper_bound();
		_o["upper_bound"] = _e;
	}
	return _o;
}

inline AuthenticateResult3T *AuthenticateResult3::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::MatchmakeFilter_::AuthenticateResult3T> _o = std::unique_ptr<server::MatchmakeFilter_::AuthenticateResult3T>(new AuthenticateResult3T());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void AuthenticateResult3::UnPackTo(AuthenticateResult3T *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = term();
		if (_e)
			_o->term = std::unique_ptr<server::MatchmakeFilter_::TermFilterT>(_e->UnPack(_resolver));
	}
	{
		auto _e = range();
		if (_e)
			_o->range = std::unique_ptr<server::MatchmakeFilter_::RangeFilterT>(_e->UnPack(_resolver));
	}
	{
		auto _e = check();
		_o->check = _e;
	}
}

inline flatbuffers::Offset<AuthenticateResult3> AuthenticateResult3::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateResult3T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateAuthenticateResult3(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AuthenticateResult3> CreateAuthenticateResult3(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateResult3T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const AuthenticateResult3T *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _term = _o->term ? CreateTermFilter(_fbb, _o->term.get(), _rehasher) : 0;
	auto _range = _o->range ? CreateRangeFilter(_fbb, _o->range.get(), _rehasher) : 0;
	auto _check = _o->check;
	return server::MatchmakeFilter_::CreateAuthenticateResult3(
			_fbb,
			_term,
			_range,
			_check);
}

inline Dictionary AuthenticateResult3::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = term();
		if (_e)
			_o["term"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = range();
		if (_e)
			_o["range"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = check();
		_o["check"] = _e;
	}
	return _o;
}

} // namespace MatchmakeFilter_

inline TMatchmakeAddT *TMatchmakeAdd::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TMatchmakeAddT> _o = std::unique_ptr<server::TMatchmakeAddT>(new TMatchmakeAddT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TMatchmakeAdd::UnPackTo(TMatchmakeAddT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = required_count();
		_o->required_count = _e;
	}
	{
		auto _e = filters();
		if (_e) {
			_o->filters.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->filters[_i] = std::unique_ptr<server::MatchmakeFilterT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
	{
		auto _e = properties();
		if (_e) {
			_o->properties.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->properties[_i] = std::unique_ptr<server::PropertyPairT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
}

inline flatbuffers::Offset<TMatchmakeAdd> TMatchmakeAdd::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TMatchmakeAddT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTMatchmakeAdd(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TMatchmakeAdd> CreateTMatchmakeAdd(flatbuffers::FlatBufferBuilder &_fbb, const TMatchmakeAddT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TMatchmakeAddT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _required_count = _o->required_count;
	auto _filters = _fbb.CreateVector<flatbuffers::Offset<server::MatchmakeFilter>>(
			_o->filters.size(), [](size_t i, _VectorArgs *__va) { return CreateMatchmakeFilter(*__va->__fbb, __va->__o->filters[i].get(), __va->__rehasher); }, &_va);
	auto _properties = _fbb.CreateVector<flatbuffers::Offset<server::PropertyPair>>(
			_o->properties.size(), [](size_t i, _VectorArgs *__va) { return CreatePropertyPair(*__va->__fbb, __va->__o->properties[i].get(), __va->__rehasher); }, &_va);
	return server::CreateTMatchmakeAdd(
			_fbb,
			_required_count,
			_filters,
			_properties);
}

inline Dictionary TMatchmakeAdd::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = required_count();
		_o["required_count"] = _e;
	}
	{
		auto _e = filters();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["filters"] = _a;
		}
	}
	{
		auto _e = properties();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["properties"] = _a;
		}
	}
	return _o;
}

inline TMatchmakeTicketT *TMatchmakeTicket::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TMatchmakeTicketT> _o = std::unique_ptr<server::TMatchmakeTicketT>(new TMatchmakeTicketT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TMatchmakeTicket::UnPackTo(TMatchmakeTicketT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = ticket();
		if (_e)
			_o->ticket = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<TMatchmakeTicket> TMatchmakeTicket::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TMatchmakeTicketT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTMatchmakeTicket(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TMatchmakeTicket> CreateTMatchmakeTicket(flatbuffers::FlatBufferBuilder &_fbb, const TMatchmakeTicketT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TMatchmakeTicketT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _ticket = _o->ticket.empty() ? 0 : _fbb.CreateString(_o->ticket);
	return server::CreateTMatchmakeTicket(
			_fbb,
			_ticket);
}

inline Dictionary TMatchmakeTicket::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = ticket();
		if (_e)
			_o["ticket"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

inline TMatchmakeRemoveT *TMatchmakeRemove::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TMatchmakeRemoveT> _o = std::unique_ptr<server::TMatchmakeRemoveT>(new TMatchmakeRemoveT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TMatchmakeRemove::UnPackTo(TMatchmakeRemoveT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = ticket();
		if (_e)
			_o->ticket = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<TMatchmakeRemove> TMatchmakeRemove::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TMatchmakeRemoveT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTMatchmakeRemove(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TMatchmakeRemove> CreateTMatchmakeRemove(flatbuffers::FlatBufferBuilder &_fbb, const TMatchmakeRemoveT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TMatchmakeRemoveT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _ticket = _o->ticket.empty() ? 0 : _fbb.CreateString(_o->ticket);
	return server::CreateTMatchmakeRemove(
			_fbb,
			_ticket);
}

inline Dictionary TMatchmakeRemove::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = ticket();
		if (_e)
			_o["ticket"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

inline MatchmakeMatchedT *MatchmakeMatched::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::MatchmakeMatchedT> _o = std::unique_ptr<server::MatchmakeMatchedT>(new MatchmakeMatchedT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void MatchmakeMatched::UnPackTo(MatchmakeMatchedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = ticket();
		if (_e)
			_o->ticket = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = token();
		if (_e)
			_o->token = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = presences();
		if (_e) {
			_o->presences.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->presences[_i] = std::unique_ptr<server::UserPresenceT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
	{
		auto _e = self();
		if (_e)
			_o->self = std::unique_ptr<server::UserPresenceT>(_e->UnPack(_resolver));
	}
	{
		auto _e = properties();
		if (_e) {
			_o->properties.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->properties[_i] = std::unique_ptr<server::MatchmakeMatched_::UserPropertyT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
}

inline flatbuffers::Offset<MatchmakeMatched> MatchmakeMatched::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatchmakeMatchedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateMatchmakeMatched(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MatchmakeMatched> CreateMatchmakeMatched(flatbuffers::FlatBufferBuilder &_fbb, const MatchmakeMatchedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const MatchmakeMatchedT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _ticket = _o->ticket.empty() ? 0 : _fbb.CreateString(_o->ticket);
	auto _token = _o->token.empty() ? 0 : _fbb.CreateString(_o->token);
	auto _presences = _fbb.CreateVector<flatbuffers::Offset<server::UserPresence>>(
			_o->presences.size(), [](size_t i, _VectorArgs *__va) { return CreateUserPresence(*__va->__fbb, __va->__o->presences[i].get(), __va->__rehasher); }, &_va);
	auto _self = _o->self ? CreateUserPresence(_fbb, _o->self.get(), _rehasher) : 0;
	auto _properties = _fbb.CreateVector<flatbuffers::Offset<server::MatchmakeMatched_::UserProperty>>(
			_o->properties.size(), [](size_t i, _VectorArgs *__va) { return CreateUserProperty(*__va->__fbb, __va->__o->properties[i].get(), __va->__rehasher); }, &_va);
	return server::CreateMatchmakeMatched(
			_fbb,
			_ticket,
			_token,
			_presences,
			_self,
			_properties);
}

inline Dictionary MatchmakeMatched::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = ticket();
		if (_e)
			_o["ticket"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = token();
		if (_e)
			_o["token"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = presences();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["presences"] = _a;
		}
	}
	{
		auto _e = self();
		if (_e)
			_o["self"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = properties();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["properties"] = _a;
		}
	}
	return _o;
}

namespace MatchmakeMatched_ {

inline UserPropertyT *UserProperty::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::MatchmakeMatched_::UserPropertyT> _o = std::unique_ptr<server::MatchmakeMatched_::UserPropertyT>(new UserPropertyT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void UserProperty::UnPackTo(UserPropertyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = user_id();
		if (_e)
			_o->user_id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = properties();
		if (_e) {
			_o->properties.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->properties[_i] = std::unique_ptr<server::PropertyPairT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
	{
		auto _e = filters();
		if (_e) {
			_o->filters.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->filters[_i] = std::unique_ptr<server::MatchmakeFilterT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
}

inline flatbuffers::Offset<UserProperty> UserProperty::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UserPropertyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateUserProperty(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UserProperty> CreateUserProperty(flatbuffers::FlatBufferBuilder &_fbb, const UserPropertyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const UserPropertyT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _user_id = _o->user_id.empty() ? 0 : _fbb.CreateString(_o->user_id);
	auto _properties = _fbb.CreateVector<flatbuffers::Offset<server::PropertyPair>>(
			_o->properties.size(), [](size_t i, _VectorArgs *__va) { return CreatePropertyPair(*__va->__fbb, __va->__o->properties[i].get(), __va->__rehasher); }, &_va);
	auto _filters = _fbb.CreateVector<flatbuffers::Offset<server::MatchmakeFilter>>(
			_o->filters.size(), [](size_t i, _VectorArgs *__va) { return CreateMatchmakeFilter(*__va->__fbb, __va->__o->filters[i].get(), __va->__rehasher); }, &_va);
	return server::MatchmakeMatched_::CreateUserProperty(
			_fbb,
			_user_id,
			_properties,
			_filters);
}

inline Dictionary UserProperty::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = user_id();
		if (_e)
			_o["user_id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = properties();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["properties"] = _a;
		}
	}
	{
		auto _e = filters();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["filters"] = _a;
		}
	}
	return _o;
}

} // namespace MatchmakeMatched_

inline MatchT *Match::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::MatchT> _o = std::unique_ptr<server::MatchT>(new MatchT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void Match::UnPackTo(MatchT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = match_id();
		if (_e)
			_o->match_id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = presences();
		if (_e) {
			_o->presences.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->presences[_i] = std::unique_ptr<server::UserPresenceT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
	{
		auto _e = self();
		if (_e)
			_o->self = std::unique_ptr<server::UserPresenceT>(_e->UnPack(_resolver));
	}
}

inline flatbuffers::Offset<Match> Match::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatchT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateMatch(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Match> CreateMatch(flatbuffers::FlatBufferBuilder &_fbb, const MatchT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const MatchT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _match_id = _o->match_id.empty() ? 0 : _fbb.CreateString(_o->match_id);
	auto _presences = _fbb.CreateVector<flatbuffers::Offset<server::UserPresence>>(
			_o->presences.size(), [](size_t i, _VectorArgs *__va) { return CreateUserPresence(*__va->__fbb, __va->__o->presences[i].get(), __va->__rehasher); }, &_va);
	auto _self = _o->self ? CreateUserPresence(_fbb, _o->self.get(), _rehasher) : 0;
	return server::CreateMatch(
			_fbb,
			_match_id,
			_presences,
			_self);
}

inline Dictionary Match::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = match_id();
		if (_e)
			_o["match_id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = presences();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["presences"] = _a;
		}
	}
	{
		auto _e = self();
		if (_e)
			_o["self"] = _e->UnPackToDict(_resolver);
	}
	return _o;
}

inline MatchPresenceT *MatchPresence::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::MatchPresenceT> _o = std::unique_ptr<server::MatchPresenceT>(new MatchPresenceT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void MatchPresence::UnPackTo(MatchPresenceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = match_id();
		if (_e)
			_o->match_id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = joins();
		if (_e) {
			_o->joins.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->joins[_i] = std::unique_ptr<server::UserPresenceT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
	{
		auto _e = leaves();
		if (_e) {
			_o->leaves.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->leaves[_i] = std::unique_ptr<server::UserPresenceT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
}

inline flatbuffers::Offset<MatchPresence> MatchPresence::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatchPresenceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateMatchPresence(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MatchPresence> CreateMatchPresence(flatbuffers::FlatBufferBuilder &_fbb, const MatchPresenceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const MatchPresenceT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _match_id = _o->match_id.empty() ? 0 : _fbb.CreateString(_o->match_id);
	auto _joins = _fbb.CreateVector<flatbuffers::Offset<server::UserPresence>>(
			_o->joins.size(), [](size_t i, _VectorArgs *__va) { return CreateUserPresence(*__va->__fbb, __va->__o->joins[i].get(), __va->__rehasher); }, &_va);
	auto _leaves = _fbb.CreateVector<flatbuffers::Offset<server::UserPresence>>(
			_o->leaves.size(), [](size_t i, _VectorArgs *__va) { return CreateUserPresence(*__va->__fbb, __va->__o->leaves[i].get(), __va->__rehasher); }, &_va);
	return server::CreateMatchPresence(
			_fbb,
			_match_id,
			_joins,
			_leaves);
}

inline Dictionary MatchPresence::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = match_id();
		if (_e)
			_o["match_id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = joins();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["joins"] = _a;
		}
	}
	{
		auto _e = leaves();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["leaves"] = _a;
		}
	}
	return _o;
}

inline TMatchCreateT *TMatchCreate::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TMatchCreateT> _o = std::unique_ptr<server::TMatchCreateT>(new TMatchCreateT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TMatchCreate::UnPackTo(TMatchCreateT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
}

inline flatbuffers::Offset<TMatchCreate> TMatchCreate::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TMatchCreateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTMatchCreate(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TMatchCreate> CreateTMatchCreate(flatbuffers::FlatBufferBuilder &_fbb, const TMatchCreateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TMatchCreateT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	return server::CreateTMatchCreate(
			_fbb);
}

inline Dictionary TMatchCreate::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	return _o;
}

inline TMatchT *TMatch::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TMatchT> _o = std::unique_ptr<server::TMatchT>(new TMatchT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TMatch::UnPackTo(TMatchT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = match();
		if (_e)
			_o->match = std::unique_ptr<server::MatchT>(_e->UnPack(_resolver));
	}
}

inline flatbuffers::Offset<TMatch> TMatch::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TMatchT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTMatch(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TMatch> CreateTMatch(flatbuffers::FlatBufferBuilder &_fbb, const TMatchT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TMatchT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _match = _o->match ? CreateMatch(_fbb, _o->match.get(), _rehasher) : 0;
	return server::CreateTMatch(
			_fbb,
			_match);
}

inline Dictionary TMatch::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = match();
		if (_e)
			_o["match"] = _e->UnPackToDict(_resolver);
	}
	return _o;
}

inline TMatchesJoinT *TMatchesJoin::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TMatchesJoinT> _o = std::unique_ptr<server::TMatchesJoinT>(new TMatchesJoinT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TMatchesJoin::UnPackTo(TMatchesJoinT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = matches();
		if (_e) {
			_o->matches.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->matches[_i] = std::unique_ptr<server::TMatchesJoin_::MatchJoinT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
}

inline flatbuffers::Offset<TMatchesJoin> TMatchesJoin::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TMatchesJoinT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTMatchesJoin(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TMatchesJoin> CreateTMatchesJoin(flatbuffers::FlatBufferBuilder &_fbb, const TMatchesJoinT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TMatchesJoinT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _matches = _fbb.CreateVector<flatbuffers::Offset<server::TMatchesJoin_::MatchJoin>>(
			_o->matches.size(), [](size_t i, _VectorArgs *__va) { return CreateMatchJoin(*__va->__fbb, __va->__o->matches[i].get(), __va->__rehasher); }, &_va);
	return server::CreateTMatchesJoin(
			_fbb,
			_matches);
}

inline Dictionary TMatchesJoin::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = matches();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["matches"] = _a;
		}
	}
	return _o;
}

namespace TMatchesJoin_ {

inline MatchJoinT *MatchJoin::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TMatchesJoin_::MatchJoinT> _o = std::unique_ptr<server::TMatchesJoin_::MatchJoinT>(new MatchJoinT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void MatchJoin::UnPackTo(MatchJoinT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = id();
		if (_e)
			_o->id = std::unique_ptr<server::TMatchesJoin_::MatchJoin_::AuthenticateResult4T>(_e->UnPack(_resolver));
	}
}

inline flatbuffers::Offset<MatchJoin> MatchJoin::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatchJoinT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateMatchJoin(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MatchJoin> CreateMatchJoin(flatbuffers::FlatBufferBuilder &_fbb, const MatchJoinT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const MatchJoinT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _id = _o->id ? CreateAuthenticateResult4(_fbb, _o->id.get(), _rehasher) : 0;
	return server::TMatchesJoin_::CreateMatchJoin(
			_fbb,
			_id);
}

inline Dictionary MatchJoin::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = id();
		if (_e)
			_o["id"] = _e->UnPackToDict(_resolver);
	}
	return _o;
}

namespace MatchJoin_ {

inline AuthenticateResult4T *AuthenticateResult4::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TMatchesJoin_::MatchJoin_::AuthenticateResult4T> _o = std::unique_ptr<server::TMatchesJoin_::MatchJoin_::AuthenticateResult4T>(new AuthenticateResult4T());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void AuthenticateResult4::UnPackTo(AuthenticateResult4T *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = match_id();
		if (_e)
			_o->match_id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = token();
		if (_e)
			_o->token = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<AuthenticateResult4> AuthenticateResult4::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateResult4T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateAuthenticateResult4(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AuthenticateResult4> CreateAuthenticateResult4(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateResult4T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const AuthenticateResult4T *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _match_id = _o->match_id.empty() ? 0 : _fbb.CreateString(_o->match_id);
	auto _token = _o->token.empty() ? 0 : _fbb.CreateString(_o->token);
	return server::TMatchesJoin_::MatchJoin_::CreateAuthenticateResult4(
			_fbb,
			_match_id,
			_token);
}

inline Dictionary AuthenticateResult4::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = match_id();
		if (_e)
			_o["match_id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = token();
		if (_e)
			_o["token"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

} // namespace MatchJoin_
} // namespace TMatchesJoin_

inline TMatchesT *TMatches::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TMatchesT> _o = std::unique_ptr<server::TMatchesT>(new TMatchesT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TMatches::UnPackTo(TMatchesT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = matches();
		if (_e) {
			_o->matches.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->matches[_i] = std::unique_ptr<server::MatchT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
}

inline flatbuffers::Offset<TMatches> TMatches::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TMatchesT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTMatches(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TMatches> CreateTMatches(flatbuffers::FlatBufferBuilder &_fbb, const TMatchesT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TMatchesT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _matches = _fbb.CreateVector<flatbuffers::Offset<server::Match>>(
			_o->matches.size(), [](size_t i, _VectorArgs *__va) { return CreateMatch(*__va->__fbb, __va->__o->matches[i].get(), __va->__rehasher); }, &_va);
	return server::CreateTMatches(
			_fbb,
			_matches);
}

inline Dictionary TMatches::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = matches();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["matches"] = _a;
		}
	}
	return _o;
}

inline MatchDataSendT *MatchDataSend::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::MatchDataSendT> _o = std::unique_ptr<server::MatchDataSendT>(new MatchDataSendT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void MatchDataSend::UnPackTo(MatchDataSendT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = match_id();
		if (_e)
			_o->match_id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = op_code();
		_o->op_code = _e;
	}
	{
		auto _e = data();
		if (_e) {
			_o->data.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->data[_i] = _e->Get(_i);
			}
		}
	}
	{
		auto _e = presences();
		if (_e) {
			_o->presences.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->presences[_i] = std::unique_ptr<server::UserPresenceT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
}

inline flatbuffers::Offset<MatchDataSend> MatchDataSend::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatchDataSendT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateMatchDataSend(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MatchDataSend> CreateMatchDataSend(flatbuffers::FlatBufferBuilder &_fbb, const MatchDataSendT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const MatchDataSendT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _match_id = _o->match_id.empty() ? 0 : _fbb.CreateString(_o->match_id);
	auto _op_code = _o->op_code;
	auto _data = _fbb.CreateVector(_o->data);
	auto _presences = _fbb.CreateVector<flatbuffers::Offset<server::UserPresence>>(
			_o->presences.size(), [](size_t i, _VectorArgs *__va) { return CreateUserPresence(*__va->__fbb, __va->__o->presences[i].get(), __va->__rehasher); }, &_va);
	return server::CreateMatchDataSend(
			_fbb,
			_match_id,
			_op_code,
			_data,
			_presences);
}

inline Dictionary MatchDataSend::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = match_id();
		if (_e)
			_o["match_id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = op_code();
		_o["op_code"] = _e;
	}
	{
		auto _e = data();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i);
			}
			_o["data"] = _a;
		}
	}
	{
		auto _e = presences();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["presences"] = _a;
		}
	}
	return _o;
}

inline MatchDataT *MatchData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::MatchDataT> _o = std::unique_ptr<server::MatchDataT>(new MatchDataT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void MatchData::UnPackTo(MatchDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = match_id();
		if (_e)
			_o->match_id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = presence();
		if (_e)
			_o->presence = std::unique_ptr<server::UserPresenceT>(_e->UnPack(_resolver));
	}
	{
		auto _e = op_code();
		_o->op_code = _e;
	}
	{
		auto _e = data();
		if (_e) {
			_o->data.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->data[_i] = _e->Get(_i);
			}
		}
	}
}

inline flatbuffers::Offset<MatchData> MatchData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatchDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateMatchData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MatchData> CreateMatchData(flatbuffers::FlatBufferBuilder &_fbb, const MatchDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const MatchDataT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _match_id = _o->match_id.empty() ? 0 : _fbb.CreateString(_o->match_id);
	auto _presence = _o->presence ? CreateUserPresence(_fbb, _o->presence.get(), _rehasher) : 0;
	auto _op_code = _o->op_code;
	auto _data = _fbb.CreateVector(_o->data);
	return server::CreateMatchData(
			_fbb,
			_match_id,
			_presence,
			_op_code,
			_data);
}

inline Dictionary MatchData::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = match_id();
		if (_e)
			_o["match_id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = presence();
		if (_e)
			_o["presence"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = op_code();
		_o["op_code"] = _e;
	}
	{
		auto _e = data();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i);
			}
			_o["data"] = _a;
		}
	}
	return _o;
}

inline TMatchesLeaveT *TMatchesLeave::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TMatchesLeaveT> _o = std::unique_ptr<server::TMatchesLeaveT>(new TMatchesLeaveT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TMatchesLeave::UnPackTo(TMatchesLeaveT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = match_ids();
		if (_e) {
			_o->match_ids.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->match_ids[_i] = CharString(_e->Get(_i)->c_str(), _e->Get(_i)->size());
			}
		}
	}
}

inline flatbuffers::Offset<TMatchesLeave> TMatchesLeave::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TMatchesLeaveT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTMatchesLeave(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TMatchesLeave> CreateTMatchesLeave(flatbuffers::FlatBufferBuilder &_fbb, const TMatchesLeaveT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TMatchesLeaveT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _match_ids = _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(
			_o->match_ids.size(), [](size_t i, _VectorArgs *__va) { return __va->__fbb->CreateString(__va->__o->match_ids[i]); }, &_va);
	return server::CreateTMatchesLeave(
			_fbb,
			_match_ids);
}

inline Dictionary TMatchesLeave::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = match_ids();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = CharString(_e->Get(_i)->c_str(), _e->Get(_i)->size());
			}
			_o["match_ids"] = _a;
		}
	}
	return _o;
}

inline TStorageListT *TStorageList::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TStorageListT> _o = std::unique_ptr<server::TStorageListT>(new TStorageListT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TStorageList::UnPackTo(TStorageListT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = user_id();
		if (_e)
			_o->user_id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = bucket();
		if (_e)
			_o->bucket = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = collection();
		if (_e)
			_o->collection = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = limit();
		_o->limit = _e;
	}
	{
		auto _e = cursor();
		if (_e)
			_o->cursor = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<TStorageList> TStorageList::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TStorageListT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTStorageList(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TStorageList> CreateTStorageList(flatbuffers::FlatBufferBuilder &_fbb, const TStorageListT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TStorageListT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _user_id = _o->user_id.empty() ? 0 : _fbb.CreateString(_o->user_id);
	auto _bucket = _o->bucket.empty() ? 0 : _fbb.CreateString(_o->bucket);
	auto _collection = _o->collection.empty() ? 0 : _fbb.CreateString(_o->collection);
	auto _limit = _o->limit;
	auto _cursor = _o->cursor.empty() ? 0 : _fbb.CreateString(_o->cursor);
	return server::CreateTStorageList(
			_fbb,
			_user_id,
			_bucket,
			_collection,
			_limit,
			_cursor);
}

inline Dictionary TStorageList::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = user_id();
		if (_e)
			_o["user_id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = bucket();
		if (_e)
			_o["bucket"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = collection();
		if (_e)
			_o["collection"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = limit();
		_o["limit"] = _e;
	}
	{
		auto _e = cursor();
		if (_e)
			_o["cursor"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

inline TStorageFetchT *TStorageFetch::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TStorageFetchT> _o = std::unique_ptr<server::TStorageFetchT>(new TStorageFetchT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TStorageFetch::UnPackTo(TStorageFetchT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = keys();
		if (_e) {
			_o->keys.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->keys[_i] = std::unique_ptr<server::TStorageFetch_::StorageKeyT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
}

inline flatbuffers::Offset<TStorageFetch> TStorageFetch::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TStorageFetchT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTStorageFetch(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TStorageFetch> CreateTStorageFetch(flatbuffers::FlatBufferBuilder &_fbb, const TStorageFetchT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TStorageFetchT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _keys = _fbb.CreateVector<flatbuffers::Offset<server::TStorageFetch_::StorageKey>>(
			_o->keys.size(), [](size_t i, _VectorArgs *__va) { return CreateStorageKey(*__va->__fbb, __va->__o->keys[i].get(), __va->__rehasher); }, &_va);
	return server::CreateTStorageFetch(
			_fbb,
			_keys);
}

inline Dictionary TStorageFetch::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = keys();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["keys"] = _a;
		}
	}
	return _o;
}

namespace TStorageFetch_ {

inline StorageKeyT *StorageKey::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TStorageFetch_::StorageKeyT> _o = std::unique_ptr<server::TStorageFetch_::StorageKeyT>(new StorageKeyT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void StorageKey::UnPackTo(StorageKeyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = bucket();
		if (_e)
			_o->bucket = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = collection();
		if (_e)
			_o->collection = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = record();
		if (_e)
			_o->record = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = user_id();
		if (_e)
			_o->user_id = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<StorageKey> StorageKey::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StorageKeyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateStorageKey(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StorageKey> CreateStorageKey(flatbuffers::FlatBufferBuilder &_fbb, const StorageKeyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const StorageKeyT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _bucket = _o->bucket.empty() ? 0 : _fbb.CreateString(_o->bucket);
	auto _collection = _o->collection.empty() ? 0 : _fbb.CreateString(_o->collection);
	auto _record = _o->record.empty() ? 0 : _fbb.CreateString(_o->record);
	auto _user_id = _o->user_id.empty() ? 0 : _fbb.CreateString(_o->user_id);
	return server::TStorageFetch_::CreateStorageKey(
			_fbb,
			_bucket,
			_collection,
			_record,
			_user_id);
}

inline Dictionary StorageKey::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = bucket();
		if (_e)
			_o["bucket"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = collection();
		if (_e)
			_o["collection"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = record();
		if (_e)
			_o["record"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = user_id();
		if (_e)
			_o["user_id"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

} // namespace TStorageFetch_

inline TStorageDataT *TStorageData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TStorageDataT> _o = std::unique_ptr<server::TStorageDataT>(new TStorageDataT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TStorageData::UnPackTo(TStorageDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = data();
		if (_e) {
			_o->data.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->data[_i] = std::unique_ptr<server::TStorageData_::StorageDataT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
	{
		auto _e = cursor();
		if (_e)
			_o->cursor = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<TStorageData> TStorageData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TStorageDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTStorageData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TStorageData> CreateTStorageData(flatbuffers::FlatBufferBuilder &_fbb, const TStorageDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TStorageDataT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _data = _fbb.CreateVector<flatbuffers::Offset<server::TStorageData_::StorageData>>(
			_o->data.size(), [](size_t i, _VectorArgs *__va) { return CreateStorageData(*__va->__fbb, __va->__o->data[i].get(), __va->__rehasher); }, &_va);
	auto _cursor = _o->cursor.empty() ? 0 : _fbb.CreateString(_o->cursor);
	return server::CreateTStorageData(
			_fbb,
			_data,
			_cursor);
}

inline Dictionary TStorageData::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = data();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["data"] = _a;
		}
	}
	{
		auto _e = cursor();
		if (_e)
			_o["cursor"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

namespace TStorageData_ {

inline StorageDataT *StorageData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TStorageData_::StorageDataT> _o = std::unique_ptr<server::TStorageData_::StorageDataT>(new StorageDataT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void StorageData::UnPackTo(StorageDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = bucket();
		if (_e)
			_o->bucket = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = collection();
		if (_e)
			_o->collection = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = record();
		if (_e)
			_o->record = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = user_id();
		if (_e)
			_o->user_id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = value();
		if (_e)
			_o->value = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = version();
		if (_e)
			_o->version = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = permission_read();
		_o->permission_read = _e;
	}
	{
		auto _e = permission_write();
		_o->permission_write = _e;
	}
	{
		auto _e = created_at();
		_o->created_at = _e;
	}
	{
		auto _e = updated_at();
		_o->updated_at = _e;
	}
	{
		auto _e = expires_at();
		_o->expires_at = _e;
	}
}

inline flatbuffers::Offset<StorageData> StorageData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StorageDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateStorageData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StorageData> CreateStorageData(flatbuffers::FlatBufferBuilder &_fbb, const StorageDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const StorageDataT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _bucket = _o->bucket.empty() ? 0 : _fbb.CreateString(_o->bucket);
	auto _collection = _o->collection.empty() ? 0 : _fbb.CreateString(_o->collection);
	auto _record = _o->record.empty() ? 0 : _fbb.CreateString(_o->record);
	auto _user_id = _o->user_id.empty() ? 0 : _fbb.CreateString(_o->user_id);
	auto _value = _o->value.empty() ? 0 : _fbb.CreateString(_o->value);
	auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
	auto _permission_read = _o->permission_read;
	auto _permission_write = _o->permission_write;
	auto _created_at = _o->created_at;
	auto _updated_at = _o->updated_at;
	auto _expires_at = _o->expires_at;
	return server::TStorageData_::CreateStorageData(
			_fbb,
			_bucket,
			_collection,
			_record,
			_user_id,
			_value,
			_version,
			_permission_read,
			_permission_write,
			_created_at,
			_updated_at,
			_expires_at);
}

inline Dictionary StorageData::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = bucket();
		if (_e)
			_o["bucket"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = collection();
		if (_e)
			_o["collection"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = record();
		if (_e)
			_o["record"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = user_id();
		if (_e)
			_o["user_id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = value();
		if (_e)
			_o["value"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = version();
		if (_e)
			_o["version"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = permission_read();
		_o["permission_read"] = _e;
	}
	{
		auto _e = permission_write();
		_o["permission_write"] = _e;
	}
	{
		auto _e = created_at();
		_o["created_at"] = _e;
	}
	{
		auto _e = updated_at();
		_o["updated_at"] = _e;
	}
	{
		auto _e = expires_at();
		_o["expires_at"] = _e;
	}
	return _o;
}

} // namespace TStorageData_

inline TStorageWriteT *TStorageWrite::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TStorageWriteT> _o = std::unique_ptr<server::TStorageWriteT>(new TStorageWriteT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TStorageWrite::UnPackTo(TStorageWriteT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = data();
		if (_e) {
			_o->data.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->data[_i] = std::unique_ptr<server::TStorageWrite_::StorageDataT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
}

inline flatbuffers::Offset<TStorageWrite> TStorageWrite::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TStorageWriteT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTStorageWrite(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TStorageWrite> CreateTStorageWrite(flatbuffers::FlatBufferBuilder &_fbb, const TStorageWriteT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TStorageWriteT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _data = _fbb.CreateVector<flatbuffers::Offset<server::TStorageWrite_::StorageData>>(
			_o->data.size(), [](size_t i, _VectorArgs *__va) { return CreateStorageData(*__va->__fbb, __va->__o->data[i].get(), __va->__rehasher); }, &_va);
	return server::CreateTStorageWrite(
			_fbb,
			_data);
}

inline Dictionary TStorageWrite::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = data();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["data"] = _a;
		}
	}
	return _o;
}

namespace TStorageWrite_ {

inline StorageDataT *StorageData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TStorageWrite_::StorageDataT> _o = std::unique_ptr<server::TStorageWrite_::StorageDataT>(new StorageDataT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void StorageData::UnPackTo(StorageDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = bucket();
		if (_e)
			_o->bucket = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = collection();
		if (_e)
			_o->collection = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = record();
		if (_e)
			_o->record = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = value();
		if (_e)
			_o->value = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = version();
		if (_e)
			_o->version = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = permission_read();
		_o->permission_read = _e;
	}
	{
		auto _e = permission_write();
		_o->permission_write = _e;
	}
}

inline flatbuffers::Offset<StorageData> StorageData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StorageDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateStorageData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StorageData> CreateStorageData(flatbuffers::FlatBufferBuilder &_fbb, const StorageDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const StorageDataT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _bucket = _o->bucket.empty() ? 0 : _fbb.CreateString(_o->bucket);
	auto _collection = _o->collection.empty() ? 0 : _fbb.CreateString(_o->collection);
	auto _record = _o->record.empty() ? 0 : _fbb.CreateString(_o->record);
	auto _value = _o->value.empty() ? 0 : _fbb.CreateString(_o->value);
	auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
	auto _permission_read = _o->permission_read;
	auto _permission_write = _o->permission_write;
	return server::TStorageWrite_::CreateStorageData(
			_fbb,
			_bucket,
			_collection,
			_record,
			_value,
			_version,
			_permission_read,
			_permission_write);
}

inline Dictionary StorageData::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = bucket();
		if (_e)
			_o["bucket"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = collection();
		if (_e)
			_o["collection"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = record();
		if (_e)
			_o["record"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = value();
		if (_e)
			_o["value"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = version();
		if (_e)
			_o["version"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = permission_read();
		_o["permission_read"] = _e;
	}
	{
		auto _e = permission_write();
		_o["permission_write"] = _e;
	}
	return _o;
}

} // namespace TStorageWrite_

inline TStorageUpdateT *TStorageUpdate::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TStorageUpdateT> _o = std::unique_ptr<server::TStorageUpdateT>(new TStorageUpdateT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TStorageUpdate::UnPackTo(TStorageUpdateT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = updates();
		if (_e) {
			_o->updates.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->updates[_i] = std::unique_ptr<server::TStorageUpdate_::StorageUpdateT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
}

inline flatbuffers::Offset<TStorageUpdate> TStorageUpdate::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TStorageUpdateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTStorageUpdate(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TStorageUpdate> CreateTStorageUpdate(flatbuffers::FlatBufferBuilder &_fbb, const TStorageUpdateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TStorageUpdateT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _updates = _fbb.CreateVector<flatbuffers::Offset<server::TStorageUpdate_::StorageUpdate>>(
			_o->updates.size(), [](size_t i, _VectorArgs *__va) { return CreateStorageUpdate(*__va->__fbb, __va->__o->updates[i].get(), __va->__rehasher); }, &_va);
	return server::CreateTStorageUpdate(
			_fbb,
			_updates);
}

inline Dictionary TStorageUpdate::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = updates();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["updates"] = _a;
		}
	}
	return _o;
}

namespace TStorageUpdate_ {

inline StorageUpdateT *StorageUpdate::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TStorageUpdate_::StorageUpdateT> _o = std::unique_ptr<server::TStorageUpdate_::StorageUpdateT>(new StorageUpdateT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void StorageUpdate::UnPackTo(StorageUpdateT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = key();
		if (_e)
			_o->key = std::unique_ptr<server::TStorageUpdate_::StorageUpdate_::StorageKeyT>(_e->UnPack(_resolver));
	}
	{
		auto _e = permission_read();
		_o->permission_read = _e;
	}
	{
		auto _e = permission_write();
		_o->permission_write = _e;
	}
	{
		auto _e = ops();
		if (_e) {
			_o->ops.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->ops[_i] = std::unique_ptr<server::TStorageUpdate_::StorageUpdate_::UpdateOpT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
}

inline flatbuffers::Offset<StorageUpdate> StorageUpdate::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StorageUpdateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateStorageUpdate(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StorageUpdate> CreateStorageUpdate(flatbuffers::FlatBufferBuilder &_fbb, const StorageUpdateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const StorageUpdateT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _key = _o->key ? CreateStorageKey(_fbb, _o->key.get(), _rehasher) : 0;
	auto _permission_read = _o->permission_read;
	auto _permission_write = _o->permission_write;
	auto _ops = _fbb.CreateVector<flatbuffers::Offset<server::TStorageUpdate_::StorageUpdate_::UpdateOp>>(
			_o->ops.size(), [](size_t i, _VectorArgs *__va) { return CreateUpdateOp(*__va->__fbb, __va->__o->ops[i].get(), __va->__rehasher); }, &_va);
	return server::TStorageUpdate_::CreateStorageUpdate(
			_fbb,
			_key,
			_permission_read,
			_permission_write,
			_ops);
}

inline Dictionary StorageUpdate::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = key();
		if (_e)
			_o["key"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = permission_read();
		_o["permission_read"] = _e;
	}
	{
		auto _e = permission_write();
		_o["permission_write"] = _e;
	}
	{
		auto _e = ops();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["ops"] = _a;
		}
	}
	return _o;
}

namespace StorageUpdate_ {

inline UpdateOpT *UpdateOp::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TStorageUpdate_::StorageUpdate_::UpdateOpT> _o = std::unique_ptr<server::TStorageUpdate_::StorageUpdate_::UpdateOpT>(new UpdateOpT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void UpdateOp::UnPackTo(UpdateOpT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = op();
		_o->op = _e;
	}
	{
		auto _e = path();
		if (_e)
			_o->path = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = value();
		if (_e)
			_o->value = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = from();
		if (_e)
			_o->from = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = conditional();
		_o->conditional = _e;
	}
	{
		auto _e = assertion();
		_o->assertion = _e;
	}
	{
		auto _e = ops();
		if (_e) {
			_o->ops.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->ops[_i] = std::unique_ptr<server::TStorageUpdate_::StorageUpdate_::UpdateOpT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
}

inline flatbuffers::Offset<UpdateOp> UpdateOp::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UpdateOpT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateUpdateOp(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UpdateOp> CreateUpdateOp(flatbuffers::FlatBufferBuilder &_fbb, const UpdateOpT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const UpdateOpT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _op = _o->op;
	auto _path = _o->path.empty() ? 0 : _fbb.CreateString(_o->path);
	auto _value = _o->value.empty() ? 0 : _fbb.CreateString(_o->value);
	auto _from = _o->from.empty() ? 0 : _fbb.CreateString(_o->from);
	auto _conditional = _o->conditional;
	auto _assertion = _o->assertion;
	auto _ops = _fbb.CreateVector<flatbuffers::Offset<server::TStorageUpdate_::StorageUpdate_::UpdateOp>>(
			_o->ops.size(), [](size_t i, _VectorArgs *__va) { return CreateUpdateOp(*__va->__fbb, __va->__o->ops[i].get(), __va->__rehasher); }, &_va);
	return server::TStorageUpdate_::StorageUpdate_::CreateUpdateOp(
			_fbb,
			_op,
			_path,
			_value,
			_from,
			_conditional,
			_assertion,
			_ops);
}

inline Dictionary UpdateOp::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = op();
		_o["op"] = _e;
	}
	{
		auto _e = path();
		if (_e)
			_o["path"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = value();
		if (_e)
			_o["value"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = from();
		if (_e)
			_o["from"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = conditional();
		_o["conditional"] = _e;
	}
	{
		auto _e = assertion();
		_o["assertion"] = _e;
	}
	{
		auto _e = ops();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["ops"] = _a;
		}
	}
	return _o;
}

inline StorageKeyT *StorageKey::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TStorageUpdate_::StorageUpdate_::StorageKeyT> _o = std::unique_ptr<server::TStorageUpdate_::StorageUpdate_::StorageKeyT>(new StorageKeyT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void StorageKey::UnPackTo(StorageKeyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = bucket();
		if (_e)
			_o->bucket = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = collection();
		if (_e)
			_o->collection = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = record();
		if (_e)
			_o->record = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = version();
		if (_e)
			_o->version = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<StorageKey> StorageKey::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StorageKeyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateStorageKey(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StorageKey> CreateStorageKey(flatbuffers::FlatBufferBuilder &_fbb, const StorageKeyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const StorageKeyT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _bucket = _o->bucket.empty() ? 0 : _fbb.CreateString(_o->bucket);
	auto _collection = _o->collection.empty() ? 0 : _fbb.CreateString(_o->collection);
	auto _record = _o->record.empty() ? 0 : _fbb.CreateString(_o->record);
	auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
	return server::TStorageUpdate_::StorageUpdate_::CreateStorageKey(
			_fbb,
			_bucket,
			_collection,
			_record,
			_version);
}

inline Dictionary StorageKey::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = bucket();
		if (_e)
			_o["bucket"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = collection();
		if (_e)
			_o["collection"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = record();
		if (_e)
			_o["record"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = version();
		if (_e)
			_o["version"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

} // namespace StorageUpdate_
} // namespace TStorageUpdate_

inline TStorageKeysT *TStorageKeys::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TStorageKeysT> _o = std::unique_ptr<server::TStorageKeysT>(new TStorageKeysT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TStorageKeys::UnPackTo(TStorageKeysT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = keys();
		if (_e) {
			_o->keys.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->keys[_i] = std::unique_ptr<server::TStorageKeys_::StorageKeyT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
}

inline flatbuffers::Offset<TStorageKeys> TStorageKeys::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TStorageKeysT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTStorageKeys(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TStorageKeys> CreateTStorageKeys(flatbuffers::FlatBufferBuilder &_fbb, const TStorageKeysT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TStorageKeysT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _keys = _fbb.CreateVector<flatbuffers::Offset<server::TStorageKeys_::StorageKey>>(
			_o->keys.size(), [](size_t i, _VectorArgs *__va) { return CreateStorageKey(*__va->__fbb, __va->__o->keys[i].get(), __va->__rehasher); }, &_va);
	return server::CreateTStorageKeys(
			_fbb,
			_keys);
}

inline Dictionary TStorageKeys::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = keys();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["keys"] = _a;
		}
	}
	return _o;
}

namespace TStorageKeys_ {

inline StorageKeyT *StorageKey::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TStorageKeys_::StorageKeyT> _o = std::unique_ptr<server::TStorageKeys_::StorageKeyT>(new StorageKeyT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void StorageKey::UnPackTo(StorageKeyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = bucket();
		if (_e)
			_o->bucket = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = collection();
		if (_e)
			_o->collection = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = record();
		if (_e)
			_o->record = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = version();
		if (_e)
			_o->version = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<StorageKey> StorageKey::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StorageKeyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateStorageKey(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StorageKey> CreateStorageKey(flatbuffers::FlatBufferBuilder &_fbb, const StorageKeyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const StorageKeyT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _bucket = _o->bucket.empty() ? 0 : _fbb.CreateString(_o->bucket);
	auto _collection = _o->collection.empty() ? 0 : _fbb.CreateString(_o->collection);
	auto _record = _o->record.empty() ? 0 : _fbb.CreateString(_o->record);
	auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
	return server::TStorageKeys_::CreateStorageKey(
			_fbb,
			_bucket,
			_collection,
			_record,
			_version);
}

inline Dictionary StorageKey::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = bucket();
		if (_e)
			_o["bucket"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = collection();
		if (_e)
			_o["collection"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = record();
		if (_e)
			_o["record"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = version();
		if (_e)
			_o["version"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

} // namespace TStorageKeys_

inline TStorageRemoveT *TStorageRemove::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TStorageRemoveT> _o = std::unique_ptr<server::TStorageRemoveT>(new TStorageRemoveT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TStorageRemove::UnPackTo(TStorageRemoveT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = keys();
		if (_e) {
			_o->keys.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->keys[_i] = std::unique_ptr<server::TStorageRemove_::StorageKeyT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
}

inline flatbuffers::Offset<TStorageRemove> TStorageRemove::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TStorageRemoveT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTStorageRemove(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TStorageRemove> CreateTStorageRemove(flatbuffers::FlatBufferBuilder &_fbb, const TStorageRemoveT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TStorageRemoveT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _keys = _fbb.CreateVector<flatbuffers::Offset<server::TStorageRemove_::StorageKey>>(
			_o->keys.size(), [](size_t i, _VectorArgs *__va) { return CreateStorageKey(*__va->__fbb, __va->__o->keys[i].get(), __va->__rehasher); }, &_va);
	return server::CreateTStorageRemove(
			_fbb,
			_keys);
}

inline Dictionary TStorageRemove::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = keys();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["keys"] = _a;
		}
	}
	return _o;
}

namespace TStorageRemove_ {

inline StorageKeyT *StorageKey::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TStorageRemove_::StorageKeyT> _o = std::unique_ptr<server::TStorageRemove_::StorageKeyT>(new StorageKeyT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void StorageKey::UnPackTo(StorageKeyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = bucket();
		if (_e)
			_o->bucket = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = collection();
		if (_e)
			_o->collection = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = record();
		if (_e)
			_o->record = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = version();
		if (_e)
			_o->version = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<StorageKey> StorageKey::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StorageKeyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateStorageKey(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StorageKey> CreateStorageKey(flatbuffers::FlatBufferBuilder &_fbb, const StorageKeyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const StorageKeyT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _bucket = _o->bucket.empty() ? 0 : _fbb.CreateString(_o->bucket);
	auto _collection = _o->collection.empty() ? 0 : _fbb.CreateString(_o->collection);
	auto _record = _o->record.empty() ? 0 : _fbb.CreateString(_o->record);
	auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
	return server::TStorageRemove_::CreateStorageKey(
			_fbb,
			_bucket,
			_collection,
			_record,
			_version);
}

inline Dictionary StorageKey::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = bucket();
		if (_e)
			_o["bucket"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = collection();
		if (_e)
			_o["collection"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = record();
		if (_e)
			_o["record"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = version();
		if (_e)
			_o["version"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

} // namespace TStorageRemove_

inline LeaderboardT *Leaderboard::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::LeaderboardT> _o = std::unique_ptr<server::LeaderboardT>(new LeaderboardT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void Leaderboard::UnPackTo(LeaderboardT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = id();
		if (_e)
			_o->id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = authoritative();
		_o->authoritative = _e;
	}
	{
		auto _e = sort();
		_o->sort = _e;
	}
	{
		auto _e = count();
		_o->count = _e;
	}
	{
		auto _e = reset_schedule();
		if (_e)
			_o->reset_schedule = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = metadata();
		if (_e)
			_o->metadata = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<Leaderboard> Leaderboard::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LeaderboardT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateLeaderboard(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Leaderboard> CreateLeaderboard(flatbuffers::FlatBufferBuilder &_fbb, const LeaderboardT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const LeaderboardT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
	auto _authoritative = _o->authoritative;
	auto _sort = _o->sort;
	auto _count = _o->count;
	auto _reset_schedule = _o->reset_schedule.empty() ? 0 : _fbb.CreateString(_o->reset_schedule);
	auto _metadata = _o->metadata.empty() ? 0 : _fbb.CreateString(_o->metadata);
	return server::CreateLeaderboard(
			_fbb,
			_id,
			_authoritative,
			_sort,
			_count,
			_reset_schedule,
			_metadata);
}

inline Dictionary Leaderboard::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = id();
		if (_e)
			_o["id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = authoritative();
		_o["authoritative"] = _e;
	}
	{
		auto _e = sort();
		_o["sort"] = _e;
	}
	{
		auto _e = count();
		_o["count"] = _e;
	}
	{
		auto _e = reset_schedule();
		if (_e)
			_o["reset_schedule"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = metadata();
		if (_e)
			_o["metadata"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

inline LeaderboardRecordT *LeaderboardRecord::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::LeaderboardRecordT> _o = std::unique_ptr<server::LeaderboardRecordT>(new LeaderboardRecordT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void LeaderboardRecord::UnPackTo(LeaderboardRecordT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = leaderboard_id();
		if (_e)
			_o->leaderboard_id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = owner_id();
		if (_e)
			_o->owner_id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = handle();
		if (_e)
			_o->handle = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = lang();
		if (_e)
			_o->lang = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = location();
		if (_e)
			_o->location = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = timezone();
		if (_e)
			_o->timezone = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = rank();
		_o->rank = _e;
	}
	{
		auto _e = score();
		_o->score = _e;
	}
	{
		auto _e = num_score();
		_o->num_score = _e;
	}
	{
		auto _e = metadata();
		if (_e)
			_o->metadata = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = ranked_at();
		_o->ranked_at = _e;
	}
	{
		auto _e = updated_at();
		_o->updated_at = _e;
	}
	{
		auto _e = expires_at();
		_o->expires_at = _e;
	}
}

inline flatbuffers::Offset<LeaderboardRecord> LeaderboardRecord::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LeaderboardRecordT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateLeaderboardRecord(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LeaderboardRecord> CreateLeaderboardRecord(flatbuffers::FlatBufferBuilder &_fbb, const LeaderboardRecordT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const LeaderboardRecordT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _leaderboard_id = _o->leaderboard_id.empty() ? 0 : _fbb.CreateString(_o->leaderboard_id);
	auto _owner_id = _o->owner_id.empty() ? 0 : _fbb.CreateString(_o->owner_id);
	auto _handle = _o->handle.empty() ? 0 : _fbb.CreateString(_o->handle);
	auto _lang = _o->lang.empty() ? 0 : _fbb.CreateString(_o->lang);
	auto _location = _o->location.empty() ? 0 : _fbb.CreateString(_o->location);
	auto _timezone = _o->timezone.empty() ? 0 : _fbb.CreateString(_o->timezone);
	auto _rank = _o->rank;
	auto _score = _o->score;
	auto _num_score = _o->num_score;
	auto _metadata = _o->metadata.empty() ? 0 : _fbb.CreateString(_o->metadata);
	auto _ranked_at = _o->ranked_at;
	auto _updated_at = _o->updated_at;
	auto _expires_at = _o->expires_at;
	return server::CreateLeaderboardRecord(
			_fbb,
			_leaderboard_id,
			_owner_id,
			_handle,
			_lang,
			_location,
			_timezone,
			_rank,
			_score,
			_num_score,
			_metadata,
			_ranked_at,
			_updated_at,
			_expires_at);
}

inline Dictionary LeaderboardRecord::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = leaderboard_id();
		if (_e)
			_o["leaderboard_id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = owner_id();
		if (_e)
			_o["owner_id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = handle();
		if (_e)
			_o["handle"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = lang();
		if (_e)
			_o["lang"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = location();
		if (_e)
			_o["location"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = timezone();
		if (_e)
			_o["timezone"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = rank();
		_o["rank"] = _e;
	}
	{
		auto _e = score();
		_o["score"] = _e;
	}
	{
		auto _e = num_score();
		_o["num_score"] = _e;
	}
	{
		auto _e = metadata();
		if (_e)
			_o["metadata"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = ranked_at();
		_o["ranked_at"] = _e;
	}
	{
		auto _e = updated_at();
		_o["updated_at"] = _e;
	}
	{
		auto _e = expires_at();
		_o["expires_at"] = _e;
	}
	return _o;
}

inline TLeaderboardsListT *TLeaderboardsList::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TLeaderboardsListT> _o = std::unique_ptr<server::TLeaderboardsListT>(new TLeaderboardsListT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TLeaderboardsList::UnPackTo(TLeaderboardsListT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = limit();
		_o->limit = _e;
	}
	{
		auto _e = cursor();
		if (_e)
			_o->cursor = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = filter_leaderboard_id();
		if (_e) {
			_o->filter_leaderboard_id.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->filter_leaderboard_id[_i] = CharString(_e->Get(_i)->c_str(), _e->Get(_i)->size());
			}
		}
	}
}

inline flatbuffers::Offset<TLeaderboardsList> TLeaderboardsList::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TLeaderboardsListT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTLeaderboardsList(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TLeaderboardsList> CreateTLeaderboardsList(flatbuffers::FlatBufferBuilder &_fbb, const TLeaderboardsListT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TLeaderboardsListT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _limit = _o->limit;
	auto _cursor = _o->cursor.empty() ? 0 : _fbb.CreateString(_o->cursor);
	auto _filter_leaderboard_id = _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(
			_o->filter_leaderboard_id.size(), [](size_t i, _VectorArgs *__va) { return __va->__fbb->CreateString(__va->__o->filter_leaderboard_id[i]); }, &_va);
	return server::CreateTLeaderboardsList(
			_fbb,
			_limit,
			_cursor,
			_filter_leaderboard_id);
}

inline Dictionary TLeaderboardsList::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = limit();
		_o["limit"] = _e;
	}
	{
		auto _e = cursor();
		if (_e)
			_o["cursor"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = filter_leaderboard_id();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = CharString(_e->Get(_i)->c_str(), _e->Get(_i)->size());
			}
			_o["filter_leaderboard_id"] = _a;
		}
	}
	return _o;
}

inline TLeaderboardsT *TLeaderboards::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TLeaderboardsT> _o = std::unique_ptr<server::TLeaderboardsT>(new TLeaderboardsT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TLeaderboards::UnPackTo(TLeaderboardsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = leaderboards();
		if (_e) {
			_o->leaderboards.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->leaderboards[_i] = std::unique_ptr<server::LeaderboardT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
	{
		auto _e = cursor();
		if (_e)
			_o->cursor = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<TLeaderboards> TLeaderboards::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TLeaderboardsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTLeaderboards(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TLeaderboards> CreateTLeaderboards(flatbuffers::FlatBufferBuilder &_fbb, const TLeaderboardsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TLeaderboardsT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _leaderboards = _fbb.CreateVector<flatbuffers::Offset<server::Leaderboard>>(
			_o->leaderboards.size(), [](size_t i, _VectorArgs *__va) { return CreateLeaderboard(*__va->__fbb, __va->__o->leaderboards[i].get(), __va->__rehasher); }, &_va);
	auto _cursor = _o->cursor.empty() ? 0 : _fbb.CreateString(_o->cursor);
	return server::CreateTLeaderboards(
			_fbb,
			_leaderboards,
			_cursor);
}

inline Dictionary TLeaderboards::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = leaderboards();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["leaderboards"] = _a;
		}
	}
	{
		auto _e = cursor();
		if (_e)
			_o["cursor"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

inline TLeaderboardRecordsWriteT *TLeaderboardRecordsWrite::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TLeaderboardRecordsWriteT> _o = std::unique_ptr<server::TLeaderboardRecordsWriteT>(new TLeaderboardRecordsWriteT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TLeaderboardRecordsWrite::UnPackTo(TLeaderboardRecordsWriteT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = records();
		if (_e) {
			_o->records.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->records[_i] = std::unique_ptr<server::TLeaderboardRecordsWrite_::LeaderboardRecordWriteT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
}

inline flatbuffers::Offset<TLeaderboardRecordsWrite> TLeaderboardRecordsWrite::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TLeaderboardRecordsWriteT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTLeaderboardRecordsWrite(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TLeaderboardRecordsWrite> CreateTLeaderboardRecordsWrite(flatbuffers::FlatBufferBuilder &_fbb, const TLeaderboardRecordsWriteT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TLeaderboardRecordsWriteT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _records = _fbb.CreateVector<flatbuffers::Offset<server::TLeaderboardRecordsWrite_::LeaderboardRecordWrite>>(
			_o->records.size(), [](size_t i, _VectorArgs *__va) { return CreateLeaderboardRecordWrite(*__va->__fbb, __va->__o->records[i].get(), __va->__rehasher); }, &_va);
	return server::CreateTLeaderboardRecordsWrite(
			_fbb,
			_records);
}

inline Dictionary TLeaderboardRecordsWrite::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = records();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["records"] = _a;
		}
	}
	return _o;
}

namespace TLeaderboardRecordsWrite_ {

inline LeaderboardRecordWriteT *LeaderboardRecordWrite::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TLeaderboardRecordsWrite_::LeaderboardRecordWriteT> _o = std::unique_ptr<server::TLeaderboardRecordsWrite_::LeaderboardRecordWriteT>(new LeaderboardRecordWriteT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void LeaderboardRecordWrite::UnPackTo(LeaderboardRecordWriteT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = leaderboard_id();
		if (_e)
			_o->leaderboard_id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = op();
		if (_e)
			_o->op = std::unique_ptr<server::TLeaderboardRecordsWrite_::LeaderboardRecordWrite_::ScoreOperatorT>(_e->UnPack(_resolver));
	}
	{
		auto _e = location();
		if (_e)
			_o->location = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = timezone();
		if (_e)
			_o->timezone = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = metadata();
		if (_e)
			_o->metadata = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<LeaderboardRecordWrite> LeaderboardRecordWrite::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LeaderboardRecordWriteT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateLeaderboardRecordWrite(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LeaderboardRecordWrite> CreateLeaderboardRecordWrite(flatbuffers::FlatBufferBuilder &_fbb, const LeaderboardRecordWriteT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const LeaderboardRecordWriteT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _leaderboard_id = _o->leaderboard_id.empty() ? 0 : _fbb.CreateString(_o->leaderboard_id);
	auto _op = _o->op ? CreateScoreOperator(_fbb, _o->op.get(), _rehasher) : 0;
	auto _location = _o->location.empty() ? 0 : _fbb.CreateString(_o->location);
	auto _timezone = _o->timezone.empty() ? 0 : _fbb.CreateString(_o->timezone);
	auto _metadata = _o->metadata.empty() ? 0 : _fbb.CreateString(_o->metadata);
	return server::TLeaderboardRecordsWrite_::CreateLeaderboardRecordWrite(
			_fbb,
			_leaderboard_id,
			_op,
			_location,
			_timezone,
			_metadata);
}

inline Dictionary LeaderboardRecordWrite::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = leaderboard_id();
		if (_e)
			_o["leaderboard_id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = op();
		if (_e)
			_o["op"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = location();
		if (_e)
			_o["location"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = timezone();
		if (_e)
			_o["timezone"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = metadata();
		if (_e)
			_o["metadata"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

namespace LeaderboardRecordWrite_ {

inline ScoreOperatorT *ScoreOperator::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TLeaderboardRecordsWrite_::LeaderboardRecordWrite_::ScoreOperatorT> _o = std::unique_ptr<server::TLeaderboardRecordsWrite_::LeaderboardRecordWrite_::ScoreOperatorT>(new ScoreOperatorT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void ScoreOperator::UnPackTo(ScoreOperatorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = incr();
		_o->incr = _e;
	}
	{
		auto _e = decr();
		_o->decr = _e;
	}
	{
		auto _e = set();
		_o->set = _e;
	}
	{
		auto _e = best();
		_o->best = _e;
	}
}

inline flatbuffers::Offset<ScoreOperator> ScoreOperator::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScoreOperatorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateScoreOperator(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ScoreOperator> CreateScoreOperator(flatbuffers::FlatBufferBuilder &_fbb, const ScoreOperatorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const ScoreOperatorT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _incr = _o->incr;
	auto _decr = _o->decr;
	auto _set = _o->set;
	auto _best = _o->best;
	return server::TLeaderboardRecordsWrite_::LeaderboardRecordWrite_::CreateScoreOperator(
			_fbb,
			_incr,
			_decr,
			_set,
			_best);
}

inline Dictionary ScoreOperator::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = incr();
		_o["incr"] = _e;
	}
	{
		auto _e = decr();
		_o["decr"] = _e;
	}
	{
		auto _e = set();
		_o["set"] = _e;
	}
	{
		auto _e = best();
		_o["best"] = _e;
	}
	return _o;
}

} // namespace LeaderboardRecordWrite_
} // namespace TLeaderboardRecordsWrite_

inline TLeaderboardRecordsFetchT *TLeaderboardRecordsFetch::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TLeaderboardRecordsFetchT> _o = std::unique_ptr<server::TLeaderboardRecordsFetchT>(new TLeaderboardRecordsFetchT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TLeaderboardRecordsFetch::UnPackTo(TLeaderboardRecordsFetchT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = leaderboard_ids();
		if (_e) {
			_o->leaderboard_ids.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->leaderboard_ids[_i] = CharString(_e->Get(_i)->c_str(), _e->Get(_i)->size());
			}
		}
	}
	{
		auto _e = limit();
		_o->limit = _e;
	}
	{
		auto _e = cursor();
		if (_e)
			_o->cursor = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<TLeaderboardRecordsFetch> TLeaderboardRecordsFetch::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TLeaderboardRecordsFetchT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTLeaderboardRecordsFetch(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TLeaderboardRecordsFetch> CreateTLeaderboardRecordsFetch(flatbuffers::FlatBufferBuilder &_fbb, const TLeaderboardRecordsFetchT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TLeaderboardRecordsFetchT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _leaderboard_ids = _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(
			_o->leaderboard_ids.size(), [](size_t i, _VectorArgs *__va) { return __va->__fbb->CreateString(__va->__o->leaderboard_ids[i]); }, &_va);
	auto _limit = _o->limit;
	auto _cursor = _o->cursor.empty() ? 0 : _fbb.CreateString(_o->cursor);
	return server::CreateTLeaderboardRecordsFetch(
			_fbb,
			_leaderboard_ids,
			_limit,
			_cursor);
}

inline Dictionary TLeaderboardRecordsFetch::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = leaderboard_ids();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = CharString(_e->Get(_i)->c_str(), _e->Get(_i)->size());
			}
			_o["leaderboard_ids"] = _a;
		}
	}
	{
		auto _e = limit();
		_o["limit"] = _e;
	}
	{
		auto _e = cursor();
		if (_e)
			_o["cursor"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

inline TLeaderboardRecordsListT *TLeaderboardRecordsList::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TLeaderboardRecordsListT> _o = std::unique_ptr<server::TLeaderboardRecordsListT>(new TLeaderboardRecordsListT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TLeaderboardRecordsList::UnPackTo(TLeaderboardRecordsListT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = leaderboard_id();
		if (_e)
			_o->leaderboard_id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = filter();
		if (_e)
			_o->filter = std::unique_ptr<server::TLeaderboardRecordsList_::AuthenticateResult6T>(_e->UnPack(_resolver));
	}
	{
		auto _e = limit();
		_o->limit = _e;
	}
	{
		auto _e = cursor();
		if (_e)
			_o->cursor = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<TLeaderboardRecordsList> TLeaderboardRecordsList::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TLeaderboardRecordsListT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTLeaderboardRecordsList(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TLeaderboardRecordsList> CreateTLeaderboardRecordsList(flatbuffers::FlatBufferBuilder &_fbb, const TLeaderboardRecordsListT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TLeaderboardRecordsListT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _leaderboard_id = _o->leaderboard_id.empty() ? 0 : _fbb.CreateString(_o->leaderboard_id);
	auto _filter = _o->filter ? CreateAuthenticateResult6(_fbb, _o->filter.get(), _rehasher) : 0;
	auto _limit = _o->limit;
	auto _cursor = _o->cursor.empty() ? 0 : _fbb.CreateString(_o->cursor);
	return server::CreateTLeaderboardRecordsList(
			_fbb,
			_leaderboard_id,
			_filter,
			_limit,
			_cursor);
}

inline Dictionary TLeaderboardRecordsList::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = leaderboard_id();
		if (_e)
			_o["leaderboard_id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = filter();
		if (_e)
			_o["filter"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = limit();
		_o["limit"] = _e;
	}
	{
		auto _e = cursor();
		if (_e)
			_o["cursor"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

namespace TLeaderboardRecordsList_ {

inline OwnersT *Owners::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TLeaderboardRecordsList_::OwnersT> _o = std::unique_ptr<server::TLeaderboardRecordsList_::OwnersT>(new OwnersT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void Owners::UnPackTo(OwnersT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = owner_ids();
		if (_e) {
			_o->owner_ids.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->owner_ids[_i] = CharString(_e->Get(_i)->c_str(), _e->Get(_i)->size());
			}
		}
	}
}

inline flatbuffers::Offset<Owners> Owners::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OwnersT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateOwners(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Owners> CreateOwners(flatbuffers::FlatBufferBuilder &_fbb, const OwnersT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const OwnersT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _owner_ids = _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(
			_o->owner_ids.size(), [](size_t i, _VectorArgs *__va) { return __va->__fbb->CreateString(__va->__o->owner_ids[i]); }, &_va);
	return server::TLeaderboardRecordsList_::CreateOwners(
			_fbb,
			_owner_ids);
}

inline Dictionary Owners::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = owner_ids();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = CharString(_e->Get(_i)->c_str(), _e->Get(_i)->size());
			}
			_o["owner_ids"] = _a;
		}
	}
	return _o;
}

inline AuthenticateResult6T *AuthenticateResult6::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TLeaderboardRecordsList_::AuthenticateResult6T> _o = std::unique_ptr<server::TLeaderboardRecordsList_::AuthenticateResult6T>(new AuthenticateResult6T());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void AuthenticateResult6::UnPackTo(AuthenticateResult6T *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = owner_id();
		if (_e)
			_o->owner_id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = owner_ids();
		if (_e)
			_o->owner_ids = std::unique_ptr<server::TLeaderboardRecordsList_::OwnersT>(_e->UnPack(_resolver));
	}
	{
		auto _e = lang();
		if (_e)
			_o->lang = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = location();
		if (_e)
			_o->location = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = timezone();
		if (_e)
			_o->timezone = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<AuthenticateResult6> AuthenticateResult6::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateResult6T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateAuthenticateResult6(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AuthenticateResult6> CreateAuthenticateResult6(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateResult6T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const AuthenticateResult6T *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _owner_id = _o->owner_id.empty() ? 0 : _fbb.CreateString(_o->owner_id);
	auto _owner_ids = _o->owner_ids ? CreateOwners(_fbb, _o->owner_ids.get(), _rehasher) : 0;
	auto _lang = _o->lang.empty() ? 0 : _fbb.CreateString(_o->lang);
	auto _location = _o->location.empty() ? 0 : _fbb.CreateString(_o->location);
	auto _timezone = _o->timezone.empty() ? 0 : _fbb.CreateString(_o->timezone);
	return server::TLeaderboardRecordsList_::CreateAuthenticateResult6(
			_fbb,
			_owner_id,
			_owner_ids,
			_lang,
			_location,
			_timezone);
}

inline Dictionary AuthenticateResult6::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = owner_id();
		if (_e)
			_o["owner_id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = owner_ids();
		if (_e)
			_o["owner_ids"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = lang();
		if (_e)
			_o["lang"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = location();
		if (_e)
			_o["location"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = timezone();
		if (_e)
			_o["timezone"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

} // namespace TLeaderboardRecordsList_

inline TLeaderboardRecordsT *TLeaderboardRecords::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TLeaderboardRecordsT> _o = std::unique_ptr<server::TLeaderboardRecordsT>(new TLeaderboardRecordsT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TLeaderboardRecords::UnPackTo(TLeaderboardRecordsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = records();
		if (_e) {
			_o->records.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->records[_i] = std::unique_ptr<server::LeaderboardRecordT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
	{
		auto _e = cursor();
		if (_e)
			_o->cursor = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<TLeaderboardRecords> TLeaderboardRecords::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TLeaderboardRecordsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTLeaderboardRecords(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TLeaderboardRecords> CreateTLeaderboardRecords(flatbuffers::FlatBufferBuilder &_fbb, const TLeaderboardRecordsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TLeaderboardRecordsT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _records = _fbb.CreateVector<flatbuffers::Offset<server::LeaderboardRecord>>(
			_o->records.size(), [](size_t i, _VectorArgs *__va) { return CreateLeaderboardRecord(*__va->__fbb, __va->__o->records[i].get(), __va->__rehasher); }, &_va);
	auto _cursor = _o->cursor.empty() ? 0 : _fbb.CreateString(_o->cursor);
	return server::CreateTLeaderboardRecords(
			_fbb,
			_records,
			_cursor);
}

inline Dictionary TLeaderboardRecords::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = records();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["records"] = _a;
		}
	}
	{
		auto _e = cursor();
		if (_e)
			_o["cursor"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

inline TRpcT *TRpc::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TRpcT> _o = std::unique_ptr<server::TRpcT>(new TRpcT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TRpc::UnPackTo(TRpcT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = id();
		if (_e)
			_o->id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = payload();
		if (_e)
			_o->payload = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<TRpc> TRpc::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TRpcT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTRpc(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TRpc> CreateTRpc(flatbuffers::FlatBufferBuilder &_fbb, const TRpcT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TRpcT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
	auto _payload = _o->payload.empty() ? 0 : _fbb.CreateString(_o->payload);
	return server::CreateTRpc(
			_fbb,
			_id,
			_payload);
}

inline Dictionary TRpc::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = id();
		if (_e)
			_o["id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = payload();
		if (_e)
			_o["payload"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

inline TPurchaseValidationT *TPurchaseValidation::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TPurchaseValidationT> _o = std::unique_ptr<server::TPurchaseValidationT>(new TPurchaseValidationT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TPurchaseValidation::UnPackTo(TPurchaseValidationT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = id();
		if (_e)
			_o->id = std::unique_ptr<server::TPurchaseValidation_::AuthenticateResult7T>(_e->UnPack(_resolver));
	}
}

inline flatbuffers::Offset<TPurchaseValidation> TPurchaseValidation::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TPurchaseValidationT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTPurchaseValidation(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TPurchaseValidation> CreateTPurchaseValidation(flatbuffers::FlatBufferBuilder &_fbb, const TPurchaseValidationT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TPurchaseValidationT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _id = _o->id ? CreateAuthenticateResult7(_fbb, _o->id.get(), _rehasher) : 0;
	return server::CreateTPurchaseValidation(
			_fbb,
			_id);
}

inline Dictionary TPurchaseValidation::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = id();
		if (_e)
			_o["id"] = _e->UnPackToDict(_resolver);
	}
	return _o;
}

namespace TPurchaseValidation_ {

inline ApplePurchaseT *ApplePurchase::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TPurchaseValidation_::ApplePurchaseT> _o = std::unique_ptr<server::TPurchaseValidation_::ApplePurchaseT>(new ApplePurchaseT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void ApplePurchase::UnPackTo(ApplePurchaseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = product_id();
		if (_e)
			_o->product_id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = receipt_data();
		if (_e)
			_o->receipt_data = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<ApplePurchase> ApplePurchase::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ApplePurchaseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateApplePurchase(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ApplePurchase> CreateApplePurchase(flatbuffers::FlatBufferBuilder &_fbb, const ApplePurchaseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const ApplePurchaseT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _product_id = _o->product_id.empty() ? 0 : _fbb.CreateString(_o->product_id);
	auto _receipt_data = _o->receipt_data.empty() ? 0 : _fbb.CreateString(_o->receipt_data);
	return server::TPurchaseValidation_::CreateApplePurchase(
			_fbb,
			_product_id,
			_receipt_data);
}

inline Dictionary ApplePurchase::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = product_id();
		if (_e)
			_o["product_id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = receipt_data();
		if (_e)
			_o["receipt_data"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

inline GooglePurchaseT *GooglePurchase::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TPurchaseValidation_::GooglePurchaseT> _o = std::unique_ptr<server::TPurchaseValidation_::GooglePurchaseT>(new GooglePurchaseT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void GooglePurchase::UnPackTo(GooglePurchaseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = product_id();
		if (_e)
			_o->product_id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = product_type();
		if (_e)
			_o->product_type = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = purchase_token();
		if (_e)
			_o->purchase_token = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<GooglePurchase> GooglePurchase::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GooglePurchaseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateGooglePurchase(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GooglePurchase> CreateGooglePurchase(flatbuffers::FlatBufferBuilder &_fbb, const GooglePurchaseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const GooglePurchaseT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _product_id = _o->product_id.empty() ? 0 : _fbb.CreateString(_o->product_id);
	auto _product_type = _o->product_type.empty() ? 0 : _fbb.CreateString(_o->product_type);
	auto _purchase_token = _o->purchase_token.empty() ? 0 : _fbb.CreateString(_o->purchase_token);
	return server::TPurchaseValidation_::CreateGooglePurchase(
			_fbb,
			_product_id,
			_product_type,
			_purchase_token);
}

inline Dictionary GooglePurchase::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = product_id();
		if (_e)
			_o["product_id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = product_type();
		if (_e)
			_o["product_type"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = purchase_token();
		if (_e)
			_o["purchase_token"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

inline AuthenticateResult7T *AuthenticateResult7::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TPurchaseValidation_::AuthenticateResult7T> _o = std::unique_ptr<server::TPurchaseValidation_::AuthenticateResult7T>(new AuthenticateResult7T());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void AuthenticateResult7::UnPackTo(AuthenticateResult7T *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = apple_purchase();
		if (_e)
			_o->apple_purchase = std::unique_ptr<server::TPurchaseValidation_::ApplePurchaseT>(_e->UnPack(_resolver));
	}
	{
		auto _e = google_purchase();
		if (_e)
			_o->google_purchase = std::unique_ptr<server::TPurchaseValidation_::GooglePurchaseT>(_e->UnPack(_resolver));
	}
}

inline flatbuffers::Offset<AuthenticateResult7> AuthenticateResult7::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateResult7T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateAuthenticateResult7(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AuthenticateResult7> CreateAuthenticateResult7(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateResult7T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const AuthenticateResult7T *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _apple_purchase = _o->apple_purchase ? CreateApplePurchase(_fbb, _o->apple_purchase.get(), _rehasher) : 0;
	auto _google_purchase = _o->google_purchase ? CreateGooglePurchase(_fbb, _o->google_purchase.get(), _rehasher) : 0;
	return server::TPurchaseValidation_::CreateAuthenticateResult7(
			_fbb,
			_apple_purchase,
			_google_purchase);
}

inline Dictionary AuthenticateResult7::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = apple_purchase();
		if (_e)
			_o["apple_purchase"] = _e->UnPackToDict(_resolver);
	}
	{
		auto _e = google_purchase();
		if (_e)
			_o["google_purchase"] = _e->UnPackToDict(_resolver);
	}
	return _o;
}

} // namespace TPurchaseValidation_

inline TPurchaseRecordT *TPurchaseRecord::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TPurchaseRecordT> _o = std::unique_ptr<server::TPurchaseRecordT>(new TPurchaseRecordT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TPurchaseRecord::UnPackTo(TPurchaseRecordT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = success();
		_o->success = _e;
	}
	{
		auto _e = seen_before();
		_o->seen_before = _e;
	}
	{
		auto _e = purchase_provider_reachable();
		_o->purchase_provider_reachable = _e;
	}
	{
		auto _e = message();
		if (_e)
			_o->message = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = data();
		if (_e)
			_o->data = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<TPurchaseRecord> TPurchaseRecord::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TPurchaseRecordT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTPurchaseRecord(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TPurchaseRecord> CreateTPurchaseRecord(flatbuffers::FlatBufferBuilder &_fbb, const TPurchaseRecordT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TPurchaseRecordT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _success = _o->success;
	auto _seen_before = _o->seen_before;
	auto _purchase_provider_reachable = _o->purchase_provider_reachable;
	auto _message = _o->message.empty() ? 0 : _fbb.CreateString(_o->message);
	auto _data = _o->data.empty() ? 0 : _fbb.CreateString(_o->data);
	return server::CreateTPurchaseRecord(
			_fbb,
			_success,
			_seen_before,
			_purchase_provider_reachable,
			_message,
			_data);
}

inline Dictionary TPurchaseRecord::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = success();
		_o["success"] = _e;
	}
	{
		auto _e = seen_before();
		_o["seen_before"] = _e;
	}
	{
		auto _e = purchase_provider_reachable();
		_o["purchase_provider_reachable"] = _e;
	}
	{
		auto _e = message();
		if (_e)
			_o["message"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = data();
		if (_e)
			_o["data"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

inline NotificationT *Notification::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::NotificationT> _o = std::unique_ptr<server::NotificationT>(new NotificationT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void Notification::UnPackTo(NotificationT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = id();
		if (_e)
			_o->id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = subject();
		if (_e)
			_o->subject = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = content();
		if (_e)
			_o->content = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = code();
		_o->code = _e;
	}
	{
		auto _e = sender_id();
		if (_e)
			_o->sender_id = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = created_at();
		_o->created_at = _e;
	}
	{
		auto _e = expires_at();
		_o->expires_at = _e;
	}
	{
		auto _e = persistent();
		_o->persistent = _e;
	}
}

inline flatbuffers::Offset<Notification> Notification::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NotificationT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateNotification(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Notification> CreateNotification(flatbuffers::FlatBufferBuilder &_fbb, const NotificationT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const NotificationT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
	auto _subject = _o->subject.empty() ? 0 : _fbb.CreateString(_o->subject);
	auto _content = _o->content.empty() ? 0 : _fbb.CreateString(_o->content);
	auto _code = _o->code;
	auto _sender_id = _o->sender_id.empty() ? 0 : _fbb.CreateString(_o->sender_id);
	auto _created_at = _o->created_at;
	auto _expires_at = _o->expires_at;
	auto _persistent = _o->persistent;
	return server::CreateNotification(
			_fbb,
			_id,
			_subject,
			_content,
			_code,
			_sender_id,
			_created_at,
			_expires_at,
			_persistent);
}

inline Dictionary Notification::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = id();
		if (_e)
			_o["id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = subject();
		if (_e)
			_o["subject"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = content();
		if (_e)
			_o["content"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = code();
		_o["code"] = _e;
	}
	{
		auto _e = sender_id();
		if (_e)
			_o["sender_id"] = CharString(_e->c_str(), _e->size());
	}
	{
		auto _e = created_at();
		_o["created_at"] = _e;
	}
	{
		auto _e = expires_at();
		_o["expires_at"] = _e;
	}
	{
		auto _e = persistent();
		_o["persistent"] = _e;
	}
	return _o;
}

inline NotificationsT *Notifications::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::NotificationsT> _o = std::unique_ptr<server::NotificationsT>(new NotificationsT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void Notifications::UnPackTo(NotificationsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = notifications();
		if (_e) {
			_o->notifications.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->notifications[_i] = std::unique_ptr<server::NotificationT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
}

inline flatbuffers::Offset<Notifications> Notifications::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NotificationsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateNotifications(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Notifications> CreateNotifications(flatbuffers::FlatBufferBuilder &_fbb, const NotificationsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const NotificationsT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _notifications = _fbb.CreateVector<flatbuffers::Offset<server::Notification>>(
			_o->notifications.size(), [](size_t i, _VectorArgs *__va) { return CreateNotification(*__va->__fbb, __va->__o->notifications[i].get(), __va->__rehasher); }, &_va);
	return server::CreateNotifications(
			_fbb,
			_notifications);
}

inline Dictionary Notifications::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = notifications();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["notifications"] = _a;
		}
	}
	return _o;
}

inline TNotificationsListT *TNotificationsList::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TNotificationsListT> _o = std::unique_ptr<server::TNotificationsListT>(new TNotificationsListT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TNotificationsList::UnPackTo(TNotificationsListT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = limit();
		_o->limit = _e;
	}
	{
		auto _e = resumable_cursor();
		if (_e)
			_o->resumable_cursor = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<TNotificationsList> TNotificationsList::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TNotificationsListT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTNotificationsList(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TNotificationsList> CreateTNotificationsList(flatbuffers::FlatBufferBuilder &_fbb, const TNotificationsListT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TNotificationsListT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _limit = _o->limit;
	auto _resumable_cursor = _o->resumable_cursor.empty() ? 0 : _fbb.CreateString(_o->resumable_cursor);
	return server::CreateTNotificationsList(
			_fbb,
			_limit,
			_resumable_cursor);
}

inline Dictionary TNotificationsList::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = limit();
		_o["limit"] = _e;
	}
	{
		auto _e = resumable_cursor();
		if (_e)
			_o["resumable_cursor"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

inline TNotificationsT *TNotifications::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TNotificationsT> _o = std::unique_ptr<server::TNotificationsT>(new TNotificationsT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TNotifications::UnPackTo(TNotificationsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = notifications();
		if (_e) {
			_o->notifications.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->notifications[_i] = std::unique_ptr<server::NotificationT>(_e->Get(_i)->UnPack(_resolver));
			}
		}
	}
	{
		auto _e = resumable_cursor();
		if (_e)
			_o->resumable_cursor = CharString(_e->c_str(), _e->size());
	}
}

inline flatbuffers::Offset<TNotifications> TNotifications::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TNotificationsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTNotifications(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TNotifications> CreateTNotifications(flatbuffers::FlatBufferBuilder &_fbb, const TNotificationsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TNotificationsT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _notifications = _fbb.CreateVector<flatbuffers::Offset<server::Notification>>(
			_o->notifications.size(), [](size_t i, _VectorArgs *__va) { return CreateNotification(*__va->__fbb, __va->__o->notifications[i].get(), __va->__rehasher); }, &_va);
	auto _resumable_cursor = _o->resumable_cursor.empty() ? 0 : _fbb.CreateString(_o->resumable_cursor);
	return server::CreateTNotifications(
			_fbb,
			_notifications,
			_resumable_cursor);
}

inline Dictionary TNotifications::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = notifications();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = _e->Get(_i)->UnPackToDict(_resolver);
			}
			_o["notifications"] = _a;
		}
	}
	{
		auto _e = resumable_cursor();
		if (_e)
			_o["resumable_cursor"] = CharString(_e->c_str(), _e->size());
	}
	return _o;
}

inline TNotificationsRemoveT *TNotificationsRemove::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	std::unique_ptr<server::TNotificationsRemoveT> _o = std::unique_ptr<server::TNotificationsRemoveT>(new TNotificationsRemoveT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TNotificationsRemove::UnPackTo(TNotificationsRemoveT *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = notification_ids();
		if (_e) {
			_o->notification_ids.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->notification_ids[_i] = CharString(_e->Get(_i)->c_str(), _e->Get(_i)->size());
			}
		}
	}
}

inline flatbuffers::Offset<TNotificationsRemove> TNotificationsRemove::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TNotificationsRemoveT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateTNotificationsRemove(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TNotificationsRemove> CreateTNotificationsRemove(flatbuffers::FlatBufferBuilder &_fbb, const TNotificationsRemoveT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const TNotificationsRemoveT *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = { &_fbb, _o, _rehasher };
	(void)_va;
	auto _notification_ids = _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(
			_o->notification_ids.size(), [](size_t i, _VectorArgs *__va) { return __va->__fbb->CreateString(__va->__o->notification_ids[i]); }, &_va);
	return server::CreateTNotificationsRemove(
			_fbb,
			_notification_ids);
}

inline Dictionary TNotificationsRemove::UnPackToDict(const flatbuffers::resolver_function_t *_resolver) const {
	(void)_resolver;
	Dictionary _o;
	{
		auto _e = notification_ids();
		if (_e) {
			Array _a;
			_a.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_a[_i] = CharString(_e->Get(_i)->c_str(), _e->Get(_i)->size());
			}
			_o["notification_ids"] = _a;
		}
	}
	return _o;
}

inline const server::Envelope *GetEnvelope(const void *buf) {
	return flatbuffers::GetRoot<server::Envelope>(buf);
}

inline const server::Envelope *GetSizePrefixedEnvelope(const void *buf) {
	return flatbuffers::GetSizePrefixedRoot<server::Envelope>(buf);
}

inline bool VerifyEnvelopeBuffer(
		flatbuffers::Verifier &verifier) {
	return verifier.VerifyBuffer<server::Envelope>(nullptr);
}

inline bool VerifySizePrefixedEnvelopeBuffer(
		flatbuffers::Verifier &verifier) {
	return verifier.VerifySizePrefixedBuffer<server::Envelope>(nullptr);
}

inline void FinishEnvelopeBuffer(
		flatbuffers::FlatBufferBuilder &fbb,
		flatbuffers::Offset<server::Envelope> root) {
	fbb.Finish(root);
}

inline void FinishSizePrefixedEnvelopeBuffer(
		flatbuffers::FlatBufferBuilder &fbb,
		flatbuffers::Offset<server::Envelope> root) {
	fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<server::EnvelopeT> UnPackEnvelope(
		const void *buf,
		const flatbuffers::resolver_function_t *res = nullptr) {
	return std::unique_ptr<server::EnvelopeT>(GetEnvelope(buf)->UnPack(res));
}

inline std::unique_ptr<server::EnvelopeT> UnPackSizePrefixedEnvelope(
		const void *buf,
		const flatbuffers::resolver_function_t *res = nullptr) {
	return std::unique_ptr<server::EnvelopeT>(GetSizePrefixedEnvelope(buf)->UnPack(res));
}

} // namespace server

#endif // FLATBUFFERS_GENERATED_API_SERVER_H_
