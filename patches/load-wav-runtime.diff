From 1df3b57a9d219948c8392832f4bbc7d2c8902217 Mon Sep 17 00:00:00 2001
From: Saracen <SaracenOne@gmail.com>
Date: Fri, 4 Sep 2020 04:21:27 +0100
Subject: [PATCH 1/3] Refactors the wave file loading from the
 ResourceImporterWave into the AudioStreamSample as a function so that it can
 be called for runtime loading of wav files similar to how the Image class
 allows runtime loading of various image formats

---
 editor/import/resource_importer_wav.cpp | 305 +++++-------------------
 scene/resources/audio_stream_sample.cpp |  71 ++++++
 scene/resources/audio_stream_sample.h   | 193 +++++++++++++++
 3 files changed, 327 insertions(+), 242 deletions(-)

diff --git a/editor/import/resource_importer_wav.cpp b/editor/import/resource_importer_wav.cpp
index d86b39d350284..c16e8c829db9b 100644
--- a/editor/import/resource_importer_wav.cpp
+++ b/editor/import/resource_importer_wav.cpp
@@ -98,207 +98,28 @@ Error ResourceImporterWAV::import(const String &p_source_file, const String &p_s
 
 	ERR_FAIL_COND_V_MSG(err != OK, ERR_CANT_OPEN, "Cannot open file '" + p_source_file + "'.");
 
-	/* CHECK RIFF */
-	char riff[5];
-	riff[4] = 0;
-	file->get_buffer((uint8_t *)&riff, 4); //RIFF
-
-	if (riff[0] != 'R' || riff[1] != 'I' || riff[2] != 'F' || riff[3] != 'F') {
-
+	err = AudioStreamSample::parse_wave_data_header(file);
+	if (err != OK) {
 		file->close();
 		memdelete(file);
-		ERR_FAIL_V(ERR_FILE_UNRECOGNIZED);
+		return err;
 	}
 
-	/* GET FILESIZE */
-	file->get_32(); // filesize
-
-	/* CHECK WAVE */
-
-	char wave[4];
-
-	file->get_buffer((uint8_t *)&wave, 4); //RIFF
-
-	if (wave[0] != 'W' || wave[1] != 'A' || wave[2] != 'V' || wave[3] != 'E') {
-
-		file->close();
-		memdelete(file);
-		ERR_FAIL_V_MSG(ERR_FILE_UNRECOGNIZED, "Not a WAV file (no WAVE RIFF header).");
-	}
-
-	int format_bits = 0;
-	int format_channels = 0;
-
-	AudioStreamSample::LoopMode loop = AudioStreamSample::LOOP_DISABLED;
-	uint16_t compression_code = 1;
-	bool format_found = false;
-	bool data_found = false;
-	int format_freq = 0;
-	int loop_begin = 0;
-	int loop_end = 0;
-	int frames = 0;
-
-	Vector<float> data;
-
-	while (!file->eof_reached()) {
-
-		/* chunk */
-		char chunkID[4];
-		file->get_buffer((uint8_t *)&chunkID, 4); //RIFF
-
-		/* chunk size */
-		uint32_t chunksize = file->get_32();
-		uint32_t file_pos = file->get_position(); //save file pos, so we can skip to next chunk safely
-
-		if (file->eof_reached()) {
-
-			//ERR_PRINT("EOF REACH");
-			break;
-		}
-
-		if (chunkID[0] == 'f' && chunkID[1] == 'm' && chunkID[2] == 't' && chunkID[3] == ' ' && !format_found) {
-			/* IS FORMAT CHUNK */
-
-			//Issue: #7755 : Not a bug - usage of other formats (format codes) are unsupported in current importer version.
-			//Consider revision for engine version 3.0
-			compression_code = file->get_16();
-			if (compression_code != 1 && compression_code != 3) {
-				file->close();
-				memdelete(file);
-				ERR_FAIL_V_MSG(ERR_INVALID_DATA, "Format not supported for WAVE file (not PCM). Save WAVE files as uncompressed PCM instead.");
-			}
-
-			format_channels = file->get_16();
-			if (format_channels != 1 && format_channels != 2) {
-				file->close();
-				memdelete(file);
-				ERR_FAIL_V_MSG(ERR_INVALID_DATA, "Format not supported for WAVE file (not stereo or mono).");
-			}
-
-			format_freq = file->get_32(); //sampling rate
-
-			file->get_32(); // average bits/second (unused)
-			file->get_16(); // block align (unused)
-			format_bits = file->get_16(); // bits per sample
-
-			if (format_bits % 8 || format_bits == 0) {
-				file->close();
-				memdelete(file);
-				ERR_FAIL_V_MSG(ERR_INVALID_DATA, "Invalid amount of bits in the sample (should be one of 8, 16, 24 or 32).");
-			}
-
-			/* Don't need anything else, continue */
-			format_found = true;
-		}
+	AudioStreamSample::WaveData wave_data;
 
-		if (chunkID[0] == 'd' && chunkID[1] == 'a' && chunkID[2] == 't' && chunkID[3] == 'a' && !data_found) {
-			/* IS DATA CHUNK */
-			data_found = true;
-
-			if (!format_found) {
-				ERR_PRINT("'data' chunk before 'format' chunk found.");
-				break;
-			}
-
-			frames = chunksize;
-
-			if (format_channels == 0) {
-				file->close();
-				memdelete(file);
-				ERR_FAIL_COND_V(format_channels == 0, ERR_INVALID_DATA);
-			}
-			frames /= format_channels;
-			frames /= (format_bits >> 3);
-
-			/*print_line("chunksize: "+itos(chunksize));
-			print_line("channels: "+itos(format_channels));
-			print_line("bits: "+itos(format_bits));
-			*/
-
-			data.resize(frames * format_channels);
-
-			if (format_bits == 8) {
-				for (int i = 0; i < frames * format_channels; i++) {
-					// 8 bit samples are UNSIGNED
-
-					data.write[i] = int8_t(file->get_8() - 128) / 128.f;
-				}
-			} else if (format_bits == 32 && compression_code == 3) {
-				for (int i = 0; i < frames * format_channels; i++) {
-					//32 bit IEEE Float
-
-					data.write[i] = file->get_float();
-				}
-			} else if (format_bits == 16) {
-				for (int i = 0; i < frames * format_channels; i++) {
-					//16 bit SIGNED
-
-					data.write[i] = int16_t(file->get_16()) / 32768.f;
-				}
-			} else {
-				for (int i = 0; i < frames * format_channels; i++) {
-					//16+ bits samples are SIGNED
-					// if sample is > 16 bits, just read extra bytes
-
-					uint32_t s = 0;
-					for (int b = 0; b < (format_bits >> 3); b++) {
-
-						s |= ((uint32_t)file->get_8()) << (b * 8);
-					}
-					s <<= (32 - format_bits);
-
-					data.write[i] = (int32_t(s) >> 16) / 32768.f;
-				}
-			}
-
-			if (file->eof_reached()) {
-				file->close();
-				memdelete(file);
-				ERR_FAIL_V_MSG(ERR_FILE_CORRUPT, "Premature end of file.");
-			}
-		}
-
-		if (chunkID[0] == 's' && chunkID[1] == 'm' && chunkID[2] == 'p' && chunkID[3] == 'l') {
-			//loop point info!
-
-			/**
-			*	Consider exploring next document:
-			*		http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/Docs/RIFFNEW.pdf
-			*	Especially on page:
-			*		16 - 17
-			*	Timestamp:
-			*		22:38 06.07.2017 GMT
-			**/
-
-			for (int i = 0; i < 10; i++)
-				file->get_32(); // i wish to know why should i do this... no doc!
-
-			// only read 0x00 (loop forward), 0x01 (loop ping-pong) and 0x02 (loop backward)
-			// Skip anything else because it's not supported, reserved for future uses or sampler specific
-			// from https://sites.google.com/site/musicgapi/technical-documents/wav-file-format#smpl (loop type values table)
-			int loop_type = file->get_32();
-			if (loop_type == 0x00 || loop_type == 0x01 || loop_type == 0x02) {
-				if (loop_type == 0x00) {
-					loop = AudioStreamSample::LOOP_FORWARD;
-				} else if (loop_type == 0x01) {
-					loop = AudioStreamSample::LOOP_PING_PONG;
-				} else if (loop_type == 0x02) {
-					loop = AudioStreamSample::LOOP_BACKWARD;
-				}
-				loop_begin = file->get_32();
-				loop_end = file->get_32();
-			}
-		}
-		file->seek(file_pos + chunksize);
-	}
+	err = AudioStreamSample::parse_wave_data_body(file, &wave_data);
 
 	file->close();
 	memdelete(file);
 
+	if (err != OK) {
+		return err;
+	}
+
 	// STEP 2, APPLY CONVERSIONS
 
-	bool is16 = format_bits != 8;
-	int rate = format_freq;
+	bool is16 = wave_data.format_bits != 8;
+	int rate = wave_data.format_freq;
 
 	/*
 	print_line("Input Sample: ");
@@ -315,13 +136,13 @@ Error ResourceImporterWAV::import(const String &p_source_file, const String &p_s
 
 	bool limit_rate = p_options["force/max_rate"];
 	int limit_rate_hz = p_options["force/max_rate_hz"];
-	if (limit_rate && rate > limit_rate_hz && rate > 0 && frames > 0) {
+	if (limit_rate && rate > limit_rate_hz && rate > 0 && wave_data.frames > 0) {
 		// resample!
-		int new_data_frames = (int)(frames * (float)limit_rate_hz / (float)rate);
+		int new_data_frames = (int)(wave_data.frames * (float)limit_rate_hz / (float)rate);
 
 		Vector<float> new_data;
-		new_data.resize(new_data_frames * format_channels);
-		for (int c = 0; c < format_channels; c++) {
+		new_data.resize(new_data_frames * wave_data.format_channels);
+		for (int c = 0; c < wave_data.format_channels; c++) {
 
 			float frac = .0f;
 			int ipos = 0;
@@ -332,10 +153,10 @@ Error ResourceImporterWAV::import(const String &p_source_file, const String &p_s
 
 				float mu = frac;
 
-				float y0 = data[MAX(0, ipos - 1) * format_channels + c];
-				float y1 = data[ipos * format_channels + c];
-				float y2 = data[MIN(frames - 1, ipos + 1) * format_channels + c];
-				float y3 = data[MIN(frames - 1, ipos + 2) * format_channels + c];
+				float y0 = wave_data.data[MAX(0, ipos - 1) * wave_data.format_channels + c];
+				float y1 = wave_data.data[ipos * wave_data.format_channels + c];
+				float y2 = wave_data.data[MIN(wave_data.frames - 1, ipos + 1) * wave_data.format_channels + c];
+				float y3 = wave_data.data[MIN(wave_data.frames - 1, ipos + 2) * wave_data.format_channels + c];
 
 				float mu2 = mu * mu;
 				float a0 = y3 - y2 - y0 + y1;
@@ -345,7 +166,7 @@ Error ResourceImporterWAV::import(const String &p_source_file, const String &p_s
 
 				float res = (a0 * mu * mu2 + a1 * mu2 + a2 * mu + a3);
 
-				new_data.write[i * format_channels + c] = res;
+				new_data.write[i * wave_data.format_channels + c] = res;
 
 				// update position and always keep fractional part within ]0...1]
 				// in order to avoid 32bit floating point precision errors
@@ -357,14 +178,14 @@ Error ResourceImporterWAV::import(const String &p_source_file, const String &p_s
 			}
 		}
 
-		if (loop) {
-			loop_begin = (int)(loop_begin * (float)new_data_frames / (float)frames);
-			loop_end = (int)(loop_end * (float)new_data_frames / (float)frames);
+		if (wave_data.loop) {
+			wave_data.loop_begin = (int)(wave_data.loop_begin * (float)new_data_frames / (float)wave_data.frames);
+			wave_data.loop_end = (int)(wave_data.loop_end * (float)new_data_frames / (float)wave_data.frames);
 		}
 
-		data = new_data;
+		wave_data.data = new_data;
 		rate = limit_rate_hz;
-		frames = new_data_frames;
+		wave_data.frames = new_data_frames;
 	}
 
 	bool normalize = p_options["edit/normalize"];
@@ -372,9 +193,9 @@ Error ResourceImporterWAV::import(const String &p_source_file, const String &p_s
 	if (normalize) {
 
 		float max = 0;
-		for (int i = 0; i < data.size(); i++) {
+		for (int i = 0; i < wave_data.data.size(); i++) {
 
-			float amp = Math::abs(data[i]);
+			float amp = Math::abs(wave_data.data[i]);
 			if (amp > max)
 				max = amp;
 		}
@@ -382,29 +203,29 @@ Error ResourceImporterWAV::import(const String &p_source_file, const String &p_s
 		if (max > 0) {
 
 			float mult = 1.0 / max;
-			for (int i = 0; i < data.size(); i++) {
+			for (int i = 0; i < wave_data.data.size(); i++) {
 
-				data.write[i] *= mult;
+				wave_data.data.write[i] *= mult;
 			}
 		}
 	}
 
 	bool trim = p_options["edit/trim"];
 
-	if (trim && !loop && format_channels > 0) {
+	if (trim && !wave_data.loop && wave_data.format_channels > 0) {
 
 		int first = 0;
-		int last = (frames / format_channels) - 1;
+		int last = (wave_data.frames / wave_data.format_channels) - 1;
 		bool found = false;
 		float limit = Math::db2linear(TRIM_DB_LIMIT);
 
-		for (int i = 0; i < data.size() / format_channels; i++) {
+		for (int i = 0; i < wave_data.data.size() / wave_data.format_channels; i++) {
 			float ampChannelSum = 0;
-			for (int j = 0; j < format_channels; j++) {
-				ampChannelSum += Math::abs(data[(i * format_channels) + j]);
+			for (int j = 0; j < wave_data.format_channels; j++) {
+				ampChannelSum += Math::abs(wave_data.data[(i * wave_data.format_channels) + j]);
 			}
 
-			float amp = Math::abs(ampChannelSum / (float)format_channels);
+			float amp = Math::abs(ampChannelSum / (float)wave_data.format_channels);
 
 			if (!found && amp > limit) {
 				first = i;
@@ -418,7 +239,7 @@ Error ResourceImporterWAV::import(const String &p_source_file, const String &p_s
 
 		if (first < last) {
 			Vector<float> new_data;
-			new_data.resize((last - first) * format_channels);
+			new_data.resize((last - first) * wave_data.format_channels);
 			for (int i = first; i < last; i++) {
 
 				float fadeOutMult = 1;
@@ -427,38 +248,38 @@ Error ResourceImporterWAV::import(const String &p_source_file, const String &p_s
 					fadeOutMult = ((float)(last - i - 1) / (float)TRIM_FADE_OUT_FRAMES);
 				}
 
-				for (int j = 0; j < format_channels; j++) {
-					new_data.write[((i - first) * format_channels) + j] = data[(i * format_channels) + j] * fadeOutMult;
+				for (int j = 0; j < wave_data.format_channels; j++) {
+					new_data.write[((i - first) * wave_data.format_channels) + j] = wave_data.data[(i * wave_data.format_channels) + j] * fadeOutMult;
 				}
 			}
 
-			data = new_data;
-			frames = data.size() / format_channels;
+			wave_data.data = new_data;
+			wave_data.frames = wave_data.data.size() / wave_data.format_channels;
 		}
 	}
 
 	bool make_loop = p_options["edit/loop"];
 
-	if (make_loop && !loop) {
+	if (make_loop && !wave_data.loop) {
 
-		loop = AudioStreamSample::LOOP_FORWARD;
-		loop_begin = 0;
-		loop_end = frames;
+		wave_data.loop = AudioStreamSample::LOOP_FORWARD;
+		wave_data.loop_begin = 0;
+		wave_data.loop_end = wave_data.frames;
 	}
 
 	int compression = p_options["compress/mode"];
 	bool force_mono = p_options["force/mono"];
 
-	if (force_mono && format_channels == 2) {
+	if (force_mono && wave_data.format_channels == 2) {
 
 		Vector<float> new_data;
-		new_data.resize(data.size() / 2);
-		for (int i = 0; i < frames; i++) {
-			new_data.write[i] = (data[i * 2 + 0] + data[i * 2 + 1]) / 2.0;
+		new_data.resize(wave_data.data.size() / 2);
+		for (int i = 0; i < wave_data.frames; i++) {
+			new_data.write[i] = (wave_data.data[i * 2 + 0] + wave_data.data[i * 2 + 1]) / 2.0;
 		}
 
-		data = new_data;
-		format_channels = 1;
+		wave_data.data = new_data;
+		wave_data.format_channels = 1;
 	}
 
 	bool force_8_bit = p_options["force/8_bit"];
@@ -473,21 +294,21 @@ Error ResourceImporterWAV::import(const String &p_source_file, const String &p_s
 	if (compression == 1) {
 
 		dst_format = AudioStreamSample::FORMAT_IMA_ADPCM;
-		if (format_channels == 1) {
-			_compress_ima_adpcm(data, dst_data);
+		if (wave_data.format_channels == 1) {
+			_compress_ima_adpcm(wave_data.data, dst_data);
 		} else {
 
 			//byte interleave
 			Vector<float> left;
 			Vector<float> right;
 
-			int tframes = data.size() / 2;
+			int tframes = wave_data.data.size() / 2;
 			left.resize(tframes);
 			right.resize(tframes);
 
 			for (int i = 0; i < tframes; i++) {
-				left.write[i] = data[i * 2 + 0];
-				right.write[i] = data[i * 2 + 1];
+				left.write[i] = wave_data.data[i * 2 + 0];
+				right.write[i] = wave_data.data[i * 2 + 1];
 			}
 
 			PoolVector<uint8_t> bleft;
@@ -512,18 +333,18 @@ Error ResourceImporterWAV::import(const String &p_source_file, const String &p_s
 	} else {
 
 		dst_format = is16 ? AudioStreamSample::FORMAT_16_BITS : AudioStreamSample::FORMAT_8_BITS;
-		dst_data.resize(data.size() * (is16 ? 2 : 1));
+		dst_data.resize(wave_data.data.size() * (is16 ? 2 : 1));
 		{
 			PoolVector<uint8_t>::Write w = dst_data.write();
 
-			int ds = data.size();
+			int ds = wave_data.data.size();
 			for (int i = 0; i < ds; i++) {
 
 				if (is16) {
-					int16_t v = CLAMP(data[i] * 32768, -32768, 32767);
+					int16_t v = CLAMP(wave_data.data[i] * 32768, -32768, 32767);
 					encode_uint16(v, &w[i * 2]);
 				} else {
-					int8_t v = CLAMP(data[i] * 128, -128, 127);
+					int8_t v = CLAMP(wave_data.data[i] * 128, -128, 127);
 					w[i] = v;
 				}
 			}
@@ -535,10 +356,10 @@ Error ResourceImporterWAV::import(const String &p_source_file, const String &p_s
 	sample->set_data(dst_data);
 	sample->set_format(dst_format);
 	sample->set_mix_rate(rate);
-	sample->set_loop_mode(loop);
-	sample->set_loop_begin(loop_begin);
-	sample->set_loop_end(loop_end);
-	sample->set_stereo(format_channels == 2);
+	sample->set_loop_mode(wave_data.loop);
+	sample->set_loop_begin(wave_data.loop_begin);
+	sample->set_loop_end(wave_data.loop_end);
+	sample->set_stereo(wave_data.format_channels == 2);
 
 	ResourceSaver::save(p_save_path + ".sample", sample);
 
diff --git a/scene/resources/audio_stream_sample.cpp b/scene/resources/audio_stream_sample.cpp
index 14b50e9168ced..63a50cb78e26a 100644
--- a/scene/resources/audio_stream_sample.cpp
+++ b/scene/resources/audio_stream_sample.cpp
@@ -31,6 +31,7 @@
 #include "audio_stream_sample.h"
 
 #include "core/io/marshalls.h"
+#include "core/io/resource_loader.h"
 #include "core/os/file_access.h"
 
 void AudioStreamPlaybackSample::start(float p_from_pos) {
@@ -518,6 +519,75 @@ PoolVector<uint8_t> AudioStreamSample::get_data() const {
 	return pv;
 }
 
+Error AudioStreamSample::load(const String &p_path) {
+#ifdef DEBUG_ENABLED
+	if (p_path.begins_with("res://") && ResourceLoader::exists(p_path)) {
+		WARN_PRINTS("Loaded resource as image file, this will not work on export: '" + p_path + "'. Instead, import the image file as an Image resource and load it normally as a resource.");
+	}
+#endif
+	Error err;
+	FileAccess *file = FileAccess::open(p_path, FileAccess::READ, &err);
+	if (!file) {
+		ERR_PRINTS("Error opening file '" + p_path + "'.");
+		return err;
+	}
+
+	err = parse_wave_data_header(file);
+	if (err != OK) {
+		file->close();
+		memdelete(file);
+		return err;
+	}
+
+	AudioStreamSample::WaveData wave_data;
+	err = AudioStreamSample::parse_wave_data_body(file, &wave_data);
+
+	file->close();
+	memdelete(file);
+
+	if (err != OK) {
+		return err;
+	}
+
+	////////////////////////////////////////
+
+	bool is16 = wave_data.format_bits != 8;
+	int rate = wave_data.format_freq;
+
+	PoolVector<uint8_t> dst_data;
+	AudioStreamSample::Format dst_format;
+
+	dst_format = is16 ? AudioStreamSample::FORMAT_16_BITS : AudioStreamSample::FORMAT_8_BITS;
+	dst_data.resize(wave_data.data.size() * (is16 ? 2 : 1));
+	{
+		PoolVector<uint8_t>::Write w = dst_data.write();
+
+		int ds = wave_data.data.size();
+		for (int i = 0; i < ds; i++) {
+
+			if (is16) {
+				int16_t v = CLAMP(wave_data.data[i] * 32768, -32768, 32767);
+				encode_uint16(v, &w[i * 2]);
+			} else {
+				int8_t v = CLAMP(wave_data.data[i] * 128, -128, 127);
+				w[i] = v;
+			}
+		}
+	}
+
+	////////////////////////////////////////
+
+	set_data(dst_data);
+	set_format(dst_format);
+	set_mix_rate(rate);
+	set_loop_mode(wave_data.loop);
+	set_loop_begin(wave_data.loop_begin);
+	set_loop_end(wave_data.loop_end);
+	set_stereo(wave_data.format_channels == 2);
+
+	return OK;
+}
+
 Error AudioStreamSample::save_to_wav(const String &p_path) {
 	if (format == AudioStreamSample::FORMAT_IMA_ADPCM) {
 		WARN_PRINTS("Saving IMA_ADPC samples are not supported yet");
@@ -628,6 +698,7 @@ void AudioStreamSample::_bind_methods() {
 	ClassDB::bind_method(D_METHOD("set_stereo", "stereo"), &AudioStreamSample::set_stereo);
 	ClassDB::bind_method(D_METHOD("is_stereo"), &AudioStreamSample::is_stereo);
 
+	ClassDB::bind_method(D_METHOD("load", "path"), &AudioStreamSample::load);
 	ClassDB::bind_method(D_METHOD("save_to_wav", "path"), &AudioStreamSample::save_to_wav);
 
 	ADD_PROPERTY(PropertyInfo(Variant::POOL_BYTE_ARRAY, "data", PROPERTY_HINT_NONE, "", PROPERTY_USAGE_NOEDITOR), "set_data", "get_data");
diff --git a/scene/resources/audio_stream_sample.h b/scene/resources/audio_stream_sample.h
index 2ba3b6be5b076..490e9a87db410 100644
--- a/scene/resources/audio_stream_sample.h
+++ b/scene/resources/audio_stream_sample.h
@@ -98,6 +98,198 @@ class AudioStreamSample : public AudioStream {
 		LOOP_BACKWARD
 	};
 
+	struct WaveData {
+		int format_bits = 0;
+		int format_channels = 0;
+		AudioStreamSample::LoopMode loop = AudioStreamSample::LOOP_DISABLED;
+		uint16_t compression_code = 1;
+		bool format_found = false;
+		bool data_found = false;
+		int format_freq = 0;
+		int loop_begin = 0;
+		int loop_end = 0;
+		int frames = 0;
+
+		Vector<float> data;
+	};
+
+	static Error parse_wave_data_header(FileAccess *p_file) {
+		/* CHECK RIFF */
+		char riff[5];
+		riff[4] = 0;
+		p_file->get_buffer((uint8_t *)&riff, 4); //RIFF
+
+		if (riff[0] != 'R' || riff[1] != 'I' || riff[2] != 'F' || riff[3] != 'F') {
+
+			ERR_FAIL_V(ERR_FILE_UNRECOGNIZED);
+		}
+
+		/* GET FILESIZE */
+		p_file->get_32(); // filesize
+
+		/* CHECK WAVE */
+
+		char wave[4];
+
+		p_file->get_buffer((uint8_t *)&wave, 4); //RIFF
+
+		if (wave[0] != 'W' || wave[1] != 'A' || wave[2] != 'V' || wave[3] != 'E') {
+
+			ERR_FAIL_V_MSG(ERR_FILE_UNRECOGNIZED, "Not a WAV file (no WAVE RIFF header).");
+		}
+
+		return OK;
+	}
+
+	static Error parse_wave_data_body(FileAccess *p_file, WaveData *p_wave_data) {
+
+		while (!p_file->eof_reached()) {
+
+			/* chunk */
+			char chunkID[4];
+			p_file->get_buffer((uint8_t *)&chunkID, 4); //RIFF
+
+			/* chunk size */
+			uint32_t chunksize = p_file->get_32();
+			uint32_t file_pos = p_file->get_position(); //save file pos, so we can skip to next chunk safely
+
+			if (p_file->eof_reached()) {
+
+				//ERR_PRINT("EOF REACH");
+				break;
+			}
+
+			if (chunkID[0] == 'f' && chunkID[1] == 'm' && chunkID[2] == 't' && chunkID[3] == ' ' && !p_wave_data->format_found) {
+				/* IS FORMAT CHUNK */
+
+				//Issue: #7755 : Not a bug - usage of other formats (format codes) are unsupported in current importer version.
+				//Consider revision for engine version 3.0
+				p_wave_data->compression_code = p_file->get_16();
+				if (p_wave_data->compression_code != 1 && p_wave_data->compression_code != 3) {
+					ERR_FAIL_V_MSG(ERR_INVALID_DATA, "Format not supported for WAVE file (not PCM). Save WAVE files as uncompressed PCM instead.");
+				}
+
+				p_wave_data->format_channels = p_file->get_16();
+				if (p_wave_data->format_channels != 1 && p_wave_data->format_channels != 2) {
+					ERR_FAIL_V_MSG(ERR_INVALID_DATA, "Format not supported for WAVE file (not stereo or mono).");
+				}
+
+				p_wave_data->format_freq = p_file->get_32(); //sampling rate
+
+				p_file->get_32(); // average bits/second (unused)
+				p_file->get_16(); // block align (unused)
+				p_wave_data->format_bits = p_file->get_16(); // bits per sample
+
+				if (p_wave_data->format_bits % 8 || p_wave_data->format_bits == 0) {
+					ERR_FAIL_V_MSG(ERR_INVALID_DATA, "Invalid amount of bits in the sample (should be one of 8, 16, 24 or 32).");
+				}
+
+				/* Don't need anything else, continue */
+				p_wave_data->format_found = true;
+			}
+
+			if (chunkID[0] == 'd' && chunkID[1] == 'a' && chunkID[2] == 't' && chunkID[3] == 'a' && !p_wave_data->data_found) {
+				/* IS DATA CHUNK */
+				p_wave_data->data_found = true;
+
+				if (!p_wave_data->format_found) {
+					ERR_PRINT("'data' chunk before 'format' chunk found.");
+					break;
+				}
+
+				p_wave_data->frames = chunksize;
+
+				if (p_wave_data->format_channels == 0) {
+					p_file->close();
+					ERR_FAIL_COND_V(p_wave_data->format_channels == 0, ERR_INVALID_DATA);
+				}
+				p_wave_data->frames /= p_wave_data->format_channels;
+				p_wave_data->frames /= (p_wave_data->format_bits >> 3);
+
+				/*print_line("chunksize: "+itos(chunksize));
+				print_line("channels: "+itos(format_channels));
+				print_line("bits: "+itos(format_bits));
+				*/
+
+				p_wave_data->data.resize(p_wave_data->frames * p_wave_data->format_channels);
+
+				if (p_wave_data->format_bits == 8) {
+					for (int i = 0; i < p_wave_data->frames * p_wave_data->format_channels; i++) {
+						// 8 bit samples are UNSIGNED
+
+						p_wave_data->data.write[i] = int8_t(p_file->get_8() - 128) / 128.f;
+					}
+				} else if (p_wave_data->format_bits == 32 && p_wave_data->compression_code == 3) {
+					for (int i = 0; i < p_wave_data->frames * p_wave_data->format_channels; i++) {
+						//32 bit IEEE Float
+
+						p_wave_data->data.write[i] = p_file->get_float();
+					}
+				} else if (p_wave_data->format_bits == 16) {
+					for (int i = 0; i < p_wave_data->frames * p_wave_data->format_channels; i++) {
+						//16 bit SIGNED
+
+						p_wave_data->data.write[i] = int16_t(p_file->get_16()) / 32768.f;
+					}
+				} else {
+					for (int i = 0; i < p_wave_data->frames * p_wave_data->format_channels; i++) {
+						//16+ bits samples are SIGNED
+						// if sample is > 16 bits, just read extra bytes
+
+						uint32_t s = 0;
+						for (int b = 0; b < (p_wave_data->format_bits >> 3); b++) {
+
+							s |= ((uint32_t)p_file->get_8()) << (b * 8);
+						}
+						s <<= (32 - p_wave_data->format_bits);
+
+						p_wave_data->data.write[i] = (int32_t(s) >> 16) / 32768.f;
+					}
+				}
+
+				if (p_file->eof_reached()) {
+					p_file->close();
+					ERR_FAIL_V_MSG(ERR_FILE_CORRUPT, "Premature end of file.");
+				}
+			}
+
+			if (chunkID[0] == 's' && chunkID[1] == 'm' && chunkID[2] == 'p' && chunkID[3] == 'l') {
+				//loop point info!
+
+				/**
+				*	Consider exploring next document:
+				*		http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/Docs/RIFFNEW.pdf
+				*	Especially on page:
+				*		16 - 17
+				*	Timestamp:
+				*		22:38 06.07.2017 GMT
+				**/
+
+				for (int i = 0; i < 10; i++)
+					p_file->get_32(); // i wish to know why should i do this... no doc!
+
+				// only read 0x00 (loop forward), 0x01 (loop ping-pong) and 0x02 (loop backward)
+				// Skip anything else because it's not supported, reserved for future uses or sampler specific
+				// from https://sites.google.com/site/musicgapi/technical-documents/wav-file-format#smpl (loop type values table)
+				int loop_type = p_file->get_32();
+				if (loop_type == 0x00 || loop_type == 0x01 || loop_type == 0x02) {
+					if (loop_type == 0x00) {
+						p_wave_data->loop = AudioStreamSample::LOOP_FORWARD;
+					} else if (loop_type == 0x01) {
+						p_wave_data->loop = AudioStreamSample::LOOP_PING_PONG;
+					} else if (loop_type == 0x02) {
+						p_wave_data->loop = AudioStreamSample::LOOP_BACKWARD;
+					}
+					p_wave_data->loop_begin = p_file->get_32();
+					p_wave_data->loop_end = p_file->get_32();
+				}
+			}
+			p_file->seek(file_pos + chunksize);
+		}
+
+		return OK;
+	}
+
 private:
 	friend class AudioStreamPlaybackSample;
 
@@ -141,6 +333,7 @@ class AudioStreamSample : public AudioStream {
 	void set_data(const PoolVector<uint8_t> &p_data);
 	PoolVector<uint8_t> get_data() const;
 
+	Error load(const String &p_path);
 	Error save_to_wav(const String &p_path);
 
 	virtual Ref<AudioStreamPlayback> instance_playback();

From 47ee6294817a5fd352d7de0ea092e7696ecb37be Mon Sep 17 00:00:00 2001
From: Saracen <SaracenOne@gmail.com>
Date: Fri, 11 Sep 2020 03:26:14 +0100
Subject: [PATCH 2/3] Get default loop points from wave loading method.

---
 scene/resources/audio_stream_sample.h | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/scene/resources/audio_stream_sample.h b/scene/resources/audio_stream_sample.h
index 490e9a87db410..7b30f29bcd098 100644
--- a/scene/resources/audio_stream_sample.h
+++ b/scene/resources/audio_stream_sample.h
@@ -282,6 +282,9 @@ class AudioStreamSample : public AudioStream {
 					}
 					p_wave_data->loop_begin = p_file->get_32();
 					p_wave_data->loop_end = p_file->get_32();
+				} else {
+					p_wave_data->loop_begin = 0;
+					p_wave_data->loop_end = p_wave_data->frames;
 				}
 			}
 			p_file->seek(file_pos + chunksize);

From 6bd4cb000deec11e16615757d9f71d1ca8eef2c8 Mon Sep 17 00:00:00 2001
From: Saracen <SaracenOne@gmail.com>
Date: Fri, 11 Sep 2020 04:58:11 +0100
Subject: [PATCH 3/3] Fix for where default loop points are set.

---
 scene/resources/audio_stream_sample.h | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/scene/resources/audio_stream_sample.h b/scene/resources/audio_stream_sample.h
index 7b30f29bcd098..7d0db78d108a5 100644
--- a/scene/resources/audio_stream_sample.h
+++ b/scene/resources/audio_stream_sample.h
@@ -253,6 +253,10 @@ class AudioStreamSample : public AudioStream {
 				}
 			}
 
+			// Add a default loop
+			p_wave_data->loop_begin = 0;
+			p_wave_data->loop_end = p_wave_data->frames;
+
 			if (chunkID[0] == 's' && chunkID[1] == 'm' && chunkID[2] == 'p' && chunkID[3] == 'l') {
 				//loop point info!
 
@@ -282,9 +286,6 @@ class AudioStreamSample : public AudioStream {
 					}
 					p_wave_data->loop_begin = p_file->get_32();
 					p_wave_data->loop_end = p_file->get_32();
-				} else {
-					p_wave_data->loop_begin = 0;
-					p_wave_data->loop_end = p_wave_data->frames;
 				}
 			}
 			p_file->seek(file_pos + chunksize);
