--- imspinner_last.h	2023-01-13 17:25:00.000000000 +0100
+++ imspinner_patch.h	2023-01-13 17:25:00.000000000 +0100
@@ -1,3 +1,4 @@
+/* clang-format off */
 #ifndef _IMSPINNER_H_
 #define _IMSPINNER_H_
 
@@ -31,19 +32,9 @@
 #include <vector>
 #include <map>
 
-#ifdef __has_include
-    #if !__has_include(<imgui.h>)
-        #error "Couldn't find imgui.h in the header include path, please add it to the path!"
-    #endif // !<imgui.h>
-#endif // __has_include
-
-// imgui headers
-#include "imgui.h"
-#include "imgui_internal.h"
-
 namespace ImSpinner
 {
-#define DECLPROP(name,type,def) struct name { type value = def; operator type() { return value; } };
+#define DECLPROP(name,type,def) struct name { type value = def; operator type() { return value; } name(type v) : value(v) {} };
     enum SpinnerTypeT {
       e_st_rainbow = 0,
       e_st_angle,
@@ -140,7 +131,7 @@
     }
 
 #define SPINNER_HEADER(pos, size, centre, num_segments) ImVec2 pos, size, centre; int num_segments; if (!detail::SpinnerBegin(label, radius, pos, size, centre, num_segments)) { return; }; ImGuiWindow *window = ImGui::GetCurrentWindow(); \
-    auto circle = [&] (auto point_func, auto dbc, auto dth) { window->DrawList->PathClear(); for (int i = 0; i < num_segments; i++) { ImVec2 p = point_func(i); window->DrawList->PathLineTo(ImVec2(centre.x + p.x, centre.y + p.y)); } window->DrawList->PathStroke(dbc, false, dth); }
+    auto circle = [&] (point_f point_func, ImColor dbc, float dth) { window->DrawList->PathClear(); for (int i = 0; i < num_segments; i++) { ImVec2 p = point_func(i); window->DrawList->PathLineTo(ImVec2(centre.x + p.x, centre.y + p.y)); } window->DrawList->PathStroke(dbc, false, dth); }
     
     inline ImColor color_alpha(ImColor c, float alpha) { c.Value.w = alpha; return c; }
 
@@ -316,7 +307,7 @@
     {
         SPINNER_HEADER(pos, size, centre, num_segments);
 
-        auto ghalf_pi = [] (auto f) -> float { return ImMin(f, PI_DIV_2); };
+        auto ghalf_pi = [] (float f) -> float { return ImMin(f, PI_DIV_2); };
         const float start = ImFmod((float)ImGui::GetTime() * speed, IM_PI);
         const float bg_angle_offset = PI_2_DIV(lines);
         for (size_t j = 0; j < 3; ++j)
@@ -641,7 +632,7 @@
       const float start = ImFmod((float)ImGui::GetTime() * speed, PI_2);
       const float angle_offset = PI_2_DIV(num_segments - 1);
 
-      circle([&] (auto i) {
+      circle([&] (int i) {
           const float a = (i * angle_offset);
           return ImVec2(ImCos(a) * radius, ImSin(a) * radius);
       }, color1, thickness);
@@ -1669,7 +1660,7 @@
 
       window->DrawList->AddCircleFilled(centre, radius, bg, num_segments);
 
-      auto draw_gradient = [&] (auto b, auto e, auto th) {
+      auto draw_gradient = [&] (grad_f b, grad_f e, grad_f th) {
         for (int i = 0; i < num_segments; i++)
         {
           window->DrawList->AddLine(ImVec2(centre.x + ImCos(start + b(i)) * radius, centre.y + ImSin(start + b(i)) * radius),
@@ -1680,22 +1671,22 @@
 
       };
 
-      draw_gradient([&] (auto i) { return (num_segments + i) * angle_offset; },
-                    [&] (auto i) { return (num_segments + i + 1) * angle_offset; },
-                    [&] (auto i) { return thickness - th * i; });
-
-      draw_gradient([&] (auto i) { return (i) * angle_offset; },
-                    [&] (auto i) { return (i + 1) * angle_offset; },
-                    [&] (auto i) { return th * i; });
-
-      draw_gradient([&] (auto i) { return (num_segments + i) * angle_offset; },
-                    [&] (auto i) { return (num_segments + i + 1) * angle_offset; },
-                    [&] (auto i) { return thickness - th * i; });
+      draw_gradient([&] (int i) { return (num_segments + i) * angle_offset; },
+                    [&] (int i) { return (num_segments + i + 1) * angle_offset; },
+                    [&] (int i) { return thickness - th * i; });
+
+      draw_gradient([&] (int i) { return (i) * angle_offset; },
+                    [&] (int i) { return (i + 1) * angle_offset; },
+                    [&] (int i) { return th * i; });
+
+      draw_gradient([&] (int i) { return (num_segments + i) * angle_offset; },
+                    [&] (int i) { return (num_segments + i + 1) * angle_offset; },
+                    [&] (int i) { return thickness - th * i; });
 
       const float b_angle_offset = (PI_2 - angle) / num_segments; 
-      draw_gradient([&] (auto i) { return num_segments * angle_offset * 2.f + (i * b_angle_offset); },
-                    [&] (auto i) { return num_segments * angle_offset * 2.f + ((i + 1) * b_angle_offset); },
-                    [] (auto) { return 1.f; });
+      draw_gradient([&] (int i) { return num_segments * angle_offset * 2.f + (i * b_angle_offset); },
+                    [&] (int i) { return num_segments * angle_offset * 2.f + ((i + 1) * b_angle_offset); },
+                    [] (int) { return 1.f; });
     }
 
     inline void SpinnerCircleDrop(const char *label, float radius, float thickness, float thickness_drop, const ImColor &color = 0xffffffff, const ImColor &bg = 0xffffff80, float speed = 2.8f, float angle = IM_PI) 
@@ -1740,7 +1731,7 @@
       window->DrawList->AddCircleFilled(centre, thickness, bg, num_segments);
       window->DrawList->AddCircleFilled(centre, thickness, color_alpha(color, ImMax(0.1f, ImMin(lerp_koeff, 1.f))), num_segments);
 
-      auto PathArc = [&] (auto c, auto th) {
+      auto PathArc = [&] (ImU32 c, float th) {
         window->DrawList->PathClear();
         const float bg_angle_offset = PI_2 / num_segments;
         for (int i = 0; i <= num_segments; i++)
@@ -1763,7 +1754,7 @@
         window->DrawList->AddCircleFilled(pc, thickness, bg, num_segments);
         window->DrawList->AddCircleFilled(pc, thickness, color_alpha(color, ImMax(0.1f, ImMin(lerp_koeff, 1.f))), num_segments);
 
-        auto PathArc = [&] (auto as, auto c, auto th, auto r) {
+        auto PathArc = [&] (float as, ImU32 c, float th, float r) {
             window->DrawList->PathClear();
             const float bg_angle_offset = PI_DIV(2) / num_segments;
             for (int i = 0; i <= num_segments; i++)
@@ -1800,7 +1791,7 @@
       bars = ImMin<size_t>(bars, 32);
 
       const float rmin = radius - thickness;
-      auto get_points = [&] (auto left, auto right) -> std::array<ImVec2, 4> {
+      auto get_points = [&] (float left, float right) -> std::array<ImVec2, 4> {
         return {
           ImVec2(centre.x + ImCos(left) * rmin, centre.y + ImSin(left) * rmin),
           ImVec2(centre.x + ImCos(left) * radius, centre.y + ImSin(left) * radius),
@@ -1809,7 +1800,7 @@
         };
       };
 
-      auto draw_sectors = [&] (auto s, auto color_func) {
+      auto draw_sectors = [&] (float s, color_f color_func) {
         for (size_t i = 0; i <= bars; i++) {
           float left = s + (i * angle_offset) - angle_offset_t;
           float right = s + (i * angle_offset) + angle_offset_t;
@@ -1818,8 +1809,8 @@
         }
       };
 
-      draw_sectors(0, [&] (auto) { ImColor rc = bg; rc.Value.w = 0.1f; return rc; });
-      draw_sectors(start, [&] (auto i) { ImColor rc = bg; rc.Value.w = (i / (float)bars) - 0.5f; return rc; });
+      draw_sectors(0, [&] (int) { ImColor rc = bg; rc.Value.w = 0.1f; return rc; });
+      draw_sectors(start, [&] (int i) { ImColor rc = bg; rc.Value.w = (i / (float)bars) - 0.5f; return rc; });
     }
 
     using LeafColor = ImColor (int);
@@ -1833,7 +1824,7 @@
       bars = ImMin<size_t>(bars, 32);
 
       const float rmin = radius - thickness - 1;
-      auto get_points = [&] (auto left, auto right) -> std::array<ImVec2, 4> {
+      auto get_points = [&] (float left, float right) -> std::array<ImVec2, 4> {
         return {
           ImVec2(centre.x + ImCos(left - 0.1f) * radius, centre.y + ImSin(left - 0.1f) * radius),
           ImVec2(centre.x + ImCos(right + 0.15f) * radius, centre.y + ImSin(right + 0.15f) * radius),
@@ -1841,7 +1832,7 @@
         };
       };
 
-      auto draw_sectors = [&] (auto s, auto color_func) {
+      auto draw_sectors = [&] (float s, color_f color_func) {
         for (size_t i = 0; i <= bars; i++) {
           float left = s + (i * angle_offset) - angle_offset_t;
           float right = s + (i * angle_offset) + angle_offset_t;
@@ -1869,7 +1860,7 @@
       }
       window->DrawList->PathStroke(bg, false, thickness);
 
-      auto draw_gradient = [&] (auto b, auto e, auto c) {
+      auto draw_gradient = [&] (grad_f b, grad_f e, grad_f c) {
         for (size_t i = 0; i < num_segments; i++)
         {
           window->DrawList->AddLine(ImVec2(centre.x + ImCos(start + b(i)) * radius, centre.y + ImSin(start + b(i)) * radius),
@@ -1879,13 +1870,13 @@
         }
       };
 
-      draw_gradient([&] (auto i) { return (i) * angle_offset; },
-                    [&] (auto i) { return (i + 1) * angle_offset; },
-                    [&] (auto i) { ImColor rc = color; rc.Value.w = (i / (float)num_segments); return rc; });
-
-      draw_gradient([&] (auto i) { return (num_segments + i) * angle_offset; },
-                    [&] (auto i) { return (num_segments + i + 1) * angle_offset; },
-                    [&] (auto i) { ImColor rc = color; rc.Value.w = 1.f - (i / (float)num_segments); return rc; });
+      draw_gradient([&] (int i) { return (i) * angle_offset; },
+                    [&] (int i) { return (i + 1) * angle_offset; },
+                    [&] (int i) { ImColor rc = color; rc.Value.w = (i / (float)num_segments); return rc; });
+
+      draw_gradient([&] (int i) { return (num_segments + i) * angle_offset; },
+                    [&] (int i) { return (num_segments + i + 1) * angle_offset; },
+                    [&] (int i) { ImColor rc = color; rc.Value.w = 1.f - (i / (float)num_segments); return rc; });
     }
 
     inline void SpinnerRotateSegments(const char *label, float radius, float thickness, const ImColor &color = 0xffffffff, float speed = 2.8f, size_t arcs = 4, size_t layers = 1)
@@ -1925,7 +1916,7 @@
       const float step = angle / num_segments;
       const float th = thickness / num_segments;
 
-      auto get_coord = [&](float const& a, float const& t) -> auto {
+      auto get_coord = [&](float const& a, float const& t) -> std::pair<float, float> {
           return std::make_pair((a * ImCos(t)) / (1 + (powf(ImSin(t), 2.0f))), (a * ImSin(t) * ImCos(t)) / (1 + (powf(ImSin(t), 2.0f))));
       };
 
@@ -2549,7 +2540,7 @@
       const float angle_offset_t = angle_offset * 0.3f;
       arcs = ImMin<size_t>(arcs, 32);
 
-      auto get_points = [&] (auto left, auto right, auto r) -> std::array<ImVec2, 4> {
+      auto get_points = [&] (float left, float right, float r) -> std::array<ImVec2, 4> {
         const float rmin = r - thickness;
         return {
           ImVec2(centre.x + ImCos(left) * rmin, centre.y + ImSin(left) * rmin),
@@ -2559,7 +2550,7 @@
         };
       };
 
-      auto draw_sectors = [&] (auto s, auto color_func, auto r) {
+      auto draw_sectors = [&] (float s, color_f color_func, float r) {
         for (size_t i = 0; i <= arcs; i++) {
           float left = s + (i * angle_offset) - angle_offset_t;
           float right = s + (i * angle_offset) + angle_offset_t;
@@ -2570,9 +2561,9 @@
 
       float out_h, out_s, out_v;
       ImGui::ColorConvertRGBtoHSV(color.Value.x, color.Value.y, color.Value.z, out_h, out_s, out_v);
-      draw_sectors(start, [&] (auto i) { return ImColor::HSV(out_h + i * 0.31f, out_s, out_v); }, radius);
+      draw_sectors(start, [&] (int i) { return ImColor::HSV(out_h + i * 0.31f, out_s, out_v); }, radius);
       switch (mode) {
-      case 0: draw_sectors(-start * 0.78f, [&] (auto i) { return ImColor::HSV(out_h + i * 0.31f, out_s, out_v); }, radius - thickness - 2); break;
+      case 0: draw_sectors(-start * 0.78f, [&] (int i) { return ImColor::HSV(out_h + i * 0.31f, out_s, out_v); }, radius - thickness - 2); break;
       case 1:
         {
           ImColor c = color;
@@ -2646,7 +2637,7 @@
         bars = ImMin<size_t>(bars, 32);
 
         const float rmin = radius - thickness;
-        auto get_points = [&] (auto left, auto right, auto r1, auto r2) -> std::array<ImVec2, 4> {
+        auto get_points = [&] (float left, float right, float r1, float r2) -> std::array<ImVec2, 4> {
             return {
                 ImVec2(centre.x + ImCos(left) * r1, centre.y + ImSin(left) * r1),
                 ImVec2(centre.x + ImCos(left) * r2, centre.y + ImSin(left) * r2),
@@ -2841,7 +2832,7 @@
 
     inline void Spinner(const char *label, const detail::SpinnerConfig& config)
     {
-      if (config.m_SpinnerType < sizeof(detail::spinner_draw_funcs))
+      if (config.m_SpinnerType < e_st_count)
         detail::spinner_draw_funcs[config.m_SpinnerType].func(label, config);
     }
 
@@ -3215,4 +3206,5 @@
 #endif // IMSPINNER_DEMO
 }
 
-#endif // _IMSPINNER_H_
\ No newline at end of file
+#endif // _IMSPINNER_H_
+/* clang-format on */
