#!/usr/bin/env python
import os
import re
import version
import platform
import binascii

Import("env")
Import("env_modules")

is_gcc = "gcc" in os.path.basename(env["CC"])
is_clang_or_gcc = (
    ("gcc" in os.path.basename(env["CC"])) or ("clang" in os.path.basename(env["CC"])) or ("osxcross" in env)
)


def is_enabled(m):
    mod = os.path.dirname(m) if os.path.dirname(m) else m
    if "enable_gdextensions_submodules" in env:
        if "none" in env["enable_gdextensions_submodules"]:
            return False
        if mod in env["enable_gdextensions_submodules"]:
            return True
        # check for group name only
        el = [x for x in env["enable_gdextensions_submodules"] if x.startswith(m)]
        return len(el) > 0
    return True


def secret(path):
    with open(path, "r") as infile:
        return infile.read(8) == "U2FsdGVk"
    return False


# https://github.com/godotengine/godot/issues/23687
# https://github.com/godotengine/godot/issues/20045
def add_external_libs(env, libs):
    if env.msvc:
        env.Append(LINKFLAGS=[p + ".lib" for p in libs])
    else:
        env.Append(LIBS=libs)


def finalize_for_incbin(filepaths, prefix="", style="snake"):
    styled = {"camel": ["Data", "End", "Size"], "snake": ["_data", "_end", "_size"]}
    (kData, kEnd, kSize) = (0, 1, 2)
    if style != "snake" and style != "camel":
        print("(GDExtensions) incbin unknown style '%s'. Default to 'snake'" % style)
        style = "snake"
    if isinstance(filepaths, list):
        files = filepaths
    else:
        files = [filepaths]
    incbin_code = """
        /* File automatically generated by incbin wrapper for msvc */

        /* clang-format off */
        #include "misc/incbin.h"
        #ifdef __cplusplus
        extern "C" {
        #endif
    """
    processed = []
    for input in files:
        if hasattr(input, "path"):
            input = input.path
        root = "modules" + os.sep + os.path.basename(os.getcwd()) + os.sep
        if input.startswith(root):
            input = input[len(root) :]
        with open(input, "rb") as f:
            content = f.read()

        incbin_index = 0
        while 1:
            try:
                incbin_index = content.index("INCBIN", incbin_index)
                beg_index = content.index("(", incbin_index)
                sep_index = content.index(",", beg_index)
                end_index = content.index(")", sep_index)
                incbin_index = end_index + 1
            except ValueError:
                # no INCBIN directive found - break loop
                # and go to next file
                break

            incbin_name = content[beg_index + 1 : sep_index].strip()
            incbin_file = content[sep_index + 1 : end_index - 1].strip(' \t"')

            processed += [incbin_file]

            with open(incbin_file, "rb") as f:
                binary = f.read()
            n_bytes = len(binary)
            # python2 compatible
            chars = binascii.hexlify(binary)
            chars = [chars[i : i + 2] for i in range(0, len(chars), 2)]
            chars = "0x" + ",0x".join(chars)

            code = """
                /* INCBIN({name}, {file}); */
                INCBIN_CONST INCBIN_ALIGN unsigned char {prefix}{name}{kData}[] = {{chars},0x00};
                INCBIN_CONST INCBIN_ALIGN unsigned char *const {prefix}{name}{kEnd} = {prefix}{name}{kData} + {n_bytes};
                INCBIN_CONST unsigned int {prefix}{name}{kSize} = {n_bytes};

            """
            incbin_code += (
                code.replace("{chars}", chars)
                .replace("{n_bytes}", str(n_bytes))
                .replace("{prefix}", prefix)
                .replace("{name}", incbin_name)
                .replace("{file}", incbin_file)
                .replace("{kData}", styled[style][kData])
                .replace("{kEnd}", styled[style][kEnd])
                .replace("{kSize}", styled[style][kSize])
            )

    incbin_code += """
        #ifdef __cplusplus
        }
        #endif

        /* clang-format on */
    """

    print("(GDExtensions) incbin processed for %d resources" % len(processed))
    return incbin_code if len(processed) else ""


def snake_case(name):
    s1 = re.sub("(.)([A-Z][a-z]+)", r"\1_\2", name)
    return re.sub("([a-z0-9])([A-Z])", r"\1_\2", s1).lower()


def create_v_template(submodule, class_file):
    print("(GDExtensions) create V template for module: %s" % submodule)
    class_file_name = os.path.splitext(class_file)[0]
    # read class description
    in_v_file = os.path.join("submodules", submodule, class_file)
    if not os.path.exists(in_v_file):
        print("(GDExtensions) missing V module file")
        return []
    with open(in_v_file) as f:
        lines = [line[2:].strip() for line in f if line.startswith("//")]
    found_info = False
    descr = {"properties": [], "methods": []}
    for line in lines:
        if found_info:
            if "END}}" in line:
                break
            if "- property:" in line:
                _, property_descr = line.split(":")
                descr["properties"] += [property_descr]
                continue
            if "- method:" in line:
                _, method_descr = line.split(":")
                descr["methods"] += [method_descr]
                continue
            if ":" in line:
                class_name, base_class = line.split(":")
                descr["class_name"] = class_name
                if snake_case(class_name) == class_name:
                    print("%s should be %s" % (snake_case(class_name), class_name))
                    sys.exit(1)
                descr["base_class"] = base_class
            else:
                descr["class_name"] = line
                descr["base_class"] = "Reference"
        if "{{INFO" in line:
            found_info = True
    files = [class_file + ".cpp"]
    template_h = ""
    template_h += "#ifndef GODOT_CLASS_%s_H\n" % descr["class_name"].upper()
    template_h += "#define GODOT_CLASS_%s_H\n" % descr["class_name"].upper()
    template_h += "\n"
    template_h += "class %s : public %s {\n" % (descr["class_name"], descr["base_class"])
    template_h += "   GDCLASS(%s, %s)\n" % (descr["class_name"], descr["base_class"])
    template_h += "\n"
    template_h += "protected:\n"
    template_h += "   static void _bind_methods();\n"
    template_h += "   void _notifcation(int p_what);\n"
    template_h += "\n"
    template_h += "public:\n"
    for m in descr["methods"]:
        template_h += "   int %s;\n" % (m)
    template_h += "\n"
    for p in descr["properties"]:
        template_h += "   void set_%s(int p_num);\n" % (p)
        template_h += "   int get_%s(int p_num) const;\n" % (p)
    template_h += "\n"
    template_h += "   %s();\n" % descr["class_name"]
    template_h += "   ~%s()\n" % descr["class_name"]
    template_h += "};\n"
    template_h += "#endif // %s\n" % descr["class_name"].upper()
    template_cpp = ""
    template_cpp = 'extern "C" %s_init(void *p_self);\n' % class_file_name
    template_cpp += "\n"
    template_cpp += "void %s::_bind_methods() { %s_bind_methods(); }\n" % (descr["class_name"], class_file_name)
    template_cpp += "void %s::_notifcation(int p_what) { %s_notification(this, p_what); }\n" % (
        descr["class_name"],
        class_file_name,
    )
    template_cpp += "\n"
    for m in descr["methods"]:
        template_cpp += "int %s::%s { }\n" % (descr["class_name"], m)
    template_cpp += "\n"
    for p in descr["properties"]:
        template_cpp += "void %s::set_%s(int p_num) { }\n" % (descr["class_name"], p)
        template_cpp += "int %s::get_%s(int p_num) const { }\n" % (descr["class_name"], p)
    template_cpp += "\n"
    template_cpp += "%s::%s() { v_simple_class_init(this); }\n" % (descr["class_name"], descr["class_name"])
    template_cpp += "~%s::%s() { v_simple_class_finalize(this); }\n" % (descr["class_name"], descr["class_name"])
    with open(os.path.join("submodules", submodule, "godot_" + class_file_name + ".cpp"), "w") as f:
        f.write(template_cpp)
    with open(os.path.join("submodules", submodule, "godot_" + class_file_name + ".h"), "w") as f:
        f.write(template_h)
    return files


env_module = env_modules.Clone()

sources = Glob("*.cpp") + Glob("common/*.cpp")  # Always build common

modules = [
    "core",
    "visual",
    "cpufeatures",
    "threadpool",
    "bulletkit",
    "blitter",
    "benchmark",
    "environment/tree_2d",
    "environment/spherical_waves",
    "environment/water_splash",
    "environment/starfield",
    "environment/spider_anim",
    "environment/waterfall",
    "environment/water_2d",
    "environment/proc_rocks",
    "fastnoise",
    "smooth",
    "debugdraw",
    "cyberelements",
    "geomfonts",
    "ropesim",
    "statemachine",
    "benet",
    "httpserver",
    "behaviornode",
    "behaviortree",
    "daedalus",
    "simpleai",
    "flexbuffers",
    "nakama1",
    "parseplatform",
    "discord",
    "silentwolf",
    "settings",
    "sfxr",
    "flashdb",
    "sqlite",
    "vgamepad",
    "landiscovery",
    "polyvector",
    "vaserenderer",
    "lsystem",
    "timelinefx",
    "ldrdraw",
    "opensteer",
    "tileengine",
    "sparkparticles",
    "turbobadger",
    "spinners",
    "media/ffmpeg",
    "media/flac",
    "media/gifexporter",
    "media/smackvideo",
    "media/bmfimporter",
    "hwinfo",
    "synthbenchmark",
    "runtimeprofiler",
    "textui",
    "textwidgets",
]

thirdparty_sources = [
    "thirdparty/misc/cqueue.cpp",
    "thirdparty/misc/pugixml.cpp",
    "thirdparty/misc/miniz_gzip.c",
    "thirdparty/misc/miniz_zip.c",
]

print(create_v_template("vnativemodule", "v_simple_class.v"))

if env["tools"]:
    if is_enabled("editor"):
        thirdparty_sources += [
            "thirdparty/mypaint/libmypaint.c",
            "thirdparty/mypaint/json-c/libjson-c.c",
            "thirdparty/gc-8.2.2/extra/gc.c",
        ]
        env_module.Append(CPPPATH=["thirdparty/gc-8.2.2/include"])
        modules += ["editor"]
    if is_enabled("qrcodetexture"):
        modules += ["qrcodetexture"]
    if is_enabled("texturepacker"):
        modules += ["texturepacker"]
    if is_enabled("goxel"):
        modules += ["goxel"]
    if is_enabled("spacemouse"):
        if env["platform"] == "windows":
            thirdparty_sources += Glob("thirdparty/hidapi/windows/*.c")
        elif env["platform"] == "x11":
            thirdparty_sources += Glob("thirdparty/hidapi/linux/*.c")
        elif env["platform"] == "osx":
            thirdparty_sources += Glob("thirdparty/hidapi/mac/*.c")
        else:
            print("(GDextensions) Spacemouse is not supported on platform '%s'." % env["platform"])
            env["enable_gdextensions_submodules"].remove("spacemouse")
        if is_enabled("spacemouse"):
            env_module.Append(CPPPATH=["thirdparty/hidapi", "thirdparty/hidapi/hidapi"])
            modules += ["spacemouse"]
    if is_enabled("scenemerge"):
        modules += ["scenemerge"]
        env_module.Prepend(CPPPATH=["thirdparty/mesh_optimizer"])
        env_module.add_source_files(env.modules_sources, Glob("thirdparty/meshoptimizer/src/*.cpp"))
    if is_enabled("yaml"):
        modules += ["yaml"]
        thirdparty_sources += Glob("thirdparty/yaml-cpp/src/*.cpp")
        env_module.Append(CPPDEFINES=["YAML_CPP_STATIC_DEFINE"])
        env_module.Prepend(CPPPATH=["thirdparty/yaml-cpp/include"])

if is_enabled("textui"):
    thirdparty_sources += ["thirdparty/textui/textUI.c", "thirdparty/textui/textUI_support.cpp"]

if is_enabled("cyberelements"):
    thirdparty_sources += ["thirdparty/libtess3/libtess3.cpp"]

if is_enabled("fastnoise"):
    thirdparty_sources += ["thirdparty/fastnoise/FastNoise.cpp"]

if is_enabled("hwinfo"):
    if env["platform"] in ["x11", "server", "frt"]:
        thirdparty_sources += (
            Glob("thirdparty/hwinfo/src/*.cpp")
            + Glob("thirdparty/hwinfo/src/platform_linux/*.cpp")
            + Glob("thirdparty/hwinfo/src/platform_linux/utils/*.cpp")
        )
    elif env["platform"] == "osx":
        thirdparty_sources += (
            Glob("thirdparty/hwinfo/src/*.cpp")
            + Glob("thirdparty/hwinfo/src/platform_apple/*.cpp")
            + Glob("thirdparty/hwinfo/src/platform_apple/*.m")
        )
    elif env["platform"] == "iphone":
        thirdparty_sources += (
            Glob("thirdparty/hwinfo/src/*.cpp")
            + Glob("thirdparty/hwinfo/src/platform_apple/*.cpp")
            + ["thirdparty/hwinfo/src/platform_apple/utils/apple_info_ios.m"]
        )
    else:
        arch = env["arch"] if "arch" in env and env["arch"] else platform.machine()
        print("(GDextensions) HWInfo is not supported on platform '%s/%s'." % (env["platform"], arch))
        modules.remove("hwinfo")
    if is_enabled("hwinfo"):
        env_module.Append(
            CPPPATH=[
                "thirdparty/hwinfo/include",
                "thirdparty/opencl-wrapper/src/",
                "thirdparty/opencl-wrapper/src/OpenCL/include",
            ]
        )
        env.Append(LIBPATH=[os.path.realpath(os.curdir) + "/thirdparty/opencl-wrapper/src/OpenCL/lib"])
        if env["platform"] == "osx":
            env.Append(LINKFLAGS=["-framework", "OpenCL"])
        else:
            add_external_libs(env, ["opencl"])

if is_enabled("cpufeatures"):
    env_module.Append(CPPPATH=["thirdparty/cpu_features/include"])
    thirdparty_sources += [fn for fn in Glob("thirdparty/cpu_features/*.c") if os.path.basename(fn.path) != "hwcaps.c"]
    if env["platform"] == "x11":
        thirdparty_sources += ["thirdparty/cpu_features/hwcaps.c"]

if is_enabled("breakpad"):
    arch = env["arch"] if "arch" in env and env["arch"] else platform.machine()
    if arch == "x64":
        arch = "x86_64"
    elif arch == "mips":
        arch = "mips32"
    if env["platform"] == "x11" and arch in ["aarch64", "x86_64"]:
        env_module.Append(CPPPATH=["thirdparty/breakpad_client/linux/include"])
        env.Append(LIBPATH=[os.path.realpath(os.curdir) + "/thirdparty/breakpad_client/linux/%s" % arch])
        add_external_libs(env, ["breakpad_client"])
    else:
        print("(GDextensions) Breakpad crash reporter is not supported on platform '%s/%s'." % (env["platform"], arch))
        env["enable_gdextensions_submodules"].remove("breakpad")

if env["platform"] == "iphone" or env["platform"] == "osx":
    modules += ["multipeer"]
    thirdparty_sources += Glob("thirdparty/MultiPeerKit/Sources/Common/*.m")
    env_module.Append(
        CCFLAGS=[
            "-fobjc-arc",
            "-fmessage-length=0",
            "-fno-strict-aliasing",
            "-fdiagnostics-print-source-range-info",
            "-fdiagnostics-show-category=id",
            "-fdiagnostics-parseable-fixits",
            "-fpascal-strings",
            "-fblocks",
            "-MMD",
            "-MT",
            "dependencies",
            "-Wno-ambiguous-macro",
            "-Werror=return-type",
            "-Wall",
        ]
    )

if not env["disable_3d"]:
    modules += ["ccd", "detournav"]
    if is_enabled("ccd"):
        thirdparty_sources += Glob("thirdparty/libccd/src/*.c") + Glob("thirdparty/libccd/src/testsuites/*.c")
    if is_enabled("detournav"):
        env_module.Append(
            CPPPATH=[
                "#thirdparty/recastnavigation/DebugUtils/Include",
                "#thirdparty/recastnavigation/Detour/Include",
                "#thirdparty/recastnavigation/DetourCrowd/Include",
                "#thirdparty/recastnavigation/DetourTileCache/Include",
                "#thirdparty/recastnavigation/Recast/Include",
            ]
        )
        sources += Glob("submodules/detournav/src/util/*.cpp") + Glob("submodules/detournav/src/util/*.c")
        thirdparty_sources += (
            Glob("thirparty/recastnavigation/DebugUtils/Source/*.cpp")
            + Glob("thirdparty/recastnavigation/Detour/Source/*.cpp")
            + Glob("thirdparty/recastnavigation/DetourCrowd/Source/*.cpp")
            + Glob("thirdparty/recastnavigation/DetourTileCache/Source/*.cpp")
            + Glob("thirdparty/recastnavigation/Recast/Source/*.cpp")
        )
    if env["tools"]:
        if is_enabled("generator"):
            modules += ["generator"]
            env_module.Append(CPPPATH=["thirdparty/libgenerator/inc"])
            if is_gcc:
                env_module.Append(CPPFLAGS=["-Wno-nonnull", "-Wno-array-bounds"])  # silent false warnings
            thirdparty_sources += Glob("thirdparty/libgenerator/src/*.cpp")
        if is_enabled("meshlod"):
            modules += ["meshlod"]
            thirdparty_sources += Glob("thirdparty/meshoptimizer/src/*.cpp")
        if is_enabled("meshslicer"):
            modules += ["meshslicer"]
            sources += Glob("submodules/meshslicer/utils/*.cpp")

if is_enabled("ldrdraw"):
    env_module.Append(CPPPATH=["thirdparty/libldr"])
    sources += Glob("thirdparty/libldr/*.c") + Glob("thirdparty/libldr/*.cpp") + Glob("thirdparty/libldr/*.c")
if env["os_family"] in ["os_windows", "os_unix"]:
    modules += ["unqlite"]
    thirdparty_sources += Glob("thirdparty/unqlite/*.c")

if is_enabled("sqlite"):
    thirdparty_sources += Glob("thirdparty/sqlite/*.c")

if os.path.isdir("submodules/iap") and is_enabled("iap"):
    if secret("submodules/iap/gd_iap.cpp") and secret("submodules/iap/gd_iap.h"):
        print("(GDextensions) IAP is not available")
        env["enable_gdextensions_submodules"].remove("iap")
    else:
        env_module.Prepend(CPPPATH=["submodules/iap"])
        sources += Glob("submodules/iap/*.cpp")
        if env["platform"] == "osx" or env["platform"] == "iphone":
            sources += Glob("submodules/iap/mac/*.mm")
            env.Append(LINKFLAGS=["-framework", "StoreKit"])
        elif env["platform"] == "android":
            sources += Glob("iap/android/*.cpp")
        elif env["platform"] == "uwp":
            sources += Glob("iap/uwp/*.cpp")
        else:
            print("(GDextensions) IAP is not available on platform '%s'." % env["platform"])
            env["enable_gdextensions_submodules"].remove("iap")

if is_enabled("playfab"):
    modules += ["playfab"]
    env_module.Append(
        CPPPATH=[
            "thirdparty/xplatcppsdk/code/include",
            "thirdparty/xplatcppsdk/code",
            "thirdparty/xplatcppsdk/external/jsoncpp/include",
        ]
    )
    env_module.Append(CPPDEFINES=["PLAYFAB_PLATFORM_GODOT"])
    sources += Glob("submodules/playfab/PlayFabSDK/*.cpp")
    thirdparty_sources += Glob("thirdparty/xplatcppsdk/code/source/playfab/*.cpp")

if env["platform"] == "psvita" and is_enabled("blitter"):
    sources += Glob("submodules/blitter/armasm/*.S")

if is_enabled("behaviortree"):
    env_module.Append(CPPDEFINES=["BEHAVIOR_TREE_AS_GODOT_MODULE"])

if is_enabled("daedalus"):
    env_module.Append(CPPPATH=["submodules/daedalus/DDLS"])

if is_enabled("environment/waterfall"):
    if env["tools"]:
        env_module.Append(CPPDEFINES=["HAVE_PARTICLES_SIZE_S", "HAVE_PARTICLES_SIZE_M", "HAVE_PARTICLES_SIZE_L"])

if is_enabled("environment/spider_anim"):
    if secret("submodules/environment/spider_anim/spider.cpp"):
        print("(GDextensions) Spider animation is not available")
        modules.remove("environment/spider_anim")

if not env["disable_3d"]:
    modules += ["environment/vegetation_instance", "environment/proc_rocks"]
    if is_enabled("environment/proc_rocks"):
        thirdparty_sources += [
            "submodules/environment/proc_rocks/generators/rockgeneration/gen_rock.cpp",
            "submodules/environment/proc_rocks/generators/rockgen/rockgen.cpp",
        ]
        env_module.Prepend(CPPPATH=["submodules/environment/proc_rocks/generators"])
        if env["tools"]:
            # it is big - keep it for editor usge only
            thirdparty_sources += ["thirdparty/libnoise/libnoise.cpp", "thirdparty/procrocklib/procrocklib.cpp"]
            env_module.Prepend(
                CPPPATH=[
                    "thirdparty/eigenmath",
                    "thirdparty/libnoise",
                    "thirdparty/procrocklib/inc",
                    "thirdparty/procrocklib/src",
                    "thirdparty/procrocklib/ext",
                ]
            )

ignore = []
if env["platform"] == "3ds" or env["platform"] == "psp":
    ignore += ["submodules/visual/heatmap.cpp"]
if env["disable_advanced_gui"]:
    ignore += ["submodules/core/input_map_editor.cpp"]
if not env["module_mbedtls_enabled"]:
    ignore += ["submodules/core/cripter.cpp"]

if is_enabled("flexbuffers") or is_enabled("nakama1"):
    env_module.Prepend(CPPPATH="thirdparty/flatbuffers/include")
    if is_enabled("flexbuffers"):
        if env["platform"] == "frt" and env["frt_arch"] == "gcw0":
            env_module.Append(CPPDEFINES=["FLATBUFFERS_LOCALE_INDEPENDENT=0"])
        thirdparty_sources += ["thirdparty/flatbuffers/src/util.cpp"]
    if is_enabled("nakama1"):
        sources += Glob("submodules/nakama1/client/*.cpp")

if is_enabled("geomfonts"):
    env_module.Prepend(CPPPATH="submodules/geomfonts/polyfonts")
    sources += Glob("submodules/geomfonts/polyfonts/fonts/*.c")

if is_enabled("polyvector"):
    env_module.Append(CPPPATH=["thirdparty/libshockwave/lzma"])
    env_module.Append(CPPDEFINES=["_7ZIP_ST"])
    thirdparty_sources += Glob("thirdparty/libshockwave/*.cpp") + Glob("thirdparty/libshockwave/lzma/*.c")

if is_enabled("thorvg"):
    if env["tools"]:
        thirdparty_dir = "#thirdparty/thorvg/"
        thirdparty_sources = [
            "src/lib/sw_engine/tvgSwFill.cpp",
            "src/lib/sw_engine/tvgSwImage.cpp",
            "src/lib/sw_engine/tvgSwMath.cpp",
            "src/lib/sw_engine/tvgSwMemPool.cpp",
            "src/lib/sw_engine/tvgSwRaster.cpp",
            "src/lib/sw_engine/tvgSwRenderer.cpp",
            "src/lib/sw_engine/tvgSwRle.cpp",
            "src/lib/sw_engine/tvgSwShape.cpp",
            "src/lib/sw_engine/tvgSwStroke.cpp",
            "src/lib/tvgAccessor.cpp",
            "src/lib/tvgBezier.cpp",
            "src/lib/tvgCanvas.cpp",
            "src/lib/tvgFill.cpp",
            "src/lib/tvgGlCanvas.cpp",
            "src/lib/tvgInitializer.cpp",
            "src/lib/tvgLinearGradient.cpp",
            "src/lib/tvgLoader.cpp",
            "src/lib/tvgLzw.cpp",
            "src/lib/tvgPaint.cpp",
            "src/lib/tvgPicture.cpp",
            "src/lib/tvgRadialGradient.cpp",
            "src/lib/tvgRender.cpp",
            "src/lib/tvgSaver.cpp",
            "src/lib/tvgScene.cpp",
            "src/lib/tvgShape.cpp",
            "src/lib/tvgSwCanvas.cpp",
            "src/lib/tvgTaskScheduler.cpp",
            "src/loaders/external_png/tvgPngLoader.cpp",
            "src/loaders/jpg/tvgJpgd.cpp",
            "src/loaders/jpg/tvgJpgLoader.cpp",
            "src/loaders/raw/tvgRawLoader.cpp",
            "src/loaders/svg/tvgSvgCssStyle.cpp",
            "src/loaders/svg/tvgSvgLoader.cpp",
            "src/loaders/svg/tvgSvgPath.cpp",
            "src/loaders/svg/tvgSvgSceneBuilder.cpp",
            "src/loaders/svg/tvgSvgUtil.cpp",
            "src/loaders/svg/tvgXmlParser.cpp",
            "src/loaders/tvg/tvgTvgBinInterpreter.cpp",
            "src/loaders/tvg/tvgTvgLoader.cpp",
            "src/savers/tvg/tvgTvgSaver.cpp",
        ]

        thirdparty_sources += [thirdparty_dir + file for file in thirdparty_sources]
        env_module.Prepend(CPPPATH=[thirdparty_dir + "inc"])
        env_module.Prepend(
            CPPPATH=[
                thirdparty_dir + "src/lib",
                thirdparty_dir + "src/lib/sw_engine",
                thirdparty_dir + "src/loaders/external_png",
                thirdparty_dir + "src/loaders/jpg",
                thirdparty_dir + "src/loaders/raw",
                thirdparty_dir + "src/loaders/svg",
                thirdparty_dir + "src/loaders/tvg",
                thirdparty_dir + "src/savers/tvg",
            ]
        )
        if env["builtin_libpng"]:
            env_module.Prepend(CPPPATH=["#thirdparty/libpng"])  # Also requires libpng headers

if is_enabled("lsystem"):
    env_module.Append(CPPPATH=["submodules/lsystem"])

if is_enabled("timelinefx"):
    sources += Glob("submodules/timelinefx/runtime/*.cpp")

if is_enabled("tileengine"):
    env_module.Append(CPPDEFINES=["TLN_EXCLUDE_WINDOW", "TLN_STATIC_BUILD"])
    env_module.Append(CPPPATH=["thirdparty/Tilengine/include"])
    thirdparty_sources += Glob("thirdparty/Tilengine/src/*.c")

if is_enabled("opensteer"):
    thirdparty_sources += (
        Glob("thirdparty/opensteer/src/*.c")
        + Glob("thirdparty/opensteer/src/*.cpp")
        + Glob("thirdparty/opensteer/plugins/*.cpp")
    )
    env_module.Append(CPPPATH=["thirdparty/opensteer/include"])

if is_enabled("sparkparticles"):
    thirdparty_sources += Glob("thirdparty/spark/src/**/*.cpp")
    if env["tools"]:
        thirdparty_sources += Glob("thirdparty/spark/demo/*.c")
    env_module.Append(CPPPATH=["thirdparty/spark/include", "thirdparty/spark/include/SPK", "thirdparty/spark/src"])

if is_enabled("flashdb"):
    thirdparty_sources += Glob("thirdparty/flashdb/src/*.c")

if is_enabled("turbobadger"):
    env_module.Append(CPPPATH=["thirdparty/turbobadger/src"])
    if env["module_freetype_enabled"]:
        env_module.Append(CPPDEFINES=["TB_FONT_RENDERER_FREETYPE"])
    else:
        env_module.Append(CPPDEFINES=["TB_FONT_RENDERER_STB"])
    thirdparty_sources += Glob("thirdparty/turbobadger/src/**/*.cpp") + Glob("thirdparty/turbobadger/resources/*.c")

if is_enabled("vgamepad"):
    sources += Glob("submodules/vgamepad/res/*.c")

if is_enabled("openclwrapper"):
    if env["tools"]:
        if env["platform"] == "windows" or env["platform"] == "x11" or env["platform"] == "osx":
            thirdparty_sources += Glob("thirdparty/opencl-wrapper/src/kernel.cpp")
            env_module.Append(
                CPPPATH=["thirdparty/opencl-wrapper/src/", "thirdparty/opencl-wrapper/src/OpenCL/include"]
            )
            env.Append(LIBPATH=[os.path.realpath(os.curdir) + "/thirdparty/opencl-wrapper/src/OpenCL/lib"])
            if env["platform"] == "osx":
                env.Append(LINKFLAGS=["-framework", "OpenCL"])
            else:
                add_external_libs(env, ["opencl"])
            modules += ["openclwrapper"]
        else:
            print("(GDextensions) OpenCLWrapper is not supported on platform '%s'." % env["platform"])
            env["enable_gdextensions_submodules"].remove("openclwrapper")

if is_enabled("slugfont"):
    if secret("submodules/slugfont/ts_slug.cpp") and secret("submodules/slugfont/ts_slug.h"):
        print("(GDextensions) SlugFont is not available")
        env["enable_gdextensions_submodules"].remove("slugfont")
    else:
        env_module.Append(CPPPATH=["thirdparty/slugfont"])
        if is_gcc:
            env_module.Append(CPPFLAGS=["-Wno-multichar", "-Wno-array-bounds"])

if is_enabled("media/"):
    env_module.Append(CPPPATH=["thirdparty/media"])
    if is_enabled("media/gifexporter"):
        thirdparty_sources += Glob("thirdparty/media/gifanimcplusplus/*.cpp")
    if is_enabled("media/smackvideo"):
        env_module.Append(CPPPATH=[os.path.dirname(os.path.realpath(os.curdir)) + "/gdnative/include"])
        thirdparty_sources += Glob("thirdparty/media/libsmacker/*.c")
    if is_enabled("media/ffmpeg"):
        arch = (env["arch"] if "arch" in env and env["arch"] else platform.machine()).lower()
        if arch == "x64" or arch == "amd64":
            arch = "x86_64"
        elif arch == "mips":
            arch = "mips32"
        if env["platform"] == "windows":
            env_module.Append(CPPPATH=["thirdparty/media/ffmpeg/windows/%s/include" % arch])
            env.Append(LIBPATH=[os.path.realpath(os.curdir) + "/thirdparty/media/ffmpeg/windows/%s/lib" % arch])
        elif env["platform"] == "x11" or env["platform"] == "frt":
            env_module.Append(CPPPATH=["thirdparty/media/ffmpeg/linux/%s/include" % arch])
            env.Append(LIBPATH=[os.path.realpath(os.curdir) + "/thirdparty/media/ffmpeg/linux/%s/lib" % arch])
            env.Append(LIBS=["iconv"])
        elif env["platform"] == "android":
            env_module.Append(CPPPATH=["thirdparty/media/ffmpeg/android/%s/include" % arch])
            env.Append(LIBPATH=[os.path.realpath(os.curdir) + "/thirdparty/media/ffmpeg/android/%s/lib" % arch])
        elif env["platform"] == "iphone":
            env_module.Append(CPPPATH=["thirdparty/media/ffmpeg/ios/universal/include" % arch])
            env.Append(LIBPATH=[os.path.realpath(os.curdir) + "thirdparty/media/ffmpeg/ios/universal/lib" % arch])
        elif env["platform"] == "osx":
            env_module.Append(CPPPATH=["thirdparty/media/ffmpeg/macosx/universal/include"])
            env.Append(LIBPATH=[os.path.realpath(os.curdir) + "/thirdparty/media/ffmpeg/macosx/universal/lib"])
        elif env["platform"] == "psvita":
            env_module.Append(CPPPATH=["thirdparty/media/ffmpeg/vita/%s/include" % arch])
            env.Append(LIBPATH=[os.path.realpath(os.curdir) + "/thirdparty/media/ffmpeg/vita/%s/lib" % arch])
        else:
            print("(GDextensions) FFmpeg is not supported on platform '%s'." % env["platform"])
            modules.remove("media/ffmpeg")
        if is_enabled("media/ffmpeg") and "media/ffmpeg" in modules:
            env_module.Append(CPPPATH=[os.path.dirname(os.path.realpath(os.curdir)) + "/gdnative/include"])
            add_external_libs(env, ["avformat", "avcodec", "avutil", "swresample", "swscale"])

if is_enabled("tileengine"):
    if env["builtin_libpng"]:
        env_module.Append(CPPPATH=["#thirdparty/libpng/"])

active_modules = []
for m in modules:
    if is_enabled(m):
        files = Glob("submodules/%s/*.cpp" % m) + Glob("submodules/%s/*.c" % m)
        sources += [f for f in files if str(f) not in ignore]
        active_modules.append(m)

if env.msvc:
    incbin_code = finalize_for_incbin(sources)
    if incbin_code:
        with open("_incbin_msvc_data.c", "w") as f:
            f.write(incbin_code)
        sources += ["_incbin_msvc_data.c"]

env_module.Append(
    CPPPATH=[
        "#thirdparty/enet",
        "#thirdparty/mbedtls/include",
        "#thirdparty",
        "thirdparty/flashdb/inc",
        "thirdparty/libccd/src",
        "thirdparty",
        "submodules",
        ".",
    ]
)

if env["builtin_freetype"]:
    env_module.Prepend(CPPPATH=["#thirdparty/freetype/include"])
env_module.Append(CPPDEFINES=["GD_CQUEUE", "GD_GODOT_ENET"])

lib = env_module.Library("gdextensions", thirdparty_sources + sources)  # Compile as a static library
env.Prepend(LIBS=[lib])  # Add the library as a dependency of the final executable

if modules:
    sub_enabled = []
    for m in sorted(active_modules):
        mod = os.path.dirname(m) if os.path.dirname(m) else m
        if mod not in sub_enabled:
            if sub_enabled and sub_enabled[-1].startswith(mod):
                sub_enabled[-1] = sub_enabled[-1] + " " + os.path.basename(m)
            elif mod != m:
                sub_enabled.append(mod + ": " + os.path.basename(m))
            else:
                sub_enabled.append(m)
            if m == mod:
                env_module.Append(CPPDEFINES=["GDEXT_%s_ENABLED" % mod.upper()])
            else:
                env_module.Append(CPPDEFINES=["GDEXT_%s_ENABLED" % (m.replace("/", "_").upper())])
    print("(GDextensions) Building submodules: %s" % sorted(sub_enabled))
