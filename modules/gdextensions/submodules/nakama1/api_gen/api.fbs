// Generated from api.proto

namespace server.Error_;

/// Predefined errors that are produced by the server.
enum Code : int {
  /// An unexpected error that is unrecoverable.
  RUNTIME_EXCEPTION = 0,
  /// Server received a message that is not recognized.
  UNRECOGNIZED_PAYLOAD = 1,
  /// Server received an Envelop message but the internal message is unrecognised. Most likely a protocol mismatch.
  MISSING_PAYLOAD = 2,
  /// The message did not include the required data in the correct format.
  BAD_INPUT = 3,
  /// Authentication failure.
  AUTH_ERROR = 4,
  /// Login failed because ID/device/email did not exist.
  USER_NOT_FOUND = 5,
  /// Registration failed because ID/device/email exists.
  USER_REGISTER_INUSE = 6,
  /// Linking operation failed because link exists.
  USER_LINK_INUSE = 7,
  /// Linking operation failed because third-party service was unreachable.
  USER_LINK_PROVIDER_UNAVAILABLE = 8,
  /// Unlinking operation failed because you cannot unlink last ID.
  USER_UNLINK_DISALLOWED = 9,
  /// Handle is in-use by another user.
  USER_HANDLE_INUSE = 10,
  /// Group names must be unique and it's already in use.
  GROUP_NAME_INUSE = 11,
  /// Group leave operation not allowed because the user is the last admin.
  GROUP_LAST_ADMIN = 12,
  /// Storage write operation failed.
  STORAGE_REJECTED = 13,
  /// Match with given ID was not found in the system.
  MATCH_NOT_FOUND = 14,
  /// Runtime function name was not found in system registry.
  RUNTIME_FUNCTION_NOT_FOUND = 15,
  /// Runtime function caused an internal server error and did not complete.
  RUNTIME_FUNCTION_EXCEPTION = 16,
}

namespace server;

enum StoragePermissionRead : int {
  /// Storage owner does not have read access.
  NO_READ = 0,
  /// Only storage owner has read access.
  OWNER_READ = 1,
  /// Storage owner and every other user has read access.
  PUBLIC_READ = 2,
}

enum StoragePermissionWrite : int {
  /// Storage owner does not have write access.
  NO_WRITE = 0,
  /// Storage owner has write access.
  OWNER_WRITE = 1,
}

namespace server.TStorageUpdate_.StorageUpdate_.UpdateOp_;

enum UpdateOpCode : int {
  /// Add field or value to array at the path.
  ADD = 0,
  /// Append a value or array of values at the path.
  APPEND = 1,
  /// Copy value at the path to another path.
  COPY = 2,
  /// Add a positive/negative value to the value at the path.
  INCR = 3,
  /// Initialize the value at the path ONLY if itâ€™s not already present.
  INIT = 4,
  /// Perform a merge of the object at the path.
  MERGE = 5,
  /// Move a value from one path to another and remove from the original path.
  MOVE = 6,
  /// Perform a JSON patch with the sequence of operations on the subpath specified
  PATCH = 7,
  /// Remove the value or array at the path.
  REMOVE = 8,
  /// Replaces an existing value at the specified path.
  REPLACE = 9,
  /// Tests equality of the value at the path. The entire patch set fails if the test fails.
  TEST = 10,
  /// Performs a comparator which returns -1, 0, or 1 depending on whether the value is less than, the same, or greater than the value in the path.
  COMPARE = 11,
}

namespace server;

table Heartbeat {
  /// Server UTC timestamp in milliseconds.
  timestamp:long;
}

table Error {
  /// Error code - must be one of the Error.Code enums above.
  code:int;
  /// Specific error message.
  message:string;
}

table AuthenticateRequest {
  /// Optional collationID to track server response.
  collation_id:string;
  /// OneOf authentication methods.
  id:server.AuthenticateRequest_.Anonymous0;
}

namespace server.AuthenticateRequest_;

table Email {
  /// Email address.
  email:string;
  /// Password.
  password:string;
}

table GameCenter {
  /// PlayerID generated by GameCenter.
  player_id:string;
  /// BundleID generated by GameCenter.
  bundle_id:string;
  /// The date and time that the signature was created.
  timestamp:long;
  /// A random NSString used to compute the hash and keep it randomized.
  salt:string;
  /// The verification signature data generated.
  signature:string;
  /// The URL for the public encryption key.
  public_key_url:string;
}

table Anonymous0 {
  /// Email address and password.
  email:server.AuthenticateRequest_.Email;
  /// Facebook OAuth Access Token.
  facebook:string;
  /// Google OAuth Access Token.
  google:string;
  /// GameCenter Authentication.
  game_center:server.AuthenticateRequest_.GameCenter;
  /// Steam Token.
  steam:string;
  /// Device ID authentication.
  device:string;
  /// Custom ID authentication.
  custom:string;
}

namespace server;

table AuthenticateResponse {
  /// Optional collationID to track server response.
  collation_id:string;
  /// OneOf authentication response.
  id:server.AuthenticateResponse_.Anonymous1;
}

namespace server.AuthenticateResponse_;

table Session {
  /// Authentication Token.
  token:string;
  /// UDP token.
  udp_token:string;
}

table Error {
  /// Error code - this will be the same as the global error codes.
  code:int;
  /// Specific error message.
  message:string;
  /// Original request that caused this error.
  request:server.AuthenticateRequest;
}

table Anonymous1 {
  /// Authentication session.
  session:server.AuthenticateResponse_.Session;
  /// Authentication error.
  error:server.AuthenticateResponse_.Error;
}

namespace server;

table Envelope {
  /// Optional collationID to track server response.
  collation_id:string;
  /// OneOf envelope payload. This can be both for request and response purposes.
  payload:server.Envelope_.Anonymous2;
}

namespace server.Envelope_;

table Anonymous2 {
  error:server.Error;
  heartbeat:server.Heartbeat;
  logout:server.Logout;
  link:server.TLink;
  unlink:server.TUnlink;
  self_fetch:server.TSelfFetch;
  self_update:server.TSelfUpdate;
  users_fetch:server.TUsersFetch;
  self:server.TSelf;
  users:server.TUsers;
  friends_add:server.TFriendsAdd;
  friends_remove:server.TFriendsRemove;
  friends_block:server.TFriendsBlock;
  friends_list:server.TFriendsList;
  friends:server.TFriends;
  groups_create:server.TGroupsCreate;
  groups_update:server.TGroupsUpdate;
  groups_remove:server.TGroupsRemove;
  groups_fetch:server.TGroupsFetch;
  groups_list:server.TGroupsList;
  groups_self_list:server.TGroupsSelfList;
  group_users_list:server.TGroupUsersList;
  groups_join:server.TGroupsJoin;
  groups_leave:server.TGroupsLeave;
  group_users_add:server.TGroupUsersAdd;
  group_users_kick:server.TGroupUsersKick;
  group_users_promote:server.TGroupUsersPromote;
  groups:server.TGroups;
  groups_self:server.TGroupsSelf;
  group_users:server.TGroupUsers;
  topics_join:server.TTopicsJoin;
  topics_leave:server.TTopicsLeave;
  topic_message_send:server.TTopicMessageSend;
  topic_messages_list:server.TTopicMessagesList;
  topics:server.TTopics;
  topic_message_ack:server.TTopicMessageAck;
  topic_message:server.TopicMessage;
  topic_messages:server.TTopicMessages;
  topic_presence:server.TopicPresence;
  match_create:server.TMatchCreate;
  matches_join:server.TMatchesJoin;
  matches_leave:server.TMatchesLeave;
  match_data_send:server.MatchDataSend;
  match:server.TMatch;
  matches:server.TMatches;
  match_data:server.MatchData;
  match_presence:server.MatchPresence;
  storage_list:server.TStorageList;
  storage_fetch:server.TStorageFetch;
  storage_write:server.TStorageWrite;
  storage_update:server.TStorageUpdate;
  storage_remove:server.TStorageRemove;
  storage_data:server.TStorageData;
  storage_keys:server.TStorageKeys;
  leaderboards_list:server.TLeaderboardsList;
  leaderboard_records_write:server.TLeaderboardRecordsWrite;
  leaderboard_records_fetch:server.TLeaderboardRecordsFetch;
  leaderboard_records_list:server.TLeaderboardRecordsList;
  leaderboards:server.TLeaderboards;
  leaderboard_records:server.TLeaderboardRecords;
  matchmake_add:server.TMatchmakeAdd;
  matchmake_remove:server.TMatchmakeRemove;
  matchmake_ticket:server.TMatchmakeTicket;
  matchmake_matched:server.MatchmakeMatched;
  rpc:server.TRpc;
  purchase:server.TPurchaseValidation;
  purchase_record:server.TPurchaseRecord;
  notifications_list:server.TNotificationsList;
  notifications_remove:server.TNotificationsRemove;
  notifications:server.TNotifications;
  live_notifications:server.Notifications;
}

namespace server;

table Logout {
}

table TLink {
  /// OneOf linking methods.
  id:server.TLink_.Anonymous3;
}

namespace server.TLink_;

table Anonymous3 {
  /// Email address and password.
  email:server.AuthenticateRequest_.Email;
  /// Facebook OAuth Access Token.
  facebook:string;
  /// Google OAuth Access Token.
  google:string;
  /// GameCenter.
  game_center:server.AuthenticateRequest_.GameCenter;
  /// Steam Token.
  steam:string;
  /// Device ID.
  device:string;
  /// Custom ID.
  custom:string;
}

namespace server;

table TUnlink {
  /// OneOf unlinking methods.
  id:server.TUnlink_.Anonymous4;
}

namespace server.TUnlink_;

table Anonymous4 {
  /// Email address.
  email:string;
  /// Facebook ID.
  facebook:string;
  /// Google ID.
  google:string;
  /// GameCenter ID.
  game_center:string;
  /// Steam ID.
  steam:string;
  /// Device ID.
  device:string;
  /// Custom ID.
  custom:string;
}

namespace server;

table User {
  /// User ID.
  id:string;
  /// User Handle (username).
  handle:string;
  /// User's fullname.
  fullname:string;
  /// Link to avatar.
  avatar_url:string;
  /// Language tag corresponding to the BCP 47 spec.
  lang:string;
  /// User's location.
  location:string;
  /// User's timezone.
  timezone:string;
  /// Custom user metadata.
  metadata:string;
  /// Unix timestamp when this user registered.
  created_at:long;
  /// Unix timestamp when user profile was last changed.
  updated_at:long;
  /// Unix timestamp when user was last connected.
  last_online_at:long;
}

table Self {
  /// User's account.
  user:server.User;
  /// Whether the user was verified, either via email or social accounts.
  verified:bool;
  /// User's email address.
  email:string;
  /// List of device IDs the user has.
  device_ids:[string];
  /// User's Facebook ID.
  facebook_id:string;
  /// User's Google ID.
  google_id:string;
  /// User's Game Center ID.
  gamecenter_id:string;
  /// User's Steam ID.
  steam_id:string;
  /// Custom ID associated with the user.
  custom_id:string;
}

table TSelfFetch {
}

table TSelf {
  self:server.Self;
}

table TSelfUpdate {
  handle:string;
  fullname:string;
  timezone:string;
  location:string;
  /// Language tag corresponding to the BCP 47 spec
  lang:string;
  /// Set or remove User's metadata
  metadata:string;
  avatar_url:string;
}

table TUsersFetch {
  /// Must at least contain one item.
  users:[server.TUsersFetch_.UsersFetch];
}

namespace server.TUsersFetch_;

table UsersFetch {
  id:server.TUsersFetch_.UsersFetch_.Anonymous5;
}

namespace server.TUsersFetch_.UsersFetch_;

table Anonymous5 {
  user_id:string;
  handle:string;
}

namespace server;

table TUsers {
  users:[server.User];
}

table Friend {
  /// The user that is the friend of the currently connected user.
  user:server.User;
  /// The type of relationship this is. The value can be one of the following:
  /// Friend(0): Mutual friendship.
  /// Invite(1): Current user has sent an invitation.
  /// Invited(2): Current user has received an invitation.
  /// Blocked(3): Current user has blocked this friend.
  state:long;
}

table TFriendsAdd {
  friends:[server.TFriendsAdd_.FriendsAdd];
}

namespace server.TFriendsAdd_;

table FriendsAdd {
  id:server.TFriendsAdd_.FriendsAdd_.Anonymous6;
}

namespace server.TFriendsAdd_.FriendsAdd_;

table Anonymous6 {
  user_id:string;
  handle:string;
}

namespace server;

table TFriendsRemove {
  user_ids:[string];
}

table TFriendsBlock {
  user_ids:[string];
}

table TFriendsList {
}

table TFriends {
  friends:[server.Friend];
}

table Group {
  /// Group ID
  id:string;
  /// Whether the group is private or public. If private, group admins will accept user join requests.
  private:bool;
  /// User ID of the group creator.
  creator_id:string;
  name:string;
  description:string;
  avatar_url:string;
  /// Language tag corresponding to the BCP 47 spec. This is important and used for Group search.
  lang:string;
  /// Offset time in millisecond from UTC.
  utc_offset_ms:long;
  /// Group metadata information.
  metadata:string;
  /// Current number of users in this group.
  count:long;
  created_at:long;
  updated_at:long;
}

table TGroupsCreate {
  groups:[server.TGroupsCreate_.GroupCreate];
}

namespace server.TGroupsCreate_;

table GroupCreate {
  /// Group name must be unique.
  name:string;
  description:string;
  avatar_url:string;
  /// Language tag corresponding to the BCP 47 spec. This is important and used for Group search.
  lang:string;
  /// Group metadata information.
  metadata:string;
  /// Whether the group is private or public. If private, group admins will accept user join requests.
  private:bool;
}

namespace server;

table TGroupsUpdate {
  groups:[server.TGroupsUpdate_.GroupUpdate];
}

namespace server.TGroupsUpdate_;

table GroupUpdate {
  group_id:string;
  /// Whether the group is private or public. If private, group admins will accept user join requests.
  private:bool;
  /// Group name must be unique.
  name:string;
  description:string;
  avatar_url:string;
  /// Language tag corresponding to the BCP 47 spec. This is important and used for Group search.
  lang:string;
  /// Set or remove metadata information.
  metadata:string;
}

namespace server;

table TGroupsRemove {
  group_ids:[string];
}

table TGroupsSelfList {
}

table TGroupsFetch {
  groups:[server.TGroupsFetch_.GroupFetch];
}

namespace server.TGroupsFetch_;

table GroupFetch {
  id:server.TGroupsFetch_.GroupFetch_.Anonymous7;
}

namespace server.TGroupsFetch_.GroupFetch_;

table Anonymous7 {
  group_id:string;
  name:string;
}

namespace server;

table TGroupsList {
  /// Upper limit on the maximum number of groups to return per request. Max value is 100.
  page_limit:long;
  /// Whether to order the result ascending or descending based on the filters defined below.
  order_by_asc:bool;
  /// Filter used to search for groups.
  filter:server.TGroupsList_.Anonymous8;
  /// Binary cursor value used to paginate results.
  /// The value of this comes from TGroups.cursor.
  cursor:string;
}

namespace server.TGroupsList_;

table Anonymous8 {
  /// Find groups matching the given language tag.
  lang:string;
  /// Find groups created after a given time.
  created_at:long;
  /// Find groups that have members up to (and equal to) the count value.
  count:long;
}

namespace server;

table TGroups {
  groups:[server.Group];
  /// Use cursor to paginate results.
  cursor:string;
}

table TGroupsSelf {
  groups_self:[server.TGroupsSelf_.GroupSelf];
}

namespace server.TGroupsSelf_;

table GroupSelf {
  /// The core group information.
  group:server.Group;
  /// The user's relationship to the group. One of:
  /// Admin(0): User is an admin for this group.
  /// Member(1): User is a regular member of this group.
  /// Join(2): User is currently waiting to be accepted in this group.
  state:long;
}

namespace server;

table GroupUser {
  user:server.User;
  /// The type of relationship this is. The value can be one of the following:
  /// Admin(0): User is an admin for this group.
  /// Member(1): User is a regular member of this group.
  /// Join(2): User is currently waiting to be accepted in this group.
  state:long;
}

table TGroupUsersList {
  group_id:string;
}

table TGroupUsers {
  users:[server.GroupUser];
}

table TGroupsJoin {
  group_ids:[string];
}

table TGroupsLeave {
  group_ids:[string];
}

table TGroupUsersAdd {
  group_users:[server.TGroupUsersAdd_.GroupUserAdd];
}

namespace server.TGroupUsersAdd_;

table GroupUserAdd {
  group_id:string;
  user_id:string;
}

namespace server;

table TGroupUsersKick {
  group_users:[server.TGroupUsersKick_.GroupUserKick];
}

namespace server.TGroupUsersKick_;

table GroupUserKick {
  group_id:string;
  user_id:string;
}

namespace server;

table TGroupUsersPromote {
  group_users:[server.TGroupUsersPromote_.GroupUserPromote];
}

namespace server.TGroupUsersPromote_;

table GroupUserPromote {
  group_id:string;
  user_id:string;
}

namespace server;

table TopicId {
  id:server.TopicId_.Anonymous9;
}

namespace server.TopicId_;

table Anonymous9 {
  dm:string;
  room:string;
  group_id:string;
}

namespace server;

table UserPresence {
  /// User ID
  user_id:string;
  /// Session ID
  session_id:string;
  /// User handle
  handle:string;
}

table TTopicsJoin {
  joins:[server.TTopicsJoin_.TopicJoin];
}

namespace server.TTopicsJoin_;

table TopicJoin {
  id:server.TTopicsJoin_.TopicJoin_.Anonymous10;
}

namespace server.TTopicsJoin_.TopicJoin_;

table Anonymous10 {
  user_id:string;
  room:string;
  group_id:string;
}

namespace server;

table TTopics {
  topics:[server.TTopics_.Topic];
}

namespace server.TTopics_;

table Topic {
  /// Chat topics
  topic:server.TopicId;
  /// List of chat presences in the topic
  presences:[server.UserPresence];
  /// Current user's chat presence
  self:server.UserPresence;
}

namespace server;

table TTopicsLeave {
  topics:[server.TopicId];
}

table TTopicMessageSend {
  topic:server.TopicId;
  data:string;
}

table TTopicMessageAck {
  message_id:string;
  created_at:long;
  expires_at:long;
  handle:string;
}

table TopicMessage {
  topic:server.TopicId;
  user_id:string;
  message_id:string;
  created_at:long;
  expires_at:long;
  handle:string;
  /// The chat message types are:
  /// Chat message (0) - Chat messages sent by users
  /// Group Join (1) - Notification - a user joined the group - send by the system
  /// Group Add (2) - Notification - a user was added/accepted to the group - send by the system
  /// Group Leave (3) - Notification - a user left the group - send by the system
  /// Group Kick (4) - Notification - a user was kicked from the group - send by the system
  /// Group Promoted (5) - Notification - a user was promoted to group admin - send by the system
  type:long;
  data:string;
}

table TTopicMessagesList {
  id:server.TTopicMessagesList_.Anonymous11;
  /// Use the cursor to paginate through more message.
  /// The value of this comes from TTopicMessages.cursor.
  cursor:string;
  forward:bool;
  limit:long;
}

namespace server.TTopicMessagesList_;

table Anonymous11 {
  user_id:string;
  room:string;
  group_id:string;
}

namespace server;

table TTopicMessages {
  messages:[server.TopicMessage];
  cursor:string;
}

table TopicPresence {
  topic:server.TopicId;
  joins:[server.UserPresence];
  leaves:[server.UserPresence];
}

table PropertyPair {
  key:string;
  value:server.PropertyPair_.Anonymous12;
}

namespace server.PropertyPair_;

/// Set of string user property
table StringSet {
  values:[string];
}

table Anonymous12 {
  string_set:server.PropertyPair_.StringSet;
  bool_value:bool;
  int_value:long;
}

namespace server;

table MatchmakeFilter {
  name:string;
  value:server.MatchmakeFilter_.Anonymous13;
}

namespace server.MatchmakeFilter_;

/// String term filters
table TermFilter {
  terms:[string];
  match_all_terms:bool;
}

/// Numeric range filter
table RangeFilter {
  lower_bound:long;
  upper_bound:long;
}

table Anonymous13 {
  term:server.MatchmakeFilter_.TermFilter;
  range:server.MatchmakeFilter_.RangeFilter;
  check:bool;
}

namespace server;

table TMatchmakeAdd {
  /// Match user with other users looking for a match with the the following number of users.
  required_count:long;
  /// List of filters that need to match.
  filters:[server.MatchmakeFilter];
  /// List of properties for the current user.
  properties:[server.PropertyPair];
}

table TMatchmakeTicket {
  ticket:string;
}

table TMatchmakeRemove {
  ticket:string;
}

table MatchmakeMatched {
  /// Matchmaking ticket. Use this to invalidate ticket cache on the client.
  ticket:string;
  /// Matchmaking token. Use this to accept the match. This is a onetime token which is only valid for a limited time.
  token:string;
  presences:[server.UserPresence];
  self:server.UserPresence;
  properties:[server.MatchmakeMatched_.UserProperty];
}

namespace server.MatchmakeMatched_;

/// Matched user presence and properties
table UserProperty {
  user_id:string;
  properties:[server.PropertyPair];
  filters:[server.MatchmakeFilter];
}

namespace server;

table Match {
  match_id:string;
  presences:[server.UserPresence];
  self:server.UserPresence;
}

table MatchPresence {
  match_id:string;
  joins:[server.UserPresence];
  leaves:[server.UserPresence];
}

table TMatchCreate {
}

table TMatch {
  match:server.Match;
}

table TMatchesJoin {
  matches:[server.TMatchesJoin_.MatchJoin];
}

namespace server.TMatchesJoin_;

table MatchJoin {
  id:server.TMatchesJoin_.MatchJoin_.Anonymous14;
}

namespace server.TMatchesJoin_.MatchJoin_;

table Anonymous14 {
  match_id:string;
  token:string;
}

namespace server;

table TMatches {
  matches:[server.Match];
}

table MatchDataSend {
  match_id:string;
  /// Custom Op code to make disguishing different message types easier.
  op_code:long;
  data:[ubyte];
  presences:[server.UserPresence];
}

table MatchData {
  match_id:string;
  presence:server.UserPresence;
  op_code:long;
  data:[ubyte];
}

table TMatchesLeave {
  match_ids:[string];
}

table TStorageList {
  user_id:string;
  bucket:string;
  collection:string;
  limit:long;
  cursor:string;
}

table TStorageFetch {
  keys:[server.TStorageFetch_.StorageKey];
}

namespace server.TStorageFetch_;

table StorageKey {
  bucket:string;
  collection:string;
  record:string;
  user_id:string;
}

namespace server;

table TStorageData {
  data:[server.TStorageData_.StorageData];
  cursor:string;
}

namespace server.TStorageData_;

table StorageData {
  bucket:string;
  collection:string;
  record:string;
  user_id:string;
  value:string;
  version:string;
  permission_read:int;
  permission_write:int;
  created_at:long;
  updated_at:long;
  expires_at:long;
}

namespace server;

table TStorageWrite {
  data:[server.TStorageWrite_.StorageData];
}

namespace server.TStorageWrite_;

table StorageData {
  bucket:string;
  collection:string;
  record:string;
  value:string;
  version:string;
  permission_read:int;
  permission_write:int;
}

namespace server;

table TStorageUpdate {
  updates:[server.TStorageUpdate_.StorageUpdate];
}

namespace server.TStorageUpdate_;

table StorageUpdate {
  key:server.TStorageUpdate_.StorageUpdate_.StorageKey;
  permission_read:int;
  permission_write:int;
  ops:[server.TStorageUpdate_.StorageUpdate_.UpdateOp];
}

namespace server.TStorageUpdate_.StorageUpdate_;

table UpdateOp {
  /// Update op code - must be one of the UpdateOpCode enums above.
  op:int;
  path:string;
  value:string;
  from:string;
  conditional:bool;
  assert:long;
  ops:[server.TStorageUpdate_.StorageUpdate_.UpdateOp];
}

table StorageKey {
  bucket:string;
  collection:string;
  record:string;
  version:string;
}

namespace server;

table TStorageKeys {
  keys:[server.TStorageKeys_.StorageKey];
}

namespace server.TStorageKeys_;

table StorageKey {
  bucket:string;
  collection:string;
  record:string;
  version:string;
}

namespace server;

table TStorageRemove {
  keys:[server.TStorageRemove_.StorageKey];
}

namespace server.TStorageRemove_;

table StorageKey {
  bucket:string;
  collection:string;
  record:string;
  version:string;
}

namespace server;

table Leaderboard {
  id:string;
  /// Whether the user can submit records directly via the client or not
  authoritative:bool;
  sort:long;
  count:long;
  reset_schedule:string;
  metadata:string;
}

table LeaderboardRecord {
  leaderboard_id:string;
  owner_id:string;
  handle:string;
  /// Language tag corresponding to the BCP 47 spec.
  lang:string;
  location:string;
  timezone:string;
  rank:long;
  score:long;
  num_score:long;
  metadata:string;
  ranked_at:long;
  updated_at:long;
  expires_at:long;
}

table TLeaderboardsList {
  limit:long;
  /// Use TLeaderboards.cursor to paginate through results.
  cursor:string;
  filter_leaderboard_id:[string];
}

table TLeaderboards {
  leaderboards:[server.Leaderboard];
  cursor:string;
}

table TLeaderboardRecordsWrite {
  records:[server.TLeaderboardRecordsWrite_.LeaderboardRecordWrite];
}

namespace server.TLeaderboardRecordsWrite_;

table LeaderboardRecordWrite {
  leaderboard_id:string;
  op:server.TLeaderboardRecordsWrite_.LeaderboardRecordWrite_.Anonymous15;
  location:string;
  timezone:string;
  metadata:string;
}

namespace server.TLeaderboardRecordsWrite_.LeaderboardRecordWrite_;

table Anonymous15 {
  incr:long;
  decr:long;
  set:long;
  best:long;
}

namespace server;

table TLeaderboardRecordsFetch {
  leaderboard_ids:[string];
  limit:long;
  /// Use TLeaderboardRecords.cursor to paginate through results.
  cursor:string;
}

table TLeaderboardRecordsList {
  leaderboard_id:string;
  filter:server.TLeaderboardRecordsList_.Anonymous16;
  limit:long;
  cursor:string;
}

namespace server.TLeaderboardRecordsList_;

table Owners {
  owner_ids:[string];
}

table Anonymous16 {
  /// Filter records by one user ID. This is the same as a "heystack" lookup
  owner_id:string;
  /// Filter records by user IDs
  owner_ids:server.TLeaderboardRecordsList_.Owners;
  lang:string;
  location:string;
  timezone:string;
}

namespace server;

table TLeaderboardRecords {
  records:[server.LeaderboardRecord];
  cursor:string;
}

table TRpc {
  id:string;
  payload:string;
}

table TPurchaseValidation {
  id:server.TPurchaseValidation_.Anonymous17;
}

namespace server.TPurchaseValidation_;

table ApplePurchase {
  product_id:string;
  receipt_data:string;
}

table GooglePurchase {
  product_id:string;
  product_type:string;
  purchase_token:string;
}

table Anonymous17 {
  apple_purchase:server.TPurchaseValidation_.ApplePurchase;
  google_purchase:server.TPurchaseValidation_.GooglePurchase;
}

namespace server;

table TPurchaseRecord {
  /// Whether or not the transaction is valid and all the information matches.
  success:bool;
  /// If this is a new transaction or if Nakama has a log of it.
  seen_before:bool;
  /// Indicates whether or not Nakama was able to reach the remote purchase service.
  purchase_provider_reachable:bool;
  /// A string indicating why the purchase verification failed, if appropriate.
  message:string;
  /// The complete response Nakama received from the remote service.
  data:string;
}

table Notification {
  id:string;
  subject:string;
  content:string;
  code:long;
  sender_id:string;
  created_at:long;
  expires_at:long;
  persistent:bool;
}

table Notifications {
  notifications:[server.Notification];
}

table TNotificationsList {
  /// Max number of notifications to list. Between 10 and 100.
  limit:long;
  /// Use this cursor to paginate notifications.
  /// Cache this to catch up to new notifications.
  /// The value of this comes from TNotifications.resumable_cursor.
  resumable_cursor:string;
}

table TNotifications {
  notifications:[server.Notification];
  /// Use this cursor to paginate notifications.
  /// Cache this to catch up to new notifications.
  resumable_cursor:string;
}

table TNotificationsRemove {
  notification_ids:[string];
}

root_type server.Envelope;
